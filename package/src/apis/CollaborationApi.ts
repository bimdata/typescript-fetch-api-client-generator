/* tslint:disable */
/* eslint-disable */
/**
 * BIMData API
 * BIMData API is a tool to interact with your models stored on BIMDataâ€™s servers.     Through the API, you can manage your projects, the clouds, upload your IFC files and manage them through endpoints.
 *
 * The version of the OpenAPI document: v1
 * Contact: contact@bimdata.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Classification,
    ClassificationFromJSON,
    ClassificationToJSON,
    Cloud,
    CloudFromJSON,
    CloudToJSON,
    CloudInvitation,
    CloudInvitationFromJSON,
    CloudInvitationToJSON,
    Document,
    DocumentFromJSON,
    DocumentToJSON,
    Folder,
    FolderFromJSON,
    FolderToJSON,
    Project,
    ProjectFromJSON,
    ProjectToJSON,
    ProjectAccessToken,
    ProjectAccessTokenFromJSON,
    ProjectAccessTokenToJSON,
    ProjectInvitation,
    ProjectInvitationFromJSON,
    ProjectInvitationToJSON,
    ProjectWithChildren,
    ProjectWithChildrenFromJSON,
    ProjectWithChildrenToJSON,
    SelfUser,
    SelfUserFromJSON,
    SelfUserToJSON,
    User,
    UserFromJSON,
    UserToJSON,
    UserCloudUpdate,
    UserCloudUpdateFromJSON,
    UserCloudUpdateToJSON,
    UserProjectUpdate,
    UserProjectUpdateFromJSON,
    UserProjectUpdateToJSON,
} from '../models';

export interface CancelCloudUserInvitationRequest {
    cloudPk: string;
    id: number;
}

export interface CancelProjectUserInvitationRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface CreateClassificationRequest {
    cloudPk: string;
    projectPk: string;
    data: Array<Classification>;
}

export interface CreateCloudRequest {
    data: Cloud;
}

export interface CreateDMSTreeRequest {
    cloudPk: string;
    id: number;
    data: Folder;
}

export interface CreateDemoRequest {
    id: number;
}

export interface CreateDocumentRequest {
    cloudPk: string;
    projectPk: string;
    name: string;
    file: Blob;
    parent?: number | null;
    parentId?: number | null;
    creator?: number | null;
    fileName?: string;
    description?: string | null;
    size?: number | null;
    ifcSource?: CreateDocumentIfcSourceEnum;
}

export interface CreateFolderRequest {
    cloudPk: string;
    projectPk: string;
    data: Folder;
}

export interface CreateProjectRequest {
    cloudPk: string;
    data: Project;
}

export interface CreateProjectAccessTokenRequest {
    cloudPk: string;
    projectPk: string;
    data: ProjectAccessToken;
}

export interface DeleteClassificationRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface DeleteCloudRequest {
    id: number;
}

export interface DeleteCloudUserRequest {
    cloudPk: string;
    id: number;
}

export interface DeleteDocumentRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface DeleteFolderRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface DeleteProjectRequest {
    cloudPk: string;
    id: number;
}

export interface DeleteProjectAccessTokenRequest {
    cloudPk: string;
    projectPk: string;
    token: string;
}

export interface DeleteProjectUserRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface FullUpdateClassificationRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    data: Classification;
}

export interface FullUpdateCloudRequest {
    id: number;
    data: Cloud;
}

export interface FullUpdateCloudUserRequest {
    cloudPk: string;
    id: number;
    data: UserCloudUpdate;
}

export interface FullUpdateDocumentRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    name: string;
    file: Blob;
    parent?: number | null;
    parentId?: number | null;
    creator?: number | null;
    fileName?: string;
    description?: string | null;
    size?: number | null;
    ifcSource?: FullUpdateDocumentIfcSourceEnum;
}

export interface FullUpdateFolderRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    data: Folder;
}

export interface FullUpdateProjectRequest {
    cloudPk: string;
    id: number;
    data: Project;
}

export interface FullUpdateProjectAccessTokenRequest {
    cloudPk: string;
    projectPk: string;
    token: string;
    data: ProjectAccessToken;
}

export interface FullUpdateProjectUserRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    data: UserProjectUpdate;
}

export interface GetClassificationRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface GetClassificationsRequest {
    cloudPk: string;
    projectPk: string;
}

export interface GetCloudRequest {
    id: number;
}

export interface GetCloudInvitationsRequest {
    cloudPk: string;
}

export interface GetCloudSizeRequest {
    id: number;
}

export interface GetCloudUserRequest {
    cloudPk: string;
    id: number;
}

export interface GetCloudUsersRequest {
    cloudPk: string;
    email?: string;
    emailContains?: string;
    emailStartswith?: string;
    emailEndswith?: string;
}

export interface GetDocumentRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface GetDocumentsRequest {
    cloudPk: string;
    projectPk: string;
}

export interface GetFolderRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface GetFoldersRequest {
    cloudPk: string;
    projectPk: string;
}

export interface GetProjectRequest {
    cloudPk: string;
    id: number;
}

export interface GetProjectAccessTokenRequest {
    cloudPk: string;
    projectPk: string;
    token: string;
}

export interface GetProjectAccessTokensRequest {
    cloudPk: string;
    projectPk: string;
}

export interface GetProjectDMSTreeRequest {
    cloudPk: string;
    id: number;
}

export interface GetProjectInvitationsRequest {
    cloudPk: string;
    projectPk: string;
}

export interface GetProjectSubTreeRequest {
    cloudPk: string;
}

export interface GetProjectTreeRequest {
    cloudPk: string;
    id: number;
}

export interface GetProjectUserRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface GetProjectUsersRequest {
    cloudPk: string;
    projectPk: string;
    email?: string;
    emailContains?: string;
    emailStartswith?: string;
    emailEndswith?: string;
}

export interface GetProjectsRequest {
    cloudPk: string;
}

export interface InviteCloudUserRequest {
    cloudPk: string;
    data: CloudInvitation;
}

export interface InviteProjectUserRequest {
    cloudPk: string;
    projectPk: string;
    data: ProjectInvitation;
}

export interface UpdateClassificationRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    data: Classification;
}

export interface UpdateCloudRequest {
    id: number;
    data: Cloud;
}

export interface UpdateCloudUserRequest {
    cloudPk: string;
    id: number;
    data: UserCloudUpdate;
}

export interface UpdateDocumentRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    data: Document;
}

export interface UpdateFolderRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    data: Folder;
}

export interface UpdateProjectRequest {
    cloudPk: string;
    id: number;
    data: Project;
}

export interface UpdateProjectAccessTokenRequest {
    cloudPk: string;
    projectPk: string;
    token: string;
    data: ProjectAccessToken;
}

export interface UpdateProjectUserRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    data: UserProjectUpdate;
}

export interface UpdateSelfUserRequest {
    data: SelfUser;
}

/**
 * no description
 */
export class CollaborationApi extends runtime.BaseAPI {

    /**
     * Cancel a pending invitation Required scopes: org:manage
     * Cancel a pending invitation
     */
    async cancelCloudUserInvitationRaw(requestParameters: CancelCloudUserInvitationRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling cancelCloudUserInvitation.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling cancelCloudUserInvitation.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/invitation/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Cancel a pending invitation Required scopes: org:manage
     * Cancel a pending invitation
     */
    async cancelCloudUserInvitation(requestParameters: CancelCloudUserInvitationRequest): Promise<void> {
        await this.cancelCloudUserInvitationRaw(requestParameters);
    }

    /**
     *  Required scopes: org:manage
     * Cancel a pending invitation
     */
    async cancelProjectUserInvitationRaw(requestParameters: CancelProjectUserInvitationRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling cancelProjectUserInvitation.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling cancelProjectUserInvitation.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling cancelProjectUserInvitation.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/invitation/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Required scopes: org:manage
     * Cancel a pending invitation
     */
    async cancelProjectUserInvitation(requestParameters: CancelProjectUserInvitationRequest): Promise<void> {
        await this.cancelProjectUserInvitationRaw(requestParameters);
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors      If created classification already exists, it will not be duplicated and the previous one will be returned.     You also can add a \'classification\' filter on this endpoint. By ex: /classification?name=\'untec\'. The name is case sensitive  Required scopes: ifc:write
     * Create a classification
     */
    async createClassificationRaw(requestParameters: CreateClassificationRequest): Promise<runtime.ApiResponse<Array<Classification>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createClassification.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createClassification.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createClassification.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/classification`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(ClassificationToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClassificationFromJSON));
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors      If created classification already exists, it will not be duplicated and the previous one will be returned.     You also can add a \'classification\' filter on this endpoint. By ex: /classification?name=\'untec\'. The name is case sensitive  Required scopes: ifc:write
     * Create a classification
     */
    async createClassification(requestParameters: CreateClassificationRequest): Promise<Array<Classification>> {
        const response = await this.createClassificationRaw(requestParameters);
        return await response.value();
    }

    /**
     *  Required scopes: cloud:manage
     * Create a cloud
     */
    async createCloudRaw(requestParameters: CreateCloudRequest): Promise<runtime.ApiResponse<Cloud>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createCloud.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CloudToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CloudFromJSON(jsonValue));
    }

    /**
     *  Required scopes: cloud:manage
     * Create a cloud
     */
    async createCloud(requestParameters: CreateCloudRequest): Promise<Cloud> {
        const response = await this.createCloudRaw(requestParameters);
        return await response.value();
    }

    /**
     *                  Create a DMS structure of folder                 Format request :                     [{                         \"name\": :name:                         \"parent_id\": :parent_id:    # optionnal                         \"children\": [{              # optionnal                             \"name\": :name:,                             \"children\": []                         }]                     }],  Required scopes: org:manage
     * Create a complete DMS tree
     */
    async createDMSTreeRaw(requestParameters: CreateDMSTreeRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createDMSTree.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling createDMSTree.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createDMSTree.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{id}/dms-tree`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FolderToJSON(requestParameters.data),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *                  Create a DMS structure of folder                 Format request :                     [{                         \"name\": :name:                         \"parent_id\": :parent_id:    # optionnal                         \"children\": [{              # optionnal                             \"name\": :name:,                             \"children\": []                         }]                     }],  Required scopes: org:manage
     * Create a complete DMS tree
     */
    async createDMSTree(requestParameters: CreateDMSTreeRequest): Promise<void> {
        await this.createDMSTreeRaw(requestParameters);
    }

    /**
     * Create a demo project with a pre-populated IFC and its data Required scopes: cloud:manage
     * Create a Demo project in a cloud
     */
    async createDemoRaw(requestParameters: CreateDemoRequest): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling createDemo.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{id}/create-demo`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     * Create a demo project with a pre-populated IFC and its data Required scopes: cloud:manage
     * Create a Demo project in a cloud
     */
    async createDemo(requestParameters: CreateDemoRequest): Promise<Project> {
        const response = await this.createDemoRaw(requestParameters);
        return await response.value();
    }

    /**
     * RCreate a document. If the document is an IFC, an IFC model will be created and attached to this document Required scopes: document:write
     * Create a document
     */
    async createDocumentRaw(requestParameters: CreateDocumentRequest): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createDocument.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createDocument.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling createDocument.');
        }

        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling createDocument.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.parent !== undefined) {
            formParams.append('parent', requestParameters.parent as any);
        }

        if (requestParameters.parentId !== undefined) {
            formParams.append('parent_id', requestParameters.parentId as any);
        }

        if (requestParameters.creator !== undefined) {
            formParams.append('creator', requestParameters.creator as any);
        }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        if (requestParameters.fileName !== undefined) {
            formParams.append('file_name', requestParameters.fileName as any);
        }

        if (requestParameters.description !== undefined) {
            formParams.append('description', requestParameters.description as any);
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.size !== undefined) {
            formParams.append('size', requestParameters.size as any);
        }

        if (requestParameters.ifcSource !== undefined) {
            formParams.append('ifc_source', requestParameters.ifcSource as any);
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/document`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * RCreate a document. If the document is an IFC, an IFC model will be created and attached to this document Required scopes: document:write
     * Create a document
     */
    async createDocument(requestParameters: CreateDocumentRequest): Promise<Document> {
        const response = await this.createDocumentRaw(requestParameters);
        return await response.value();
    }

    /**
     * If the created folder have no parent, it will be put as a child of the default root folder of the project Required scopes: document:write
     * Create a folder
     */
    async createFolderRaw(requestParameters: CreateFolderRequest): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createFolder.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createFolder.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createFolder.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/folder`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FolderToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * If the created folder have no parent, it will be put as a child of the default root folder of the project Required scopes: document:write
     * Create a folder
     */
    async createFolder(requestParameters: CreateFolderRequest): Promise<Folder> {
        const response = await this.createFolderRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a project Required scopes: org:manage
     * Create a project
     */
    async createProjectRaw(requestParameters: CreateProjectRequest): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createProject.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createProject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     * Create a project Required scopes: org:manage
     * Create a project
     */
    async createProject(requestParameters: CreateProjectRequest): Promise<Project> {
        const response = await this.createProjectRaw(requestParameters);
        return await response.value();
    }

    /**
     * Tokens are valid 1 day by default Required scopes: org:manage
     * Create a token for this project
     */
    async createProjectAccessTokenRaw(requestParameters: CreateProjectAccessTokenRequest): Promise<runtime.ApiResponse<ProjectAccessToken>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createProjectAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createProjectAccessToken.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createProjectAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/access-token`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectAccessTokenToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectAccessTokenFromJSON(jsonValue));
    }

    /**
     * Tokens are valid 1 day by default Required scopes: org:manage
     * Create a token for this project
     */
    async createProjectAccessToken(requestParameters: CreateProjectAccessTokenRequest): Promise<ProjectAccessToken> {
        const response = await this.createProjectAccessTokenRaw(requestParameters);
        return await response.value();
    }

    /**
     * All elements having this classification will lose it Required scopes: ifc:write
     * Delete a classification
     */
    async deleteClassificationRaw(requestParameters: DeleteClassificationRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteClassification.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteClassification.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteClassification.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/classification/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * All elements having this classification will lose it Required scopes: ifc:write
     * Delete a classification
     */
    async deleteClassification(requestParameters: DeleteClassificationRequest): Promise<void> {
        await this.deleteClassificationRaw(requestParameters);
    }

    /**
     *  Required scopes: cloud:manage
     * Delete a cloud
     */
    async deleteCloudRaw(requestParameters: DeleteCloudRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteCloud.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Required scopes: cloud:manage
     * Delete a cloud
     */
    async deleteCloud(requestParameters: DeleteCloudRequest): Promise<void> {
        await this.deleteCloudRaw(requestParameters);
    }

    /**
     * The user will also be removed from all the projects of the cloud Required scopes: cloud:manage
     * Remove a user from a cloud
     */
    async deleteCloudUserRaw(requestParameters: DeleteCloudUserRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteCloudUser.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteCloudUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/user/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The user will also be removed from all the projects of the cloud Required scopes: cloud:manage
     * Remove a user from a cloud
     */
    async deleteCloudUser(requestParameters: DeleteCloudUserRequest): Promise<void> {
        await this.deleteCloudUserRaw(requestParameters);
    }

    /**
     * Delete the document Required scopes: document:write
     * Delete the document
     */
    async deleteDocumentRaw(requestParameters: DeleteDocumentRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteDocument.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteDocument.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteDocument.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/document/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the document Required scopes: document:write
     * Delete the document
     */
    async deleteDocument(requestParameters: DeleteDocumentRequest): Promise<void> {
        await this.deleteDocumentRaw(requestParameters);
    }

    /**
     * All files and subfolders will be deleted too. If folder is a project\'s root folder, only children are deleted Required scopes: document:write
     * Delete a folder
     */
    async deleteFolderRaw(requestParameters: DeleteFolderRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteFolder.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteFolder.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteFolder.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/folder/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * All files and subfolders will be deleted too. If folder is a project\'s root folder, only children are deleted Required scopes: document:write
     * Delete a folder
     */
    async deleteFolder(requestParameters: DeleteFolderRequest): Promise<void> {
        await this.deleteFolderRaw(requestParameters);
    }

    /**
     * It can take a long time to respond because we may need to delete all properties of all elements of all models in the project Required scopes: org:manage
     * Delete a project
     */
    async deleteProjectRaw(requestParameters: DeleteProjectRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteProject.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteProject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * It can take a long time to respond because we may need to delete all properties of all elements of all models in the project Required scopes: org:manage
     * Delete a project
     */
    async deleteProject(requestParameters: DeleteProjectRequest): Promise<void> {
        await this.deleteProjectRaw(requestParameters);
    }

    /**
     * Deleting a token will revoke it Required scopes: org:manage
     * Delete a token
     */
    async deleteProjectAccessTokenRaw(requestParameters: DeleteProjectAccessTokenRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteProjectAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteProjectAccessToken.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling deleteProjectAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/access-token/{token}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deleting a token will revoke it Required scopes: org:manage
     * Delete a token
     */
    async deleteProjectAccessToken(requestParameters: DeleteProjectAccessTokenRequest): Promise<void> {
        await this.deleteProjectAccessTokenRaw(requestParameters);
    }

    /**
     * Remove a user from a project Required scopes: cloud:manage
     * Remove a user from a project
     */
    async deleteProjectUserRaw(requestParameters: DeleteProjectUserRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteProjectUser.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteProjectUser.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteProjectUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/user/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a user from a project Required scopes: cloud:manage
     * Remove a user from a project
     */
    async deleteProjectUser(requestParameters: DeleteProjectUserRequest): Promise<void> {
        await this.deleteProjectUserRaw(requestParameters);
    }

    /**
     * Update all fields of a classification Required scopes: ifc:write
     * Update all fields of a classification
     */
    async fullUpdateClassificationRaw(requestParameters: FullUpdateClassificationRequest): Promise<runtime.ApiResponse<Classification>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling fullUpdateClassification.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling fullUpdateClassification.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling fullUpdateClassification.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateClassification.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/classification/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ClassificationToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ClassificationFromJSON(jsonValue));
    }

    /**
     * Update all fields of a classification Required scopes: ifc:write
     * Update all fields of a classification
     */
    async fullUpdateClassification(requestParameters: FullUpdateClassificationRequest): Promise<Classification> {
        const response = await this.fullUpdateClassificationRaw(requestParameters);
        return await response.value();
    }

    /**
     *  Required scopes: cloud:manage
     * Update all fields of a cloud
     */
    async fullUpdateCloudRaw(requestParameters: FullUpdateCloudRequest): Promise<runtime.ApiResponse<Cloud>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling fullUpdateCloud.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateCloud.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CloudToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CloudFromJSON(jsonValue));
    }

    /**
     *  Required scopes: cloud:manage
     * Update all fields of a cloud
     */
    async fullUpdateCloud(requestParameters: FullUpdateCloudRequest): Promise<Cloud> {
        const response = await this.fullUpdateCloudRaw(requestParameters);
        return await response.value();
    }

    /**
     * Change the user role in the cloud Required scopes: cloud:manage
     * Update all fields of a cloud user
     */
    async fullUpdateCloudUserRaw(requestParameters: FullUpdateCloudUserRequest): Promise<runtime.ApiResponse<User>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling fullUpdateCloudUser.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling fullUpdateCloudUser.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateCloudUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/user/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserCloudUpdateToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Change the user role in the cloud Required scopes: cloud:manage
     * Update all fields of a cloud user
     */
    async fullUpdateCloudUser(requestParameters: FullUpdateCloudUserRequest): Promise<User> {
        const response = await this.fullUpdateCloudUserRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update all fields of the document Required scopes: document:write
     * Update all fields of the document
     */
    async fullUpdateDocumentRaw(requestParameters: FullUpdateDocumentRequest): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling fullUpdateDocument.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling fullUpdateDocument.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling fullUpdateDocument.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling fullUpdateDocument.');
        }

        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling fullUpdateDocument.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.parent !== undefined) {
            formParams.append('parent', requestParameters.parent as any);
        }

        if (requestParameters.parentId !== undefined) {
            formParams.append('parent_id', requestParameters.parentId as any);
        }

        if (requestParameters.creator !== undefined) {
            formParams.append('creator', requestParameters.creator as any);
        }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        if (requestParameters.fileName !== undefined) {
            formParams.append('file_name', requestParameters.fileName as any);
        }

        if (requestParameters.description !== undefined) {
            formParams.append('description', requestParameters.description as any);
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.size !== undefined) {
            formParams.append('size', requestParameters.size as any);
        }

        if (requestParameters.ifcSource !== undefined) {
            formParams.append('ifc_source', requestParameters.ifcSource as any);
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/document/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Update all fields of the document Required scopes: document:write
     * Update all fields of the document
     */
    async fullUpdateDocument(requestParameters: FullUpdateDocumentRequest): Promise<Document> {
        const response = await this.fullUpdateDocumentRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update all fields of a folder Required scopes: document:write
     * Update all fields of a folder
     */
    async fullUpdateFolderRaw(requestParameters: FullUpdateFolderRequest): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling fullUpdateFolder.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling fullUpdateFolder.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling fullUpdateFolder.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateFolder.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/folder/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FolderToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Update all fields of a folder Required scopes: document:write
     * Update all fields of a folder
     */
    async fullUpdateFolder(requestParameters: FullUpdateFolderRequest): Promise<Folder> {
        const response = await this.fullUpdateFolderRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update all fields of a project Required scopes: org:manage
     * Update all fields of a project
     */
    async fullUpdateProjectRaw(requestParameters: FullUpdateProjectRequest): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling fullUpdateProject.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling fullUpdateProject.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateProject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     * Update all fields of a project Required scopes: org:manage
     * Update all fields of a project
     */
    async fullUpdateProject(requestParameters: FullUpdateProjectRequest): Promise<Project> {
        const response = await this.fullUpdateProjectRaw(requestParameters);
        return await response.value();
    }

    /**
     * You can update the expiration date field Required scopes: org:manage
     * Update all fields of a token
     */
    async fullUpdateProjectAccessTokenRaw(requestParameters: FullUpdateProjectAccessTokenRequest): Promise<runtime.ApiResponse<ProjectAccessToken>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling fullUpdateProjectAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling fullUpdateProjectAccessToken.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling fullUpdateProjectAccessToken.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateProjectAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/access-token/{token}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectAccessTokenToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectAccessTokenFromJSON(jsonValue));
    }

    /**
     * You can update the expiration date field Required scopes: org:manage
     * Update all fields of a token
     */
    async fullUpdateProjectAccessToken(requestParameters: FullUpdateProjectAccessTokenRequest): Promise<ProjectAccessToken> {
        const response = await this.fullUpdateProjectAccessTokenRaw(requestParameters);
        return await response.value();
    }

    /**
     * Change the user role in the cloud Required scopes: cloud:manage
     * Update all fields of a project user
     */
    async fullUpdateProjectUserRaw(requestParameters: FullUpdateProjectUserRequest): Promise<runtime.ApiResponse<User>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling fullUpdateProjectUser.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling fullUpdateProjectUser.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling fullUpdateProjectUser.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateProjectUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/user/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserProjectUpdateToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Change the user role in the cloud Required scopes: cloud:manage
     * Update all fields of a project user
     */
    async fullUpdateProjectUser(requestParameters: FullUpdateProjectUserRequest): Promise<User> {
        const response = await this.fullUpdateProjectUserRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a classification Required scopes: ifc:read
     * Retrieve a classification
     */
    async getClassificationRaw(requestParameters: GetClassificationRequest): Promise<runtime.ApiResponse<Classification>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getClassification.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getClassification.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getClassification.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/classification/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ClassificationFromJSON(jsonValue));
    }

    /**
     * Retrieve a classification Required scopes: ifc:read
     * Retrieve a classification
     */
    async getClassification(requestParameters: GetClassificationRequest): Promise<Classification> {
        const response = await this.getClassificationRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all classifications of all models in the project Required scopes: ifc:read
     * Retrieve all classifications
     */
    async getClassificationsRaw(requestParameters: GetClassificationsRequest): Promise<runtime.ApiResponse<Array<Classification>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getClassifications.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getClassifications.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/classification`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClassificationFromJSON));
    }

    /**
     * Retrieve all classifications of all models in the project Required scopes: ifc:read
     * Retrieve all classifications
     */
    async getClassifications(requestParameters: GetClassificationsRequest): Promise<Array<Classification>> {
        const response = await this.getClassificationsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve one cloud
     */
    async getCloudRaw(requestParameters: GetCloudRequest): Promise<runtime.ApiResponse<Cloud>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getCloud.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CloudFromJSON(jsonValue));
    }

    /**
     * Retrieve one cloud
     */
    async getCloud(requestParameters: GetCloudRequest): Promise<Cloud> {
        const response = await this.getCloudRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns app\'s invitations only Required scopes: org:manage
     * Retrieve all pending invitations in the cloud
     */
    async getCloudInvitationsRaw(requestParameters: GetCloudInvitationsRequest): Promise<runtime.ApiResponse<Array<CloudInvitation>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getCloudInvitations.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/invitation`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CloudInvitationFromJSON));
    }

    /**
     * Returns app\'s invitations only Required scopes: org:manage
     * Retrieve all pending invitations in the cloud
     */
    async getCloudInvitations(requestParameters: GetCloudInvitationsRequest): Promise<Array<CloudInvitation>> {
        const response = await this.getCloudInvitationsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the size of the cloud in Bytes
     * Get size of all ifc files in the cloud
     */
    async getCloudSizeRaw(requestParameters: GetCloudSizeRequest): Promise<runtime.ApiResponse<number>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getCloudSize.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{id}/size`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns the size of the cloud in Bytes
     * Get size of all ifc files in the cloud
     */
    async getCloudSize(requestParameters: GetCloudSizeRequest): Promise<number> {
        const response = await this.getCloudSizeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Only administrators can see a cloud member Required scopes: cloud:read
     * Retrieve a user in a cloud
     */
    async getCloudUserRaw(requestParameters: GetCloudUserRequest): Promise<runtime.ApiResponse<User>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getCloudUser.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getCloudUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/user/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Only administrators can see a cloud member Required scopes: cloud:read
     * Retrieve a user in a cloud
     */
    async getCloudUser(requestParameters: GetCloudUserRequest): Promise<User> {
        const response = await this.getCloudUserRaw(requestParameters);
        return await response.value();
    }

    /**
     * Only administrators can see cloud members. Required scopes: cloud:read
     * Retrieve all users in a cloud, or a list with a filter by email
     */
    async getCloudUsersRaw(requestParameters: GetCloudUsersRequest): Promise<runtime.ApiResponse<Array<User>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getCloudUsers.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.email !== undefined) {
            queryParameters['email'] = requestParameters.email;
        }

        if (requestParameters.emailContains !== undefined) {
            queryParameters['email__contains'] = requestParameters.emailContains;
        }

        if (requestParameters.emailStartswith !== undefined) {
            queryParameters['email__startswith'] = requestParameters.emailStartswith;
        }

        if (requestParameters.emailEndswith !== undefined) {
            queryParameters['email__endswith'] = requestParameters.emailEndswith;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/user`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserFromJSON));
    }

    /**
     * Only administrators can see cloud members. Required scopes: cloud:read
     * Retrieve all users in a cloud, or a list with a filter by email
     */
    async getCloudUsers(requestParameters: GetCloudUsersRequest): Promise<Array<User>> {
        const response = await this.getCloudUsersRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns user\'s (or app\'s) clouds only
     * Retrieve all clouds
     */
    async getCloudsRaw(): Promise<runtime.ApiResponse<Array<Cloud>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CloudFromJSON));
    }

    /**
     * Returns user\'s (or app\'s) clouds only
     * Retrieve all clouds
     */
    async getClouds(): Promise<Array<Cloud>> {
        const response = await this.getCloudsRaw();
        return await response.value();
    }

    /**
     * Retrieve a document in the project Required scopes: document:read
     * Retrieve a document
     */
    async getDocumentRaw(requestParameters: GetDocumentRequest): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getDocument.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getDocument.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getDocument.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/document/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Retrieve a document in the project Required scopes: document:read
     * Retrieve a document
     */
    async getDocument(requestParameters: GetDocumentRequest): Promise<Document> {
        const response = await this.getDocumentRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all documents in the project Required scopes: document:read
     * Retrieve all documents
     */
    async getDocumentsRaw(requestParameters: GetDocumentsRequest): Promise<runtime.ApiResponse<Array<Document>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getDocuments.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getDocuments.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/document`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DocumentFromJSON));
    }

    /**
     * Retrieve all documents in the project Required scopes: document:read
     * Retrieve all documents
     */
    async getDocuments(requestParameters: GetDocumentsRequest): Promise<Array<Document>> {
        const response = await this.getDocumentsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a folder Required scopes: document:read
     * Retrieve a folder
     */
    async getFolderRaw(requestParameters: GetFolderRequest): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getFolder.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFolder.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getFolder.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/folder/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Retrieve a folder Required scopes: document:read
     * Retrieve a folder
     */
    async getFolder(requestParameters: GetFolderRequest): Promise<Folder> {
        const response = await this.getFolderRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all folders in the project. This is an array of folder. If you want to get the tree of all folders, see getProjectTree Required scopes: document:read
     * Retrieve all folders
     */
    async getFoldersRaw(requestParameters: GetFoldersRequest): Promise<runtime.ApiResponse<Array<Folder>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getFolders.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getFolders.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/folder`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FolderFromJSON));
    }

    /**
     * Retrieve all folders in the project. This is an array of folder. If you want to get the tree of all folders, see getProjectTree Required scopes: document:read
     * Retrieve all folders
     */
    async getFolders(requestParameters: GetFoldersRequest): Promise<Array<Folder>> {
        const response = await this.getFoldersRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a project
     * Retrieve a project
     */
    async getProjectRaw(requestParameters: GetProjectRequest): Promise<runtime.ApiResponse<ProjectWithChildren>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProject.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getProject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectWithChildrenFromJSON(jsonValue));
    }

    /**
     * Retrieve a project
     * Retrieve a project
     */
    async getProject(requestParameters: GetProjectRequest): Promise<ProjectWithChildren> {
        const response = await this.getProjectRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve one token created for this project Required scopes: org:manage
     * Retrieve one token created for this project
     */
    async getProjectAccessTokenRaw(requestParameters: GetProjectAccessTokenRequest): Promise<runtime.ApiResponse<ProjectAccessToken>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProjectAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getProjectAccessToken.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling getProjectAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/access-token/{token}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectAccessTokenFromJSON(jsonValue));
    }

    /**
     * Retrieve one token created for this project Required scopes: org:manage
     * Retrieve one token created for this project
     */
    async getProjectAccessToken(requestParameters: GetProjectAccessTokenRequest): Promise<ProjectAccessToken> {
        const response = await this.getProjectAccessTokenRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all tokens created for this project Required scopes: org:manage
     * Retrieve all tokens created for this project
     */
    async getProjectAccessTokensRaw(requestParameters: GetProjectAccessTokensRequest): Promise<runtime.ApiResponse<Array<ProjectAccessToken>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProjectAccessTokens.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getProjectAccessTokens.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/access-token`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProjectAccessTokenFromJSON));
    }

    /**
     * Retrieve all tokens created for this project Required scopes: org:manage
     * Retrieve all tokens created for this project
     */
    async getProjectAccessTokens(requestParameters: GetProjectAccessTokensRequest): Promise<Array<ProjectAccessToken>> {
        const response = await this.getProjectAccessTokensRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve the complete DMS tree (all folders and all documents in the project)
     * Retrieve the complete DMS tree
     */
    async getProjectDMSTreeRaw(requestParameters: GetProjectDMSTreeRequest): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProjectDMSTree.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getProjectDMSTree.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{id}/dms-tree`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Retrieve the complete DMS tree (all folders and all documents in the project)
     * Retrieve the complete DMS tree
     */
    async getProjectDMSTree(requestParameters: GetProjectDMSTreeRequest): Promise<Folder> {
        const response = await this.getProjectDMSTreeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns app\'s invitations only Required scopes: org:manage
     * Retrieve all pending invitations in the project
     */
    async getProjectInvitationsRaw(requestParameters: GetProjectInvitationsRequest): Promise<runtime.ApiResponse<Array<ProjectInvitation>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProjectInvitations.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getProjectInvitations.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/invitation`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProjectInvitationFromJSON));
    }

    /**
     * Returns app\'s invitations only Required scopes: org:manage
     * Retrieve all pending invitations in the project
     */
    async getProjectInvitations(requestParameters: GetProjectInvitationsRequest): Promise<Array<ProjectInvitation>> {
        const response = await this.getProjectInvitationsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve the complete projects tree of the cloud
     * Retrieve the complete projects tree of the cloud
     */
    async getProjectSubTreeRaw(requestParameters: GetProjectSubTreeRequest): Promise<runtime.ApiResponse<Array<ProjectWithChildren>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProjectSubTree.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/subtree`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProjectWithChildrenFromJSON));
    }

    /**
     * Retrieve the complete projects tree of the cloud
     * Retrieve the complete projects tree of the cloud
     */
    async getProjectSubTree(requestParameters: GetProjectSubTreeRequest): Promise<Array<ProjectWithChildren>> {
        const response = await this.getProjectSubTreeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve the complete DMS tree (all folders and all documents in the project). DEPRECATED: renamed to getProjectDMSTree
     * Retrieve the complete DMS tree
     */
    async getProjectTreeRaw(requestParameters: GetProjectTreeRequest): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProjectTree.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getProjectTree.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{id}/tree`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Retrieve the complete DMS tree (all folders and all documents in the project). DEPRECATED: renamed to getProjectDMSTree
     * Retrieve the complete DMS tree
     */
    async getProjectTree(requestParameters: GetProjectTreeRequest): Promise<Folder> {
        const response = await this.getProjectTreeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Each member of a project can see other members of the project Required scopes: cloud:read
     * Retrieve a user in a project
     */
    async getProjectUserRaw(requestParameters: GetProjectUserRequest): Promise<runtime.ApiResponse<User>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProjectUser.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getProjectUser.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getProjectUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/user/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Each member of a project can see other members of the project Required scopes: cloud:read
     * Retrieve a user in a project
     */
    async getProjectUser(requestParameters: GetProjectUserRequest): Promise<User> {
        const response = await this.getProjectUserRaw(requestParameters);
        return await response.value();
    }

    /**
     * Each member of a project can see other members of the project Required scopes: cloud:read
     * Retrieve all users in a project, or a list with a filter by email
     */
    async getProjectUsersRaw(requestParameters: GetProjectUsersRequest): Promise<runtime.ApiResponse<Array<User>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProjectUsers.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getProjectUsers.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.email !== undefined) {
            queryParameters['email'] = requestParameters.email;
        }

        if (requestParameters.emailContains !== undefined) {
            queryParameters['email__contains'] = requestParameters.emailContains;
        }

        if (requestParameters.emailStartswith !== undefined) {
            queryParameters['email__startswith'] = requestParameters.emailStartswith;
        }

        if (requestParameters.emailEndswith !== undefined) {
            queryParameters['email__endswith'] = requestParameters.emailEndswith;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/user`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserFromJSON));
    }

    /**
     * Each member of a project can see other members of the project Required scopes: cloud:read
     * Retrieve all users in a project, or a list with a filter by email
     */
    async getProjectUsers(requestParameters: GetProjectUsersRequest): Promise<Array<User>> {
        const response = await this.getProjectUsersRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all projects of the cloud. All project are shown at the same level. see #getProjectSubTree
     * Retrieve all projects
     */
    async getProjectsRaw(requestParameters: GetProjectsRequest): Promise<runtime.ApiResponse<Array<Project>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProjects.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProjectFromJSON));
    }

    /**
     * Retrieve all projects of the cloud. All project are shown at the same level. see #getProjectSubTree
     * Retrieve all projects
     */
    async getProjects(requestParameters: GetProjectsRequest): Promise<Array<Project>> {
        const response = await this.getProjectsRaw(requestParameters);
        return await response.value();
    }

    /**
     * List user\'s projects of all clouds Required scopes: user:read
     * List current user\'s projects
     */
    async getSelfProjectsRaw(): Promise<runtime.ApiResponse<Array<Project>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/user/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProjectFromJSON));
    }

    /**
     * List user\'s projects of all clouds Required scopes: user:read
     * List current user\'s projects
     */
    async getSelfProjects(): Promise<Array<Project>> {
        const response = await this.getSelfProjectsRaw();
        return await response.value();
    }

    /**
     * Get info about the current user
     * Get info about the current user
     */
    async getSelfUserRaw(): Promise<runtime.ApiResponse<SelfUser>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/user`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SelfUserFromJSON(jsonValue));
    }

    /**
     * Get info about the current user
     * Get info about the current user
     */
    async getSelfUser(): Promise<SelfUser> {
        const response = await this.getSelfUserRaw();
        return await response.value();
    }

    /**
     * Invite cloud administrators only. To invite in a project, see inviteProjectUser. You can\'t invite a user already in the cloud. Create multiple invitations of the same email in the same cloud will generate multiple invitation emails but not multiple invitation object Required scopes: org:manage
     * Invite a cloud administrator
     */
    async inviteCloudUserRaw(requestParameters: InviteCloudUserRequest): Promise<runtime.ApiResponse<CloudInvitation>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling inviteCloudUser.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling inviteCloudUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/invitation`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CloudInvitationToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CloudInvitationFromJSON(jsonValue));
    }

    /**
     * Invite cloud administrators only. To invite in a project, see inviteProjectUser. You can\'t invite a user already in the cloud. Create multiple invitations of the same email in the same cloud will generate multiple invitation emails but not multiple invitation object Required scopes: org:manage
     * Invite a cloud administrator
     */
    async inviteCloudUser(requestParameters: InviteCloudUserRequest): Promise<CloudInvitation> {
        const response = await this.inviteCloudUserRaw(requestParameters);
        return await response.value();
    }

    /**
     * Invite a project member. If the user is not already a cloud member, they will also be invited in the cloud with USER role. Required scopes: org:manage
     * Invite a project member
     */
    async inviteProjectUserRaw(requestParameters: InviteProjectUserRequest): Promise<runtime.ApiResponse<ProjectInvitation>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling inviteProjectUser.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling inviteProjectUser.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling inviteProjectUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/invitation`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectInvitationToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectInvitationFromJSON(jsonValue));
    }

    /**
     * Invite a project member. If the user is not already a cloud member, they will also be invited in the cloud with USER role. Required scopes: org:manage
     * Invite a project member
     */
    async inviteProjectUser(requestParameters: InviteProjectUserRequest): Promise<ProjectInvitation> {
        const response = await this.inviteProjectUserRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a classification Required scopes: ifc:write
     * Update some fields of a classification
     */
    async updateClassificationRaw(requestParameters: UpdateClassificationRequest): Promise<runtime.ApiResponse<Classification>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateClassification.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateClassification.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateClassification.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateClassification.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/classification/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ClassificationToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ClassificationFromJSON(jsonValue));
    }

    /**
     * Update some fields of a classification Required scopes: ifc:write
     * Update some fields of a classification
     */
    async updateClassification(requestParameters: UpdateClassificationRequest): Promise<Classification> {
        const response = await this.updateClassificationRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a cloud Required scopes: cloud:manage
     * Update some fields of a cloud
     */
    async updateCloudRaw(requestParameters: UpdateCloudRequest): Promise<runtime.ApiResponse<Cloud>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateCloud.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateCloud.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: CloudToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CloudFromJSON(jsonValue));
    }

    /**
     * Update some fields of a cloud Required scopes: cloud:manage
     * Update some fields of a cloud
     */
    async updateCloud(requestParameters: UpdateCloudRequest): Promise<Cloud> {
        const response = await this.updateCloudRaw(requestParameters);
        return await response.value();
    }

    /**
     * Change the user role in the cloud Required scopes: cloud:manage
     * Update some fields of a cloud user
     */
    async updateCloudUserRaw(requestParameters: UpdateCloudUserRequest): Promise<runtime.ApiResponse<User>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateCloudUser.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateCloudUser.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateCloudUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/user/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UserCloudUpdateToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Change the user role in the cloud Required scopes: cloud:manage
     * Update some fields of a cloud user
     */
    async updateCloudUser(requestParameters: UpdateCloudUserRequest): Promise<User> {
        const response = await this.updateCloudUserRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of the document Required scopes: document:write
     * Update some fields of the document
     */
    async updateDocumentRaw(requestParameters: UpdateDocumentRequest): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateDocument.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateDocument.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateDocument.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateDocument.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/document/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Update some fields of the document Required scopes: document:write
     * Update some fields of the document
     */
    async updateDocument(requestParameters: UpdateDocumentRequest): Promise<Document> {
        const response = await this.updateDocumentRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a folder Required scopes: document:write
     * Update some fields of a folder
     */
    async updateFolderRaw(requestParameters: UpdateFolderRequest): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateFolder.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateFolder.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateFolder.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateFolder.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/folder/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: FolderToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Update some fields of a folder Required scopes: document:write
     * Update some fields of a folder
     */
    async updateFolder(requestParameters: UpdateFolderRequest): Promise<Folder> {
        const response = await this.updateFolderRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a project Required scopes: org:manage
     * Update some fields of a project
     */
    async updateProjectRaw(requestParameters: UpdateProjectRequest): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateProject.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateProject.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateProject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     * Update some fields of a project Required scopes: org:manage
     * Update some fields of a project
     */
    async updateProject(requestParameters: UpdateProjectRequest): Promise<Project> {
        const response = await this.updateProjectRaw(requestParameters);
        return await response.value();
    }

    /**
     * You can update the expiration date field Required scopes: org:manage
     * Update some fields of a token
     */
    async updateProjectAccessTokenRaw(requestParameters: UpdateProjectAccessTokenRequest): Promise<runtime.ApiResponse<ProjectAccessToken>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateProjectAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateProjectAccessToken.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling updateProjectAccessToken.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateProjectAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/access-token/{token}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectAccessTokenToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectAccessTokenFromJSON(jsonValue));
    }

    /**
     * You can update the expiration date field Required scopes: org:manage
     * Update some fields of a token
     */
    async updateProjectAccessToken(requestParameters: UpdateProjectAccessTokenRequest): Promise<ProjectAccessToken> {
        const response = await this.updateProjectAccessTokenRaw(requestParameters);
        return await response.value();
    }

    /**
     * Change the user role in the cloud Required scopes: cloud:manage
     * Update some fields of a project user
     */
    async updateProjectUserRaw(requestParameters: UpdateProjectUserRequest): Promise<runtime.ApiResponse<User>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateProjectUser.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateProjectUser.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateProjectUser.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateProjectUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/user/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UserProjectUpdateToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * Change the user role in the cloud Required scopes: cloud:manage
     * Update some fields of a project user
     */
    async updateProjectUser(requestParameters: UpdateProjectUserRequest): Promise<User> {
        const response = await this.updateProjectUserRaw(requestParameters);
        return await response.value();
    }

    /**
     * DEPRECATED. The user must be updated on its identity provider
     * Update info of the current user
     */
    async updateSelfUserRaw(requestParameters: UpdateSelfUserRequest): Promise<runtime.ApiResponse<SelfUser>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateSelfUser.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/user`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SelfUserToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SelfUserFromJSON(jsonValue));
    }

    /**
     * DEPRECATED. The user must be updated on its identity provider
     * Update info of the current user
     */
    async updateSelfUser(requestParameters: UpdateSelfUserRequest): Promise<SelfUser> {
        const response = await this.updateSelfUserRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum CreateDocumentIfcSourceEnum {
    UPLOAD = 'UPLOAD',
    SPLIT = 'SPLIT',
    MERGE = 'MERGE',
    EXPORT = 'EXPORT',
    OPTIMIZED = 'OPTIMIZED'
}
/**
    * @export
    * @enum {string}
    */
export enum FullUpdateDocumentIfcSourceEnum {
    UPLOAD = 'UPLOAD',
    SPLIT = 'SPLIT',
    MERGE = 'MERGE',
    EXPORT = 'EXPORT',
    OPTIMIZED = 'OPTIMIZED'
}
