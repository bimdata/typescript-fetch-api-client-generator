/* tslint:disable */
/* eslint-disable */
/**
 * BIMData API
 * BIMData API is a tool to interact with your models stored on BIMDataâ€™s servers.     Through the API, you can manage your projects, the clouds, upload your IFC files and manage them through endpoints.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@bimdata.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    BcfProject,
    BcfProjectFromJSON,
    BcfProjectToJSON,
    Coloring,
    ColoringFromJSON,
    ColoringToJSON,
    Comment,
    CommentFromJSON,
    CommentToJSON,
    Component,
    ComponentFromJSON,
    ComponentToJSON,
    Extensions,
    ExtensionsFromJSON,
    ExtensionsToJSON,
    FullTopic,
    FullTopicFromJSON,
    FullTopicToJSON,
    SelfBcfUser,
    SelfBcfUserFromJSON,
    SelfBcfUserToJSON,
    Topic,
    TopicFromJSON,
    TopicToJSON,
    Viewpoint,
    ViewpointFromJSON,
    ViewpointToJSON,
    Visibility,
    VisibilityFromJSON,
    VisibilityToJSON,
} from '../models';

export interface CreateCommentRequest {
    projectsPk: string;
    topicsGuid: string;
    data: Comment;
}

export interface CreateFullTopicRequest {
    projectsPk: string;
    data: FullTopic;
    imgFormat?: CreateFullTopicImgFormatEnum;
}

export interface CreateTopicRequest {
    projectsPk: string;
    data: Topic;
}

export interface CreateViewpointRequest {
    projectsPk: string;
    topicsGuid: string;
    data: Viewpoint;
    imgFormat?: CreateViewpointImgFormatEnum;
}

export interface DeleteCommentRequest {
    guid: string;
    projectsPk: string;
    topicsGuid: string;
}

export interface DeleteTopicRequest {
    guid: string;
    projectsPk: string;
}

export interface DeleteViewpointRequest {
    guid: string;
    projectsPk: string;
    topicsGuid: string;
    imgFormat?: DeleteViewpointImgFormatEnum;
}

export interface DownloadBcfExportRequest {
    id: number;
    topics?: string;
    format?: string;
}

export interface FullUpdateBcfProjectRequest {
    id: number;
    data: BcfProject;
}

export interface FullUpdateCommentRequest {
    guid: string;
    projectsPk: string;
    topicsGuid: string;
    data: Comment;
}

export interface FullUpdateFullTopicRequest {
    guid: string;
    projectsPk: string;
    data: FullTopic;
    imgFormat?: FullUpdateFullTopicImgFormatEnum;
}

export interface FullUpdateTopicRequest {
    guid: string;
    projectsPk: string;
    data: Topic;
}

export interface FullUpdateViewpointRequest {
    guid: string;
    projectsPk: string;
    topicsGuid: string;
    data: Viewpoint;
    imgFormat?: FullUpdateViewpointImgFormatEnum;
}

export interface GetBcfProjectRequest {
    id: number;
}

export interface GetColoringsRequest {
    guid: string;
    projectsPk: string;
    topicsGuid: string;
}

export interface GetCommentRequest {
    guid: string;
    projectsPk: string;
    topicsGuid: string;
}

export interface GetCommentsRequest {
    projectsPk: string;
    topicsGuid: string;
}

export interface GetExtensionsRequest {
    projectsPk: string;
}

export interface GetFullTopicRequest {
    guid: string;
    projectsPk: string;
    imgFormat?: GetFullTopicImgFormatEnum;
}

export interface GetFullTopicsRequest {
    projectsPk: string;
    models?: string;
    ifcs?: string;
    format?: string;
    imgFormat?: GetFullTopicsImgFormatEnum;
}

export interface GetSelectionsRequest {
    guid: string;
    projectsPk: string;
    topicsGuid: string;
}

export interface GetSnapshotRequest {
    guid: string;
    projectsPk: string;
    topicsGuid: string;
}

export interface GetTopicRequest {
    guid: string;
    projectsPk: string;
}

export interface GetTopicViewpointsRequest {
    projectsPk: string;
    topicsGuid: string;
    imgFormat?: GetTopicViewpointsImgFormatEnum;
}

export interface GetTopicsRequest {
    projectsPk: string;
    models?: string;
    ifcs?: string;
    format?: string;
}

export interface GetViewpointRequest {
    guid: string;
    projectsPk: string;
    topicsGuid: string;
    imgFormat?: GetViewpointImgFormatEnum;
}

export interface GetViewpointsRequest {
    projectsPk: string;
    topicsGuid: string;
    imgFormat?: GetViewpointsImgFormatEnum;
}

export interface GetVisibilitiesRequest {
    guid: string;
    projectsPk: string;
    topicsGuid: string;
}

export interface ImportBcfRequest {
    id: number;
    name: string;
}

export interface UpdateBcfProjectRequest {
    id: number;
    data: BcfProject;
}

export interface UpdateCommentRequest {
    guid: string;
    projectsPk: string;
    topicsGuid: string;
    data: Comment;
}

export interface UpdateExtensionsRequest {
    projectsPk: string;
    data: Extensions;
}

export interface UpdateFullTopicRequest {
    guid: string;
    projectsPk: string;
    data: FullTopic;
    imgFormat?: UpdateFullTopicImgFormatEnum;
}

export interface UpdateTopicRequest {
    guid: string;
    projectsPk: string;
    data: Topic;
}

export interface UpdateViewpointRequest {
    guid: string;
    projectsPk: string;
    topicsGuid: string;
    data: Viewpoint;
    imgFormat?: UpdateViewpointImgFormatEnum;
}

/**
 * 
 */
export class BcfApi extends runtime.BaseAPI {

    /**
     * Create a comment Required scopes: bcf:write
     * Create a comment
     */
    async createCommentRaw(requestParameters: CreateCommentRequest): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createComment.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling createComment.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createComment.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CommentToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Create a comment Required scopes: bcf:write
     * Create a comment
     */
    async createComment(requestParameters: CreateCommentRequest): Promise<Comment> {
        const response = await this.createCommentRaw(requestParameters);
        return await response.value();
    }

    /**
     * This is not a standard route. You can send a topic, viewpoints and comments in a single call Required scopes: bcf:write
     * Create a Topic with viewpoints and comments
     */
    async createFullTopicRaw(requestParameters: CreateFullTopicRequest): Promise<runtime.ApiResponse<FullTopic>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createFullTopic.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createFullTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FullTopicToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTopicFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. You can send a topic, viewpoints and comments in a single call Required scopes: bcf:write
     * Create a Topic with viewpoints and comments
     */
    async createFullTopic(requestParameters: CreateFullTopicRequest): Promise<FullTopic> {
        const response = await this.createFullTopicRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a topic Required scopes: bcf:write
     * Create a topic
     */
    async createTopicRaw(requestParameters: CreateTopicRequest): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createTopic.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TopicToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * Create a topic Required scopes: bcf:write
     * Create a topic
     */
    async createTopic(requestParameters: CreateTopicRequest): Promise<Topic> {
        const response = await this.createTopicRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a Viewpoint Required scopes: bcf:write
     * Create a Viewpoint
     */
    async createViewpointRaw(requestParameters: CreateViewpointRequest): Promise<runtime.ApiResponse<Viewpoint>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createViewpoint.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling createViewpoint.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createViewpoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ViewpointToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewpointFromJSON(jsonValue));
    }

    /**
     * Create a Viewpoint Required scopes: bcf:write
     * Create a Viewpoint
     */
    async createViewpoint(requestParameters: CreateViewpointRequest): Promise<Viewpoint> {
        const response = await this.createViewpointRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete a comment Required scopes: bcf:write
     * Delete a comment
     */
    async deleteCommentRaw(requestParameters: DeleteCommentRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling deleteComment.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling deleteComment.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling deleteComment.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a comment Required scopes: bcf:write
     * Delete a comment
     */
    async deleteComment(requestParameters: DeleteCommentRequest): Promise<void> {
        await this.deleteCommentRaw(requestParameters);
    }

    /**
     * Delete a topic Required scopes: bcf:write
     * Delete a topic
     */
    async deleteTopicRaw(requestParameters: DeleteTopicRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling deleteTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling deleteTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a topic Required scopes: bcf:write
     * Delete a topic
     */
    async deleteTopic(requestParameters: DeleteTopicRequest): Promise<void> {
        await this.deleteTopicRaw(requestParameters);
    }

    /**
     * This is not a standard route. Delete a Viewpoint Required scopes: bcf:write
     * Delete a Viewpoint
     */
    async deleteViewpointRaw(requestParameters: DeleteViewpointRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling deleteViewpoint.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling deleteViewpoint.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling deleteViewpoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a Viewpoint Required scopes: bcf:write
     * Delete a Viewpoint
     */
    async deleteViewpoint(requestParameters: DeleteViewpointRequest): Promise<void> {
        await this.deleteViewpointRaw(requestParameters);
    }

    /**
     * Export project\'s topics in bcf-xml format Required scopes: bcf:read
     * Export project\'s topics in bcf-xml format
     */
    async downloadBcfExportRaw(requestParameters: DownloadBcfExportRequest): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling downloadBcfExport.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.topics !== undefined) {
            queryParameters['topics'] = requestParameters.topics;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}/export`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Export project\'s topics in bcf-xml format Required scopes: bcf:read
     * Export project\'s topics in bcf-xml format
     */
    async downloadBcfExport(requestParameters: DownloadBcfExportRequest): Promise<Blob> {
        const response = await this.downloadBcfExportRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update all fields of a BCF project Required scopes: bcf:write
     * Update all fields of a BCF project
     */
    async fullUpdateBcfProjectRaw(requestParameters: FullUpdateBcfProjectRequest): Promise<runtime.ApiResponse<BcfProject>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling fullUpdateBcfProject.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateBcfProject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BcfProjectToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BcfProjectFromJSON(jsonValue));
    }

    /**
     * Update all fields of a BCF project Required scopes: bcf:write
     * Update all fields of a BCF project
     */
    async fullUpdateBcfProject(requestParameters: FullUpdateBcfProjectRequest): Promise<BcfProject> {
        const response = await this.fullUpdateBcfProjectRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update all fields of a comment Required scopes: bcf:write
     * Update all fields of a comment
     */
    async fullUpdateCommentRaw(requestParameters: FullUpdateCommentRequest): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling fullUpdateComment.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling fullUpdateComment.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling fullUpdateComment.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateComment.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CommentToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Update all fields of a comment Required scopes: bcf:write
     * Update all fields of a comment
     */
    async fullUpdateComment(requestParameters: FullUpdateCommentRequest): Promise<Comment> {
        const response = await this.fullUpdateCommentRaw(requestParameters);
        return await response.value();
    }

    /**
     * This is not a standard route. You can update topic, viewpoints and comment is a signle call Required scopes: bcf:write
     * Update all fields of a topic
     */
    async fullUpdateFullTopicRaw(requestParameters: FullUpdateFullTopicRequest): Promise<runtime.ApiResponse<FullTopic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling fullUpdateFullTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling fullUpdateFullTopic.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateFullTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FullTopicToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTopicFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. You can update topic, viewpoints and comment is a signle call Required scopes: bcf:write
     * Update all fields of a topic
     */
    async fullUpdateFullTopic(requestParameters: FullUpdateFullTopicRequest): Promise<FullTopic> {
        const response = await this.fullUpdateFullTopicRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update all fields of a topic Required scopes: bcf:write
     * Update all fields of a topic
     */
    async fullUpdateTopicRaw(requestParameters: FullUpdateTopicRequest): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling fullUpdateTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling fullUpdateTopic.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TopicToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * Update all fields of a topic Required scopes: bcf:write
     * Update all fields of a topic
     */
    async fullUpdateTopic(requestParameters: FullUpdateTopicRequest): Promise<Topic> {
        const response = await this.fullUpdateTopicRaw(requestParameters);
        return await response.value();
    }

    /**
     * This is not a standard route. Update all fields of a Viewpoint Required scopes: bcf:write
     * Update all fields of a Viewpoint
     */
    async fullUpdateViewpointRaw(requestParameters: FullUpdateViewpointRequest): Promise<runtime.ApiResponse<Viewpoint>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling fullUpdateViewpoint.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling fullUpdateViewpoint.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling fullUpdateViewpoint.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateViewpoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ViewpointToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewpointFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update all fields of a Viewpoint Required scopes: bcf:write
     * Update all fields of a Viewpoint
     */
    async fullUpdateViewpoint(requestParameters: FullUpdateViewpointRequest): Promise<Viewpoint> {
        const response = await this.fullUpdateViewpointRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a BCF project Required scopes: bcf:read
     * Retrieve a BCF project
     */
    async getBcfProjectRaw(requestParameters: GetBcfProjectRequest): Promise<runtime.ApiResponse<BcfProject>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getBcfProject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BcfProjectFromJSON(jsonValue));
    }

    /**
     * Retrieve a BCF project Required scopes: bcf:read
     * Retrieve a BCF project
     */
    async getBcfProject(requestParameters: GetBcfProjectRequest): Promise<BcfProject> {
        const response = await this.getBcfProjectRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all BCF projects Required scopes: bcf:read
     * Retrieve all BCF projects
     */
    async getBcfProjectsRaw(): Promise<runtime.ApiResponse<Array<BcfProject>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BcfProjectFromJSON));
    }

    /**
     * Retrieve all BCF projects Required scopes: bcf:read
     * Retrieve all BCF projects
     */
    async getBcfProjects(): Promise<Array<BcfProject>> {
        const response = await this.getBcfProjectsRaw();
        return await response.value();
    }

    /**
     * Retrieve all colorings of a viewpoint Required scopes: bcf:read
     * Retrieve all colorings of a viewpoint
     */
    async getColoringsRaw(requestParameters: GetColoringsRequest): Promise<runtime.ApiResponse<Array<Coloring>>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getColorings.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getColorings.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getColorings.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/coloring`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ColoringFromJSON));
    }

    /**
     * Retrieve all colorings of a viewpoint Required scopes: bcf:read
     * Retrieve all colorings of a viewpoint
     */
    async getColorings(requestParameters: GetColoringsRequest): Promise<Array<Coloring>> {
        const response = await this.getColoringsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a comment Required scopes: bcf:read
     * Retrieve a comment
     */
    async getCommentRaw(requestParameters: GetCommentRequest): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getComment.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getComment.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getComment.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Retrieve a comment Required scopes: bcf:read
     * Retrieve a comment
     */
    async getComment(requestParameters: GetCommentRequest): Promise<Comment> {
        const response = await this.getCommentRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all comments Required scopes: bcf:read
     * Retrieve all comments
     */
    async getCommentsRaw(requestParameters: GetCommentsRequest): Promise<runtime.ApiResponse<Array<Comment>>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getComments.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getComments.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CommentFromJSON));
    }

    /**
     * Retrieve all comments Required scopes: bcf:read
     * Retrieve all comments
     */
    async getComments(requestParameters: GetCommentsRequest): Promise<Array<Comment>> {
        const response = await this.getCommentsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve project extensions
     * Retrieve project extensions
     */
    async getExtensionsRaw(requestParameters: GetExtensionsRequest): Promise<runtime.ApiResponse<Extensions>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getExtensions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extensions`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExtensionsFromJSON(jsonValue));
    }

    /**
     * Retrieve project extensions
     * Retrieve project extensions
     */
    async getExtensions(requestParameters: GetExtensionsRequest): Promise<Extensions> {
        const response = await this.getExtensionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * This is not a standard route. It responds with a topic, its viewpoints and its comments Required scopes: bcf:read
     * Retrieve a full topic
     */
    async getFullTopicRaw(requestParameters: GetFullTopicRequest): Promise<runtime.ApiResponse<FullTopic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getFullTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getFullTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTopicFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. It responds with a topic, its viewpoints and its comments Required scopes: bcf:read
     * Retrieve a full topic
     */
    async getFullTopic(requestParameters: GetFullTopicRequest): Promise<FullTopic> {
        const response = await this.getFullTopicRaw(requestParameters);
        return await response.value();
    }

    /**
     * This is not a standard route. It responds with all topics, their viewpoints and their comments Required scopes: bcf:read
     * Retrieve all full topics
     */
    async getFullTopicsRaw(requestParameters: GetFullTopicsRequest): Promise<runtime.ApiResponse<Array<FullTopic>>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getFullTopics.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.models !== undefined) {
            queryParameters['models'] = requestParameters.models;
        }

        if (requestParameters.ifcs !== undefined) {
            queryParameters['ifcs'] = requestParameters.ifcs;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FullTopicFromJSON));
    }

    /**
     * This is not a standard route. It responds with all topics, their viewpoints and their comments Required scopes: bcf:read
     * Retrieve all full topics
     */
    async getFullTopics(requestParameters: GetFullTopicsRequest): Promise<Array<FullTopic>> {
        const response = await this.getFullTopicsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all selections of a viewpoint Required scopes: bcf:read
     * Retrieve all selections of a viewpoint
     */
    async getSelectionsRaw(requestParameters: GetSelectionsRequest): Promise<runtime.ApiResponse<Array<Component>>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getSelections.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getSelections.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getSelections.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/selection`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ComponentFromJSON));
    }

    /**
     * Retrieve all selections of a viewpoint Required scopes: bcf:read
     * Retrieve all selections of a viewpoint
     */
    async getSelections(requestParameters: GetSelectionsRequest): Promise<Array<Component>> {
        const response = await this.getSelectionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve the viewpoint\' snapshot Required scopes: bcf:read
     * Retrieve the viewpoint\' snapshot
     */
    async getSnapshotRaw(requestParameters: GetSnapshotRequest): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getSnapshot.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getSnapshot.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getSnapshot.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/snapshot`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Retrieve the viewpoint\' snapshot Required scopes: bcf:read
     * Retrieve the viewpoint\' snapshot
     */
    async getSnapshot(requestParameters: GetSnapshotRequest): Promise<Blob> {
        const response = await this.getSnapshotRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a topic Required scopes: bcf:read
     * Retrieve a topic
     */
    async getTopicRaw(requestParameters: GetTopicRequest): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * Retrieve a topic Required scopes: bcf:read
     * Retrieve a topic
     */
    async getTopic(requestParameters: GetTopicRequest): Promise<Topic> {
        const response = await this.getTopicRaw(requestParameters);
        return await response.value();
    }

    /**
     * This is not a standard route. It returns all viewpoints of the topic that are not attached to a comment. Required scopes: bcf:read
     * Retrieve all viewpoints attached to the topic
     */
    async getTopicViewpointsRaw(requestParameters: GetTopicViewpointsRequest): Promise<runtime.ApiResponse<Array<Viewpoint>>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getTopicViewpoints.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getTopicViewpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/topic-viewpoints`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ViewpointFromJSON));
    }

    /**
     * This is not a standard route. It returns all viewpoints of the topic that are not attached to a comment. Required scopes: bcf:read
     * Retrieve all viewpoints attached to the topic
     */
    async getTopicViewpoints(requestParameters: GetTopicViewpointsRequest): Promise<Array<Viewpoint>> {
        const response = await this.getTopicViewpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all topics Required scopes: bcf:read
     * Retrieve all topics
     */
    async getTopicsRaw(requestParameters: GetTopicsRequest): Promise<runtime.ApiResponse<Array<Topic>>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getTopics.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.models !== undefined) {
            queryParameters['models'] = requestParameters.models;
        }

        if (requestParameters.ifcs !== undefined) {
            queryParameters['ifcs'] = requestParameters.ifcs;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TopicFromJSON));
    }

    /**
     * Retrieve all topics Required scopes: bcf:read
     * Retrieve all topics
     */
    async getTopics(requestParameters: GetTopicsRequest): Promise<Array<Topic>> {
        const response = await this.getTopicsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get current user info. If request comes from an App, the response is always:         {             \"id\": None,             \"name\": None,             \"is_client\": True,         } Required scopes: bcf:read
     * Get current user info
     */
    async getUserRaw(): Promise<runtime.ApiResponse<SelfBcfUser>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/current-user`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SelfBcfUserFromJSON(jsonValue));
    }

    /**
     * Get current user info. If request comes from an App, the response is always:         {             \"id\": None,             \"name\": None,             \"is_client\": True,         } Required scopes: bcf:read
     * Get current user info
     */
    async getUser(): Promise<SelfBcfUser> {
        const response = await this.getUserRaw();
        return await response.value();
    }

    /**
     * Retrieve a Viewpoint Required scopes: bcf:read
     * Retrieve a Viewpoint
     */
    async getViewpointRaw(requestParameters: GetViewpointRequest): Promise<runtime.ApiResponse<Viewpoint>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getViewpoint.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getViewpoint.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getViewpoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewpointFromJSON(jsonValue));
    }

    /**
     * Retrieve a Viewpoint Required scopes: bcf:read
     * Retrieve a Viewpoint
     */
    async getViewpoint(requestParameters: GetViewpointRequest): Promise<Viewpoint> {
        const response = await this.getViewpointRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all Viewpoints of a topic Required scopes: bcf:read
     * Retrieve all Viewpoints of a topic
     */
    async getViewpointsRaw(requestParameters: GetViewpointsRequest): Promise<runtime.ApiResponse<Array<Viewpoint>>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getViewpoints.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getViewpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ViewpointFromJSON));
    }

    /**
     * Retrieve all Viewpoints of a topic Required scopes: bcf:read
     * Retrieve all Viewpoints of a topic
     */
    async getViewpoints(requestParameters: GetViewpointsRequest): Promise<Array<Viewpoint>> {
        const response = await this.getViewpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all visibilities of a viewpoint Required scopes: bcf:read
     * Retrieve all visibilities of a viewpoint
     */
    async getVisibilitiesRaw(requestParameters: GetVisibilitiesRequest): Promise<runtime.ApiResponse<Visibility>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getVisibilities.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getVisibilities.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getVisibilities.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/visibility`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => VisibilityFromJSON(jsonValue));
    }

    /**
     * Retrieve all visibilities of a viewpoint Required scopes: bcf:read
     * Retrieve all visibilities of a viewpoint
     */
    async getVisibilities(requestParameters: GetVisibilitiesRequest): Promise<Visibility> {
        const response = await this.getVisibilitiesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Import bcf-xml format into this project. If there are guid conflict, an error will be raised. If there are index conflicts, indexes of the imported file will be overriden with a new index. Author and assigned_to fields will be linked to existing users in the project. If no matching user are found, fields will be emptied. Only BCF 2.1 is supported Required scopes: bcf:write
     * Import bcf-xml format into this project
     */
    async importBcfRaw(requestParameters: ImportBcfRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling importBcf.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling importBcf.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}/import`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Import bcf-xml format into this project. If there are guid conflict, an error will be raised. If there are index conflicts, indexes of the imported file will be overriden with a new index. Author and assigned_to fields will be linked to existing users in the project. If no matching user are found, fields will be emptied. Only BCF 2.1 is supported Required scopes: bcf:write
     * Import bcf-xml format into this project
     */
    async importBcf(requestParameters: ImportBcfRequest): Promise<void> {
        await this.importBcfRaw(requestParameters);
    }

    /**
     * Update some fields of a BCF project Required scopes: bcf:write
     * Update some fields of a BCF project
     */
    async updateBcfProjectRaw(requestParameters: UpdateBcfProjectRequest): Promise<runtime.ApiResponse<BcfProject>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateBcfProject.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateBcfProject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: BcfProjectToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BcfProjectFromJSON(jsonValue));
    }

    /**
     * Update some fields of a BCF project Required scopes: bcf:write
     * Update some fields of a BCF project
     */
    async updateBcfProject(requestParameters: UpdateBcfProjectRequest): Promise<BcfProject> {
        const response = await this.updateBcfProjectRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a comment Required scopes: bcf:write
     * Update some fields of a comment
     */
    async updateCommentRaw(requestParameters: UpdateCommentRequest): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updateComment.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateComment.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling updateComment.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateComment.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: CommentToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Update some fields of a comment Required scopes: bcf:write
     * Update some fields of a comment
     */
    async updateComment(requestParameters: UpdateCommentRequest): Promise<Comment> {
        const response = await this.updateCommentRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update project extensions
     * Update project extensions
     */
    async updateExtensionsRaw(requestParameters: UpdateExtensionsRequest): Promise<runtime.ApiResponse<Extensions>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateExtensions.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateExtensions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extensions`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ExtensionsToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExtensionsFromJSON(jsonValue));
    }

    /**
     * Update project extensions
     * Update project extensions
     */
    async updateExtensions(requestParameters: UpdateExtensionsRequest): Promise<Extensions> {
        const response = await this.updateExtensionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * This is not a standard route. You can update topic, viewpoints and comment is a signle call Required scopes: bcf:write
     * Update some fields of a topic
     */
    async updateFullTopicRaw(requestParameters: UpdateFullTopicRequest): Promise<runtime.ApiResponse<FullTopic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updateFullTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateFullTopic.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateFullTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: FullTopicToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTopicFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. You can update topic, viewpoints and comment is a signle call Required scopes: bcf:write
     * Update some fields of a topic
     */
    async updateFullTopic(requestParameters: UpdateFullTopicRequest): Promise<FullTopic> {
        const response = await this.updateFullTopicRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a topic Required scopes: bcf:write
     * Update some fields of a topic
     */
    async updateTopicRaw(requestParameters: UpdateTopicRequest): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updateTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateTopic.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TopicToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * Update some fields of a topic Required scopes: bcf:write
     * Update some fields of a topic
     */
    async updateTopic(requestParameters: UpdateTopicRequest): Promise<Topic> {
        const response = await this.updateTopicRaw(requestParameters);
        return await response.value();
    }

    /**
     * This is not a standard route. Update some fields of a Viewpoint Required scopes: bcf:write
     * Update some fields of a Viewpoint
     */
    async updateViewpointRaw(requestParameters: UpdateViewpointRequest): Promise<runtime.ApiResponse<Viewpoint>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updateViewpoint.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateViewpoint.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling updateViewpoint.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateViewpoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ViewpointToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewpointFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update some fields of a Viewpoint Required scopes: bcf:write
     * Update some fields of a Viewpoint
     */
    async updateViewpoint(requestParameters: UpdateViewpointRequest): Promise<Viewpoint> {
        const response = await this.updateViewpointRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum CreateFullTopicImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateViewpointImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum DeleteViewpointImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum FullUpdateFullTopicImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum FullUpdateViewpointImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetFullTopicImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetFullTopicsImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTopicViewpointsImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetViewpointImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetViewpointsImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateFullTopicImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateViewpointImgFormatEnum {
    Url = 'url'
}
