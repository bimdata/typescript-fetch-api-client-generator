/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1 (v1)
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    BcfProject,
    BcfProjectFromJSON,
    BcfProjectToJSON,
    BcfProjectRequest,
    BcfProjectRequestFromJSON,
    BcfProjectRequestToJSON,
    Coloring,
    ColoringFromJSON,
    ColoringToJSON,
    Comment,
    CommentFromJSON,
    CommentToJSON,
    CommentRequest,
    CommentRequestFromJSON,
    CommentRequestToJSON,
    Component,
    ComponentFromJSON,
    ComponentToJSON,
    DetailedExtensions,
    DetailedExtensionsFromJSON,
    DetailedExtensionsToJSON,
    Extensions,
    ExtensionsFromJSON,
    ExtensionsToJSON,
    FullTopic,
    FullTopicFromJSON,
    FullTopicToJSON,
    FullTopicRequest,
    FullTopicRequestFromJSON,
    FullTopicRequestToJSON,
    Label,
    LabelFromJSON,
    LabelToJSON,
    LabelRequest,
    LabelRequestFromJSON,
    LabelRequestToJSON,
    PatchedBcfProjectRequest,
    PatchedBcfProjectRequestFromJSON,
    PatchedBcfProjectRequestToJSON,
    PatchedCommentRequest,
    PatchedCommentRequestFromJSON,
    PatchedCommentRequestToJSON,
    PatchedFullTopicRequest,
    PatchedFullTopicRequestFromJSON,
    PatchedFullTopicRequestToJSON,
    PatchedLabelRequest,
    PatchedLabelRequestFromJSON,
    PatchedLabelRequestToJSON,
    PatchedPriorityRequest,
    PatchedPriorityRequestFromJSON,
    PatchedPriorityRequestToJSON,
    PatchedStageRequest,
    PatchedStageRequestFromJSON,
    PatchedStageRequestToJSON,
    PatchedTopicRequest,
    PatchedTopicRequestFromJSON,
    PatchedTopicRequestToJSON,
    PatchedTopicStatusRequest,
    PatchedTopicStatusRequestFromJSON,
    PatchedTopicStatusRequestToJSON,
    PatchedTopicTypeRequest,
    PatchedTopicTypeRequestFromJSON,
    PatchedTopicTypeRequestToJSON,
    PatchedViewpointRequest,
    PatchedViewpointRequestFromJSON,
    PatchedViewpointRequestToJSON,
    Priority,
    PriorityFromJSON,
    PriorityToJSON,
    PriorityRequest,
    PriorityRequestFromJSON,
    PriorityRequestToJSON,
    SelfBcfUser,
    SelfBcfUserFromJSON,
    SelfBcfUserToJSON,
    Stage,
    StageFromJSON,
    StageToJSON,
    StageRequest,
    StageRequestFromJSON,
    StageRequestToJSON,
    Topic,
    TopicFromJSON,
    TopicToJSON,
    TopicRequest,
    TopicRequestFromJSON,
    TopicRequestToJSON,
    TopicStatus,
    TopicStatusFromJSON,
    TopicStatusToJSON,
    TopicStatusRequest,
    TopicStatusRequestFromJSON,
    TopicStatusRequestToJSON,
    TopicType,
    TopicTypeFromJSON,
    TopicTypeToJSON,
    TopicTypeRequest,
    TopicTypeRequestFromJSON,
    TopicTypeRequestToJSON,
    Viewpoint,
    ViewpointFromJSON,
    ViewpointToJSON,
    ViewpointRequest,
    ViewpointRequestFromJSON,
    ViewpointRequestToJSON,
    Visibility,
    VisibilityFromJSON,
    VisibilityToJSON,
} from '../models';

export interface CreateCommentRequest {
    projectsPk: number;
    topicsGuid: string;
    commentRequest?: CommentRequest;
}

export interface CreateExtensionLabelRequest {
    projectsPk: number;
    labelRequest: LabelRequest;
}

export interface CreateExtensionPriorityRequest {
    projectsPk: number;
    priorityRequest: PriorityRequest;
}

export interface CreateExtensionStageRequest {
    projectsPk: number;
    stageRequest: StageRequest;
}

export interface CreateExtensionStatusRequest {
    projectsPk: number;
    topicStatusRequest: TopicStatusRequest;
}

export interface CreateExtensionTypeRequest {
    projectsPk: number;
    topicTypeRequest: TopicTypeRequest;
}

export interface CreateFullTopicRequest {
    projectsPk: number;
    fullTopicRequest: FullTopicRequest;
    imgFormat?: CreateFullTopicImgFormatEnum;
}

export interface CreateTopicRequest {
    projectsPk: number;
    topicRequest: TopicRequest;
}

export interface CreateViewpointRequest {
    projectsPk: number;
    topicsGuid: string;
    imgFormat?: CreateViewpointImgFormatEnum;
    viewpointRequest?: ViewpointRequest;
}

export interface DeleteCommentRequest {
    guid: string;
    projectsPk: number;
    topicsGuid: string;
}

export interface DeleteExtensionLabelRequest {
    id: number;
    projectsPk: number;
}

export interface DeleteExtensionPriorityRequest {
    id: number;
    projectsPk: number;
}

export interface DeleteExtensionStageRequest {
    id: number;
    projectsPk: number;
}

export interface DeleteExtensionStatusRequest {
    id: number;
    projectsPk: number;
}

export interface DeleteExtensionTypeRequest {
    id: number;
    projectsPk: number;
}

export interface DeleteTopicRequest {
    guid: string;
    projectsPk: number;
}

export interface DeleteViewpointRequest {
    guid: string;
    projectsPk: number;
    topicsGuid: string;
    imgFormat?: DeleteViewpointImgFormatEnum;
}

export interface DownloadBcfExportRequest {
    id: number;
    format?: string;
    topics?: string;
}

export interface FullUpdateBcfProjectRequest {
    id: number;
    bcfProjectRequest: BcfProjectRequest;
}

export interface FullUpdateCommentRequest {
    guid: string;
    projectsPk: number;
    topicsGuid: string;
    commentRequest?: CommentRequest;
}

export interface FullUpdateFullTopicRequest {
    guid: string;
    projectsPk: number;
    fullTopicRequest: FullTopicRequest;
    imgFormat?: FullUpdateFullTopicImgFormatEnum;
}

export interface FullUpdateTopicRequest {
    guid: string;
    projectsPk: number;
    topicRequest: TopicRequest;
}

export interface FullUpdateViewpointRequest {
    guid: string;
    projectsPk: number;
    topicsGuid: string;
    imgFormat?: FullUpdateViewpointImgFormatEnum;
    viewpointRequest?: ViewpointRequest;
}

export interface GetBcfProjectRequest {
    id: number;
}

export interface GetColoringsRequest {
    guid: string;
    projectsPk: number;
    topicsGuid: string;
}

export interface GetCommentRequest {
    guid: string;
    projectsPk: number;
    topicsGuid: string;
}

export interface GetCommentsRequest {
    projectsPk: number;
    topicsGuid: string;
}

export interface GetDetailedExtensionsRequest {
    id: number;
}

export interface GetExtensionsRequest {
    id: number;
}

export interface GetFullTopicRequest {
    guid: string;
    projectsPk: number;
    imgFormat?: GetFullTopicImgFormatEnum;
}

export interface GetFullTopicsRequest {
    projectsPk: number;
    format?: string;
    ifcs?: Array<number>;
    imgFormat?: GetFullTopicsImgFormatEnum;
    models?: Array<number>;
}

export interface GetSelectionsRequest {
    guid: string;
    projectsPk: number;
    topicsGuid: string;
}

export interface GetSnapshotRequest {
    guid: string;
    projectsPk: number;
    topicsGuid: string;
}

export interface GetTopicRequest {
    guid: string;
    projectsPk: number;
}

export interface GetTopicViewpointsRequest {
    projectsPk: number;
    topicsGuid: string;
    imgFormat?: GetTopicViewpointsImgFormatEnum;
}

export interface GetTopicsRequest {
    projectsPk: number;
    format?: string;
    ifcs?: Array<number>;
    models?: Array<number>;
}

export interface GetViewpointRequest {
    guid: string;
    projectsPk: number;
    topicsGuid: string;
    imgFormat?: GetViewpointImgFormatEnum;
}

export interface GetViewpointsRequest {
    projectsPk: number;
    topicsGuid: string;
    imgFormat?: GetViewpointsImgFormatEnum;
}

export interface GetVisibilitiesRequest {
    guid: string;
    projectsPk: number;
    topicsGuid: string;
}

export interface ImportBcfRequest {
    id: number;
    name: string;
}

export interface UpdateBcfProjectRequest {
    id: number;
    patchedBcfProjectRequest?: PatchedBcfProjectRequest;
}

export interface UpdateCommentRequest {
    guid: string;
    projectsPk: number;
    topicsGuid: string;
    patchedCommentRequest?: PatchedCommentRequest;
}

export interface UpdateExtensionLabelRequest {
    id: number;
    projectsPk: number;
    patchedLabelRequest?: PatchedLabelRequest;
}

export interface UpdateExtensionPriorityRequest {
    id: number;
    projectsPk: number;
    patchedPriorityRequest?: PatchedPriorityRequest;
}

export interface UpdateExtensionStageRequest {
    id: number;
    projectsPk: number;
    patchedStageRequest?: PatchedStageRequest;
}

export interface UpdateExtensionStatusRequest {
    id: number;
    projectsPk: number;
    patchedTopicStatusRequest?: PatchedTopicStatusRequest;
}

export interface UpdateExtensionTypeRequest {
    id: number;
    projectsPk: number;
    patchedTopicTypeRequest?: PatchedTopicTypeRequest;
}

export interface UpdateFullTopicRequest {
    guid: string;
    projectsPk: number;
    imgFormat?: UpdateFullTopicImgFormatEnum;
    patchedFullTopicRequest?: PatchedFullTopicRequest;
}

export interface UpdateTopicRequest {
    guid: string;
    projectsPk: number;
    patchedTopicRequest?: PatchedTopicRequest;
}

export interface UpdateViewpointRequest {
    guid: string;
    projectsPk: number;
    topicsGuid: string;
    imgFormat?: UpdateViewpointImgFormatEnum;
    patchedViewpointRequest?: PatchedViewpointRequest;
}

/**
 * 
 */
export class BcfApi extends runtime.BaseAPI {

    /**
     * Create a comment  Required scopes: bcf:write
     * Create a comment
     */
    async createCommentRaw(requestParameters: CreateCommentRequest): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createComment.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling createComment.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CommentRequestToJSON(requestParameters.commentRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Create a comment  Required scopes: bcf:write
     * Create a comment
     */
    async createComment(projectsPk: number, topicsGuid: string, commentRequest?: CommentRequest): Promise<Comment> {
        const response = await this.createCommentRaw({ projectsPk: projectsPk, topicsGuid: topicsGuid, commentRequest: commentRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. Create a Label available for the project  Required scopes: bcf:write
     * Create a Label
     */
    async createExtensionLabelRaw(requestParameters: CreateExtensionLabelRequest): Promise<runtime.ApiResponse<Label>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createExtensionLabel.');
        }

        if (requestParameters.labelRequest === null || requestParameters.labelRequest === undefined) {
            throw new runtime.RequiredError('labelRequest','Required parameter requestParameters.labelRequest was null or undefined when calling createExtensionLabel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/label`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LabelRequestToJSON(requestParameters.labelRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LabelFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Create a Label available for the project  Required scopes: bcf:write
     * Create a Label
     */
    async createExtensionLabel(projectsPk: number, labelRequest: LabelRequest): Promise<Label> {
        const response = await this.createExtensionLabelRaw({ projectsPk: projectsPk, labelRequest: labelRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. Create a Priority available for the project  Required scopes: bcf:write
     * Create a Priority
     */
    async createExtensionPriorityRaw(requestParameters: CreateExtensionPriorityRequest): Promise<runtime.ApiResponse<Priority>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createExtensionPriority.');
        }

        if (requestParameters.priorityRequest === null || requestParameters.priorityRequest === undefined) {
            throw new runtime.RequiredError('priorityRequest','Required parameter requestParameters.priorityRequest was null or undefined when calling createExtensionPriority.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/priority`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PriorityRequestToJSON(requestParameters.priorityRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PriorityFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Create a Priority available for the project  Required scopes: bcf:write
     * Create a Priority
     */
    async createExtensionPriority(projectsPk: number, priorityRequest: PriorityRequest): Promise<Priority> {
        const response = await this.createExtensionPriorityRaw({ projectsPk: projectsPk, priorityRequest: priorityRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. Create a Stage available for the project  Required scopes: bcf:write
     * Create a Stage
     */
    async createExtensionStageRaw(requestParameters: CreateExtensionStageRequest): Promise<runtime.ApiResponse<Stage>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createExtensionStage.');
        }

        if (requestParameters.stageRequest === null || requestParameters.stageRequest === undefined) {
            throw new runtime.RequiredError('stageRequest','Required parameter requestParameters.stageRequest was null or undefined when calling createExtensionStage.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/stage`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StageRequestToJSON(requestParameters.stageRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StageFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Create a Stage available for the project  Required scopes: bcf:write
     * Create a Stage
     */
    async createExtensionStage(projectsPk: number, stageRequest: StageRequest): Promise<Stage> {
        const response = await this.createExtensionStageRaw({ projectsPk: projectsPk, stageRequest: stageRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. Create a TopicStatus available for the project  Required scopes: bcf:write
     * Create a TopicStatus
     */
    async createExtensionStatusRaw(requestParameters: CreateExtensionStatusRequest): Promise<runtime.ApiResponse<TopicStatus>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createExtensionStatus.');
        }

        if (requestParameters.topicStatusRequest === null || requestParameters.topicStatusRequest === undefined) {
            throw new runtime.RequiredError('topicStatusRequest','Required parameter requestParameters.topicStatusRequest was null or undefined when calling createExtensionStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/status`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TopicStatusRequestToJSON(requestParameters.topicStatusRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicStatusFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Create a TopicStatus available for the project  Required scopes: bcf:write
     * Create a TopicStatus
     */
    async createExtensionStatus(projectsPk: number, topicStatusRequest: TopicStatusRequest): Promise<TopicStatus> {
        const response = await this.createExtensionStatusRaw({ projectsPk: projectsPk, topicStatusRequest: topicStatusRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. Create a TopicType available for the project  Required scopes: bcf:write
     * Create a TopicType
     */
    async createExtensionTypeRaw(requestParameters: CreateExtensionTypeRequest): Promise<runtime.ApiResponse<TopicType>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createExtensionType.');
        }

        if (requestParameters.topicTypeRequest === null || requestParameters.topicTypeRequest === undefined) {
            throw new runtime.RequiredError('topicTypeRequest','Required parameter requestParameters.topicTypeRequest was null or undefined when calling createExtensionType.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/type`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TopicTypeRequestToJSON(requestParameters.topicTypeRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicTypeFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Create a TopicType available for the project  Required scopes: bcf:write
     * Create a TopicType
     */
    async createExtensionType(projectsPk: number, topicTypeRequest: TopicTypeRequest): Promise<TopicType> {
        const response = await this.createExtensionTypeRaw({ projectsPk: projectsPk, topicTypeRequest: topicTypeRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. You can send a topic, viewpoints and comments in a single call  Required scopes: bcf:write
     * Create a Topic with viewpoints and comments
     */
    async createFullTopicRaw(requestParameters: CreateFullTopicRequest): Promise<runtime.ApiResponse<FullTopic>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createFullTopic.');
        }

        if (requestParameters.fullTopicRequest === null || requestParameters.fullTopicRequest === undefined) {
            throw new runtime.RequiredError('fullTopicRequest','Required parameter requestParameters.fullTopicRequest was null or undefined when calling createFullTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FullTopicRequestToJSON(requestParameters.fullTopicRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTopicFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. You can send a topic, viewpoints and comments in a single call  Required scopes: bcf:write
     * Create a Topic with viewpoints and comments
     */
    async createFullTopic(projectsPk: number, fullTopicRequest: FullTopicRequest, imgFormat?: CreateFullTopicImgFormatEnum): Promise<FullTopic> {
        const response = await this.createFullTopicRaw({ projectsPk: projectsPk, fullTopicRequest: fullTopicRequest, imgFormat: imgFormat });
        return await response.value();
    }

    /**
     * Create a topic  Required scopes: bcf:write
     * Create a topic
     */
    async createTopicRaw(requestParameters: CreateTopicRequest): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createTopic.');
        }

        if (requestParameters.topicRequest === null || requestParameters.topicRequest === undefined) {
            throw new runtime.RequiredError('topicRequest','Required parameter requestParameters.topicRequest was null or undefined when calling createTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TopicRequestToJSON(requestParameters.topicRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * Create a topic  Required scopes: bcf:write
     * Create a topic
     */
    async createTopic(projectsPk: number, topicRequest: TopicRequest): Promise<Topic> {
        const response = await this.createTopicRaw({ projectsPk: projectsPk, topicRequest: topicRequest });
        return await response.value();
    }

    /**
     * Create a Viewpoint  Required scopes: bcf:write
     * Create a Viewpoint
     */
    async createViewpointRaw(requestParameters: CreateViewpointRequest): Promise<runtime.ApiResponse<Viewpoint>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling createViewpoint.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling createViewpoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ViewpointRequestToJSON(requestParameters.viewpointRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewpointFromJSON(jsonValue));
    }

    /**
     * Create a Viewpoint  Required scopes: bcf:write
     * Create a Viewpoint
     */
    async createViewpoint(projectsPk: number, topicsGuid: string, imgFormat?: CreateViewpointImgFormatEnum, viewpointRequest?: ViewpointRequest): Promise<Viewpoint> {
        const response = await this.createViewpointRaw({ projectsPk: projectsPk, topicsGuid: topicsGuid, imgFormat: imgFormat, viewpointRequest: viewpointRequest });
        return await response.value();
    }

    /**
     * Delete a comment  Required scopes: bcf:write
     * Delete a comment
     */
    async deleteCommentRaw(requestParameters: DeleteCommentRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling deleteComment.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling deleteComment.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling deleteComment.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a comment  Required scopes: bcf:write
     * Delete a comment
     */
    async deleteComment(guid: string, projectsPk: number, topicsGuid: string): Promise<void> {
        await this.deleteCommentRaw({ guid: guid, projectsPk: projectsPk, topicsGuid: topicsGuid });
    }

    /**
     * This is not a standard route. Delete a Label. Topics using this label won\'t be deleted   Required scopes: bcf:write
     * Delete a Label
     */
    async deleteExtensionLabelRaw(requestParameters: DeleteExtensionLabelRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteExtensionLabel.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling deleteExtensionLabel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/label/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a Label. Topics using this label won\'t be deleted   Required scopes: bcf:write
     * Delete a Label
     */
    async deleteExtensionLabel(id: number, projectsPk: number): Promise<void> {
        await this.deleteExtensionLabelRaw({ id: id, projectsPk: projectsPk });
    }

    /**
     * This is not a standard route. Delete a Priority. Topics using this priority won\'t be deleted   Required scopes: bcf:write
     * Delete a Priority
     */
    async deleteExtensionPriorityRaw(requestParameters: DeleteExtensionPriorityRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteExtensionPriority.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling deleteExtensionPriority.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/priority/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a Priority. Topics using this priority won\'t be deleted   Required scopes: bcf:write
     * Delete a Priority
     */
    async deleteExtensionPriority(id: number, projectsPk: number): Promise<void> {
        await this.deleteExtensionPriorityRaw({ id: id, projectsPk: projectsPk });
    }

    /**
     * This is not a standard route. Delete a Stage. Topics using this stage won\'t be deleted   Required scopes: bcf:write
     * Delete a Stage
     */
    async deleteExtensionStageRaw(requestParameters: DeleteExtensionStageRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteExtensionStage.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling deleteExtensionStage.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/stage/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a Stage. Topics using this stage won\'t be deleted   Required scopes: bcf:write
     * Delete a Stage
     */
    async deleteExtensionStage(id: number, projectsPk: number): Promise<void> {
        await this.deleteExtensionStageRaw({ id: id, projectsPk: projectsPk });
    }

    /**
     * This is not a standard route. Delete a TopicStatus. Topics using this status won\'t be deleted   Required scopes: bcf:write
     * Delete a TopicStatus
     */
    async deleteExtensionStatusRaw(requestParameters: DeleteExtensionStatusRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteExtensionStatus.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling deleteExtensionStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/status/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a TopicStatus. Topics using this status won\'t be deleted   Required scopes: bcf:write
     * Delete a TopicStatus
     */
    async deleteExtensionStatus(id: number, projectsPk: number): Promise<void> {
        await this.deleteExtensionStatusRaw({ id: id, projectsPk: projectsPk });
    }

    /**
     * This is not a standard route. Delete a TopicType. Topics using this type won\'t be deleted  Required scopes: bcf:write
     * Delete a TopicType
     */
    async deleteExtensionTypeRaw(requestParameters: DeleteExtensionTypeRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteExtensionType.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling deleteExtensionType.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/type/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a TopicType. Topics using this type won\'t be deleted  Required scopes: bcf:write
     * Delete a TopicType
     */
    async deleteExtensionType(id: number, projectsPk: number): Promise<void> {
        await this.deleteExtensionTypeRaw({ id: id, projectsPk: projectsPk });
    }

    /**
     * Delete a topic  Required scopes: bcf:write
     * Delete a topic
     */
    async deleteTopicRaw(requestParameters: DeleteTopicRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling deleteTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling deleteTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a topic  Required scopes: bcf:write
     * Delete a topic
     */
    async deleteTopic(guid: string, projectsPk: number): Promise<void> {
        await this.deleteTopicRaw({ guid: guid, projectsPk: projectsPk });
    }

    /**
     * This is not a standard route. Delete a Viewpoint  Required scopes: bcf:write
     * Delete a Viewpoint
     */
    async deleteViewpointRaw(requestParameters: DeleteViewpointRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling deleteViewpoint.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling deleteViewpoint.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling deleteViewpoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a Viewpoint  Required scopes: bcf:write
     * Delete a Viewpoint
     */
    async deleteViewpoint(guid: string, projectsPk: number, topicsGuid: string, imgFormat?: DeleteViewpointImgFormatEnum): Promise<void> {
        await this.deleteViewpointRaw({ guid: guid, projectsPk: projectsPk, topicsGuid: topicsGuid, imgFormat: imgFormat });
    }

    /**
     * This is not a standard route. Export project\'s topics in bcf-xml format  Required scopes: bcf:read
     * Export project\'s topics in bcf-xml format
     */
    async downloadBcfExportRaw(requestParameters: DownloadBcfExportRequest): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling downloadBcfExport.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.topics !== undefined) {
            queryParameters['topics'] = requestParameters.topics;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}/export`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * This is not a standard route. Export project\'s topics in bcf-xml format  Required scopes: bcf:read
     * Export project\'s topics in bcf-xml format
     */
    async downloadBcfExport(id: number, format?: string, topics?: string): Promise<Blob> {
        const response = await this.downloadBcfExportRaw({ id: id, format: format, topics: topics });
        return await response.value();
    }

    /**
     * Update all fields of a BCF project  Required scopes: bcf:write
     * Update all fields of a BCF project
     */
    async fullUpdateBcfProjectRaw(requestParameters: FullUpdateBcfProjectRequest): Promise<runtime.ApiResponse<BcfProject>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling fullUpdateBcfProject.');
        }

        if (requestParameters.bcfProjectRequest === null || requestParameters.bcfProjectRequest === undefined) {
            throw new runtime.RequiredError('bcfProjectRequest','Required parameter requestParameters.bcfProjectRequest was null or undefined when calling fullUpdateBcfProject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BcfProjectRequestToJSON(requestParameters.bcfProjectRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BcfProjectFromJSON(jsonValue));
    }

    /**
     * Update all fields of a BCF project  Required scopes: bcf:write
     * Update all fields of a BCF project
     */
    async fullUpdateBcfProject(id: number, bcfProjectRequest: BcfProjectRequest): Promise<BcfProject> {
        const response = await this.fullUpdateBcfProjectRaw({ id: id, bcfProjectRequest: bcfProjectRequest });
        return await response.value();
    }

    /**
     * Update all fields of a comment  Required scopes: bcf:write
     * Update all fields of a comment
     */
    async fullUpdateCommentRaw(requestParameters: FullUpdateCommentRequest): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling fullUpdateComment.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling fullUpdateComment.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling fullUpdateComment.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CommentRequestToJSON(requestParameters.commentRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Update all fields of a comment  Required scopes: bcf:write
     * Update all fields of a comment
     */
    async fullUpdateComment(guid: string, projectsPk: number, topicsGuid: string, commentRequest?: CommentRequest): Promise<Comment> {
        const response = await this.fullUpdateCommentRaw({ guid: guid, projectsPk: projectsPk, topicsGuid: topicsGuid, commentRequest: commentRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. You can update topic, viewpoints and comment is a signle call  Required scopes: bcf:write
     * Update all fields of a topic
     */
    async fullUpdateFullTopicRaw(requestParameters: FullUpdateFullTopicRequest): Promise<runtime.ApiResponse<FullTopic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling fullUpdateFullTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling fullUpdateFullTopic.');
        }

        if (requestParameters.fullTopicRequest === null || requestParameters.fullTopicRequest === undefined) {
            throw new runtime.RequiredError('fullTopicRequest','Required parameter requestParameters.fullTopicRequest was null or undefined when calling fullUpdateFullTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FullTopicRequestToJSON(requestParameters.fullTopicRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTopicFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. You can update topic, viewpoints and comment is a signle call  Required scopes: bcf:write
     * Update all fields of a topic
     */
    async fullUpdateFullTopic(guid: string, projectsPk: number, fullTopicRequest: FullTopicRequest, imgFormat?: FullUpdateFullTopicImgFormatEnum): Promise<FullTopic> {
        const response = await this.fullUpdateFullTopicRaw({ guid: guid, projectsPk: projectsPk, fullTopicRequest: fullTopicRequest, imgFormat: imgFormat });
        return await response.value();
    }

    /**
     * Update all fields of a topic  Required scopes: bcf:write
     * Update all fields of a topic
     */
    async fullUpdateTopicRaw(requestParameters: FullUpdateTopicRequest): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling fullUpdateTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling fullUpdateTopic.');
        }

        if (requestParameters.topicRequest === null || requestParameters.topicRequest === undefined) {
            throw new runtime.RequiredError('topicRequest','Required parameter requestParameters.topicRequest was null or undefined when calling fullUpdateTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TopicRequestToJSON(requestParameters.topicRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * Update all fields of a topic  Required scopes: bcf:write
     * Update all fields of a topic
     */
    async fullUpdateTopic(guid: string, projectsPk: number, topicRequest: TopicRequest): Promise<Topic> {
        const response = await this.fullUpdateTopicRaw({ guid: guid, projectsPk: projectsPk, topicRequest: topicRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. Update all fields of a Viewpoint  Required scopes: bcf:write
     * Update all fields of a Viewpoint
     */
    async fullUpdateViewpointRaw(requestParameters: FullUpdateViewpointRequest): Promise<runtime.ApiResponse<Viewpoint>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling fullUpdateViewpoint.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling fullUpdateViewpoint.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling fullUpdateViewpoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ViewpointRequestToJSON(requestParameters.viewpointRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewpointFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update all fields of a Viewpoint  Required scopes: bcf:write
     * Update all fields of a Viewpoint
     */
    async fullUpdateViewpoint(guid: string, projectsPk: number, topicsGuid: string, imgFormat?: FullUpdateViewpointImgFormatEnum, viewpointRequest?: ViewpointRequest): Promise<Viewpoint> {
        const response = await this.fullUpdateViewpointRaw({ guid: guid, projectsPk: projectsPk, topicsGuid: topicsGuid, imgFormat: imgFormat, viewpointRequest: viewpointRequest });
        return await response.value();
    }

    /**
     * Retrieve a BCF project  Required scopes: bcf:read
     * Retrieve a BCF project
     */
    async getBcfProjectRaw(requestParameters: GetBcfProjectRequest): Promise<runtime.ApiResponse<BcfProject>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getBcfProject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BcfProjectFromJSON(jsonValue));
    }

    /**
     * Retrieve a BCF project  Required scopes: bcf:read
     * Retrieve a BCF project
     */
    async getBcfProject(id: number): Promise<BcfProject> {
        const response = await this.getBcfProjectRaw({ id: id });
        return await response.value();
    }

    /**
     * Retrieve all BCF projects  Required scopes: bcf:read
     * Retrieve all BCF projects
     */
    async getBcfProjectsRaw(): Promise<runtime.ApiResponse<Array<BcfProject>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BcfProjectFromJSON));
    }

    /**
     * Retrieve all BCF projects  Required scopes: bcf:read
     * Retrieve all BCF projects
     */
    async getBcfProjects(): Promise<Array<BcfProject>> {
        const response = await this.getBcfProjectsRaw();
        return await response.value();
    }

    /**
     * Retrieve all colorings of a viewpoint  Required scopes: bcf:read
     * Retrieve all colorings of a viewpoint
     */
    async getColoringsRaw(requestParameters: GetColoringsRequest): Promise<runtime.ApiResponse<Array<Coloring>>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getColorings.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getColorings.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getColorings.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/coloring`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ColoringFromJSON));
    }

    /**
     * Retrieve all colorings of a viewpoint  Required scopes: bcf:read
     * Retrieve all colorings of a viewpoint
     */
    async getColorings(guid: string, projectsPk: number, topicsGuid: string): Promise<Array<Coloring>> {
        const response = await this.getColoringsRaw({ guid: guid, projectsPk: projectsPk, topicsGuid: topicsGuid });
        return await response.value();
    }

    /**
     * Retrieve a comment  Required scopes: bcf:read
     * Retrieve a comment
     */
    async getCommentRaw(requestParameters: GetCommentRequest): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getComment.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getComment.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getComment.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Retrieve a comment  Required scopes: bcf:read
     * Retrieve a comment
     */
    async getComment(guid: string, projectsPk: number, topicsGuid: string): Promise<Comment> {
        const response = await this.getCommentRaw({ guid: guid, projectsPk: projectsPk, topicsGuid: topicsGuid });
        return await response.value();
    }

    /**
     * Retrieve all comments  Required scopes: bcf:read
     * Retrieve all comments
     */
    async getCommentsRaw(requestParameters: GetCommentsRequest): Promise<runtime.ApiResponse<Array<Comment>>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getComments.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getComments.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CommentFromJSON));
    }

    /**
     * Retrieve all comments  Required scopes: bcf:read
     * Retrieve all comments
     */
    async getComments(projectsPk: number, topicsGuid: string): Promise<Array<Comment>> {
        const response = await this.getCommentsRaw({ projectsPk: projectsPk, topicsGuid: topicsGuid });
        return await response.value();
    }

    /**
     * This is not a standard route. Retrieve project detailed extensions  Required scopes: bcf:read
     * Retrieve project detailed extensions
     */
    async getDetailedExtensionsRaw(requestParameters: GetDetailedExtensionsRequest): Promise<runtime.ApiResponse<DetailedExtensions>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getDetailedExtensions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}/detailed-extensions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => DetailedExtensionsFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Retrieve project detailed extensions  Required scopes: bcf:read
     * Retrieve project detailed extensions
     */
    async getDetailedExtensions(id: number): Promise<DetailedExtensions> {
        const response = await this.getDetailedExtensionsRaw({ id: id });
        return await response.value();
    }

    /**
     * Retrieve project extensions  Required scopes: bcf:read
     * Retrieve project extensions
     */
    async getExtensionsRaw(requestParameters: GetExtensionsRequest): Promise<runtime.ApiResponse<Extensions>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getExtensions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}/extensions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExtensionsFromJSON(jsonValue));
    }

    /**
     * Retrieve project extensions  Required scopes: bcf:read
     * Retrieve project extensions
     */
    async getExtensions(id: number): Promise<Extensions> {
        const response = await this.getExtensionsRaw({ id: id });
        return await response.value();
    }

    /**
     * This is not a standard route. It responds with a topic, its viewpoints and its comments  Required scopes: bcf:read
     * Retrieve a full topic
     */
    async getFullTopicRaw(requestParameters: GetFullTopicRequest): Promise<runtime.ApiResponse<FullTopic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getFullTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getFullTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTopicFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. It responds with a topic, its viewpoints and its comments  Required scopes: bcf:read
     * Retrieve a full topic
     */
    async getFullTopic(guid: string, projectsPk: number, imgFormat?: GetFullTopicImgFormatEnum): Promise<FullTopic> {
        const response = await this.getFullTopicRaw({ guid: guid, projectsPk: projectsPk, imgFormat: imgFormat });
        return await response.value();
    }

    /**
     * This is not a standard route. It responds with all topics, their viewpoints and their comments  Required scopes: bcf:read
     * Retrieve all full topics
     */
    async getFullTopicsRaw(requestParameters: GetFullTopicsRequest): Promise<runtime.ApiResponse<Array<FullTopic>>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getFullTopics.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.ifcs) {
            queryParameters['ifcs'] = requestParameters.ifcs;
        }

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        if (requestParameters.models) {
            queryParameters['models'] = requestParameters.models;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FullTopicFromJSON));
    }

    /**
     * This is not a standard route. It responds with all topics, their viewpoints and their comments  Required scopes: bcf:read
     * Retrieve all full topics
     */
    async getFullTopics(projectsPk: number, format?: string, ifcs?: Array<number>, imgFormat?: GetFullTopicsImgFormatEnum, models?: Array<number>): Promise<Array<FullTopic>> {
        const response = await this.getFullTopicsRaw({ projectsPk: projectsPk, format: format, ifcs: ifcs, imgFormat: imgFormat, models: models });
        return await response.value();
    }

    /**
     * Retrieve all selections of a viewpoint  Required scopes: bcf:read
     * Retrieve all selections of a viewpoint
     */
    async getSelectionsRaw(requestParameters: GetSelectionsRequest): Promise<runtime.ApiResponse<Array<Component>>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getSelections.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getSelections.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getSelections.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/selection`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ComponentFromJSON));
    }

    /**
     * Retrieve all selections of a viewpoint  Required scopes: bcf:read
     * Retrieve all selections of a viewpoint
     */
    async getSelections(guid: string, projectsPk: number, topicsGuid: string): Promise<Array<Component>> {
        const response = await this.getSelectionsRaw({ guid: guid, projectsPk: projectsPk, topicsGuid: topicsGuid });
        return await response.value();
    }

    /**
     * Retrieve the viewpoint\' snapshot  Required scopes: bcf:read
     * Retrieve the viewpoint\' snapshot
     */
    async getSnapshotRaw(requestParameters: GetSnapshotRequest): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getSnapshot.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getSnapshot.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getSnapshot.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/snapshot`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Retrieve the viewpoint\' snapshot  Required scopes: bcf:read
     * Retrieve the viewpoint\' snapshot
     */
    async getSnapshot(guid: string, projectsPk: number, topicsGuid: string): Promise<Blob> {
        const response = await this.getSnapshotRaw({ guid: guid, projectsPk: projectsPk, topicsGuid: topicsGuid });
        return await response.value();
    }

    /**
     * Retrieve a topic  Required scopes: bcf:read
     * Retrieve a topic
     */
    async getTopicRaw(requestParameters: GetTopicRequest): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * Retrieve a topic  Required scopes: bcf:read
     * Retrieve a topic
     */
    async getTopic(guid: string, projectsPk: number): Promise<Topic> {
        const response = await this.getTopicRaw({ guid: guid, projectsPk: projectsPk });
        return await response.value();
    }

    /**
     * This is not a standard route. It returns all viewpoints of the topic that are not attached to a comment.  Required scopes: bcf:read
     * Retrieve all viewpoints attached to the topic
     */
    async getTopicViewpointsRaw(requestParameters: GetTopicViewpointsRequest): Promise<runtime.ApiResponse<Array<Viewpoint>>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getTopicViewpoints.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getTopicViewpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/topic-viewpoints`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ViewpointFromJSON));
    }

    /**
     * This is not a standard route. It returns all viewpoints of the topic that are not attached to a comment.  Required scopes: bcf:read
     * Retrieve all viewpoints attached to the topic
     */
    async getTopicViewpoints(projectsPk: number, topicsGuid: string, imgFormat?: GetTopicViewpointsImgFormatEnum): Promise<Array<Viewpoint>> {
        const response = await this.getTopicViewpointsRaw({ projectsPk: projectsPk, topicsGuid: topicsGuid, imgFormat: imgFormat });
        return await response.value();
    }

    /**
     * Retrieve all topics  Required scopes: bcf:read
     * Retrieve all topics
     */
    async getTopicsRaw(requestParameters: GetTopicsRequest): Promise<runtime.ApiResponse<Array<Topic>>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getTopics.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.ifcs) {
            queryParameters['ifcs'] = requestParameters.ifcs;
        }

        if (requestParameters.models) {
            queryParameters['models'] = requestParameters.models;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TopicFromJSON));
    }

    /**
     * Retrieve all topics  Required scopes: bcf:read
     * Retrieve all topics
     */
    async getTopics(projectsPk: number, format?: string, ifcs?: Array<number>, models?: Array<number>): Promise<Array<Topic>> {
        const response = await this.getTopicsRaw({ projectsPk: projectsPk, format: format, ifcs: ifcs, models: models });
        return await response.value();
    }

    /**
     * Get current user info. If request comes from an App, the response is always:{    \"id\": None,    \"name\": None,    \"is_client\": True,}  Required scopes: bcf:read
     * Get current user info
     */
    async getUserRaw(): Promise<runtime.ApiResponse<SelfBcfUser>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/current-user`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SelfBcfUserFromJSON(jsonValue));
    }

    /**
     * Get current user info. If request comes from an App, the response is always:{    \"id\": None,    \"name\": None,    \"is_client\": True,}  Required scopes: bcf:read
     * Get current user info
     */
    async getUser(): Promise<SelfBcfUser> {
        const response = await this.getUserRaw();
        return await response.value();
    }

    /**
     * Retrieve a Viewpoint  Required scopes: bcf:read
     * Retrieve a Viewpoint
     */
    async getViewpointRaw(requestParameters: GetViewpointRequest): Promise<runtime.ApiResponse<Viewpoint>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getViewpoint.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getViewpoint.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getViewpoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewpointFromJSON(jsonValue));
    }

    /**
     * Retrieve a Viewpoint  Required scopes: bcf:read
     * Retrieve a Viewpoint
     */
    async getViewpoint(guid: string, projectsPk: number, topicsGuid: string, imgFormat?: GetViewpointImgFormatEnum): Promise<Viewpoint> {
        const response = await this.getViewpointRaw({ guid: guid, projectsPk: projectsPk, topicsGuid: topicsGuid, imgFormat: imgFormat });
        return await response.value();
    }

    /**
     * Retrieve all Viewpoints of a topic  Required scopes: bcf:read
     * Retrieve all Viewpoints of a topic
     */
    async getViewpointsRaw(requestParameters: GetViewpointsRequest): Promise<runtime.ApiResponse<Array<Viewpoint>>> {
        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getViewpoints.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getViewpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ViewpointFromJSON));
    }

    /**
     * Retrieve all Viewpoints of a topic  Required scopes: bcf:read
     * Retrieve all Viewpoints of a topic
     */
    async getViewpoints(projectsPk: number, topicsGuid: string, imgFormat?: GetViewpointsImgFormatEnum): Promise<Array<Viewpoint>> {
        const response = await this.getViewpointsRaw({ projectsPk: projectsPk, topicsGuid: topicsGuid, imgFormat: imgFormat });
        return await response.value();
    }

    /**
     * Retrieve all visibilities of a viewpoint  Required scopes: bcf:read
     * Retrieve all visibilities of a viewpoint
     */
    async getVisibilitiesRaw(requestParameters: GetVisibilitiesRequest): Promise<runtime.ApiResponse<Visibility>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getVisibilities.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling getVisibilities.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling getVisibilities.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/visibility`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => VisibilityFromJSON(jsonValue));
    }

    /**
     * Retrieve all visibilities of a viewpoint  Required scopes: bcf:read
     * Retrieve all visibilities of a viewpoint
     */
    async getVisibilities(guid: string, projectsPk: number, topicsGuid: string): Promise<Visibility> {
        const response = await this.getVisibilitiesRaw({ guid: guid, projectsPk: projectsPk, topicsGuid: topicsGuid });
        return await response.value();
    }

    /**
     * This is not a standard route. Import bcf-xml format into this project. If there are guid conflict, an error will be raised. If there are index conflicts, indexes of the imported file will be overriden with a new index. Author and assigned_to fields will be linked to existing users in the project. If no matching user are found, fields will be emptied. Only BCF 2.1 is supported  Required scopes: bcf:write
     * Import bcf-xml format into this project
     */
    async importBcfRaw(requestParameters: ImportBcfRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling importBcf.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling importBcf.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}/import`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Import bcf-xml format into this project. If there are guid conflict, an error will be raised. If there are index conflicts, indexes of the imported file will be overriden with a new index. Author and assigned_to fields will be linked to existing users in the project. If no matching user are found, fields will be emptied. Only BCF 2.1 is supported  Required scopes: bcf:write
     * Import bcf-xml format into this project
     */
    async importBcf(id: number, name: string): Promise<void> {
        await this.importBcfRaw({ id: id, name: name });
    }

    /**
     * Update some fields of a BCF project  Required scopes: bcf:write
     * Update some fields of a BCF project
     */
    async updateBcfProjectRaw(requestParameters: UpdateBcfProjectRequest): Promise<runtime.ApiResponse<BcfProject>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateBcfProject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedBcfProjectRequestToJSON(requestParameters.patchedBcfProjectRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BcfProjectFromJSON(jsonValue));
    }

    /**
     * Update some fields of a BCF project  Required scopes: bcf:write
     * Update some fields of a BCF project
     */
    async updateBcfProject(id: number, patchedBcfProjectRequest?: PatchedBcfProjectRequest): Promise<BcfProject> {
        const response = await this.updateBcfProjectRaw({ id: id, patchedBcfProjectRequest: patchedBcfProjectRequest });
        return await response.value();
    }

    /**
     * Update some fields of a comment  Required scopes: bcf:write
     * Update some fields of a comment
     */
    async updateCommentRaw(requestParameters: UpdateCommentRequest): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updateComment.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateComment.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling updateComment.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedCommentRequestToJSON(requestParameters.patchedCommentRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Update some fields of a comment  Required scopes: bcf:write
     * Update some fields of a comment
     */
    async updateComment(guid: string, projectsPk: number, topicsGuid: string, patchedCommentRequest?: PatchedCommentRequest): Promise<Comment> {
        const response = await this.updateCommentRaw({ guid: guid, projectsPk: projectsPk, topicsGuid: topicsGuid, patchedCommentRequest: patchedCommentRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. Update a Label. All topics using this label will be updated  Required scopes: bcf:write
     * Update a Label
     */
    async updateExtensionLabelRaw(requestParameters: UpdateExtensionLabelRequest): Promise<runtime.ApiResponse<Label>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateExtensionLabel.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateExtensionLabel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/label/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedLabelRequestToJSON(requestParameters.patchedLabelRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LabelFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update a Label. All topics using this label will be updated  Required scopes: bcf:write
     * Update a Label
     */
    async updateExtensionLabel(id: number, projectsPk: number, patchedLabelRequest?: PatchedLabelRequest): Promise<Label> {
        const response = await this.updateExtensionLabelRaw({ id: id, projectsPk: projectsPk, patchedLabelRequest: patchedLabelRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. Update a Priority. All topics using this priority will be updated  Required scopes: bcf:write
     * Update a Priority
     */
    async updateExtensionPriorityRaw(requestParameters: UpdateExtensionPriorityRequest): Promise<runtime.ApiResponse<Priority>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateExtensionPriority.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateExtensionPriority.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/priority/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPriorityRequestToJSON(requestParameters.patchedPriorityRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PriorityFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update a Priority. All topics using this priority will be updated  Required scopes: bcf:write
     * Update a Priority
     */
    async updateExtensionPriority(id: number, projectsPk: number, patchedPriorityRequest?: PatchedPriorityRequest): Promise<Priority> {
        const response = await this.updateExtensionPriorityRaw({ id: id, projectsPk: projectsPk, patchedPriorityRequest: patchedPriorityRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. Update a Stage. All topics using this stage will be updated  Required scopes: bcf:write
     * Update a Stage
     */
    async updateExtensionStageRaw(requestParameters: UpdateExtensionStageRequest): Promise<runtime.ApiResponse<Stage>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateExtensionStage.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateExtensionStage.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/stage/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedStageRequestToJSON(requestParameters.patchedStageRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StageFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update a Stage. All topics using this stage will be updated  Required scopes: bcf:write
     * Update a Stage
     */
    async updateExtensionStage(id: number, projectsPk: number, patchedStageRequest?: PatchedStageRequest): Promise<Stage> {
        const response = await this.updateExtensionStageRaw({ id: id, projectsPk: projectsPk, patchedStageRequest: patchedStageRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. Update a TopicStatus. All topics using this status will be updated  Required scopes: bcf:write
     * Update a TopicStatus
     */
    async updateExtensionStatusRaw(requestParameters: UpdateExtensionStatusRequest): Promise<runtime.ApiResponse<TopicStatus>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateExtensionStatus.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateExtensionStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/status/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedTopicStatusRequestToJSON(requestParameters.patchedTopicStatusRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicStatusFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update a TopicStatus. All topics using this status will be updated  Required scopes: bcf:write
     * Update a TopicStatus
     */
    async updateExtensionStatus(id: number, projectsPk: number, patchedTopicStatusRequest?: PatchedTopicStatusRequest): Promise<TopicStatus> {
        const response = await this.updateExtensionStatusRaw({ id: id, projectsPk: projectsPk, patchedTopicStatusRequest: patchedTopicStatusRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. Update a TopicType. All topics using this type will be updated  Required scopes: bcf:write
     * Update a TopicType
     */
    async updateExtensionTypeRaw(requestParameters: UpdateExtensionTypeRequest): Promise<runtime.ApiResponse<TopicType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateExtensionType.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateExtensionType.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/type/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedTopicTypeRequestToJSON(requestParameters.patchedTopicTypeRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicTypeFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update a TopicType. All topics using this type will be updated  Required scopes: bcf:write
     * Update a TopicType
     */
    async updateExtensionType(id: number, projectsPk: number, patchedTopicTypeRequest?: PatchedTopicTypeRequest): Promise<TopicType> {
        const response = await this.updateExtensionTypeRaw({ id: id, projectsPk: projectsPk, patchedTopicTypeRequest: patchedTopicTypeRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. You can update topic, viewpoints and comment is a signle call  Required scopes: bcf:write
     * Update some fields of a topic
     */
    async updateFullTopicRaw(requestParameters: UpdateFullTopicRequest): Promise<runtime.ApiResponse<FullTopic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updateFullTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateFullTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedFullTopicRequestToJSON(requestParameters.patchedFullTopicRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTopicFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. You can update topic, viewpoints and comment is a signle call  Required scopes: bcf:write
     * Update some fields of a topic
     */
    async updateFullTopic(guid: string, projectsPk: number, imgFormat?: UpdateFullTopicImgFormatEnum, patchedFullTopicRequest?: PatchedFullTopicRequest): Promise<FullTopic> {
        const response = await this.updateFullTopicRaw({ guid: guid, projectsPk: projectsPk, imgFormat: imgFormat, patchedFullTopicRequest: patchedFullTopicRequest });
        return await response.value();
    }

    /**
     * Update some fields of a topic  Required scopes: bcf:write
     * Update some fields of a topic
     */
    async updateTopicRaw(requestParameters: UpdateTopicRequest): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updateTopic.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateTopic.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedTopicRequestToJSON(requestParameters.patchedTopicRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * Update some fields of a topic  Required scopes: bcf:write
     * Update some fields of a topic
     */
    async updateTopic(guid: string, projectsPk: number, patchedTopicRequest?: PatchedTopicRequest): Promise<Topic> {
        const response = await this.updateTopicRaw({ guid: guid, projectsPk: projectsPk, patchedTopicRequest: patchedTopicRequest });
        return await response.value();
    }

    /**
     * This is not a standard route. Update some fields of a Viewpoint  Required scopes: bcf:write
     * Update some fields of a Viewpoint
     */
    async updateViewpointRaw(requestParameters: UpdateViewpointRequest): Promise<runtime.ApiResponse<Viewpoint>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updateViewpoint.');
        }

        if (requestParameters.projectsPk === null || requestParameters.projectsPk === undefined) {
            throw new runtime.RequiredError('projectsPk','Required parameter requestParameters.projectsPk was null or undefined when calling updateViewpoint.');
        }

        if (requestParameters.topicsGuid === null || requestParameters.topicsGuid === undefined) {
            throw new runtime.RequiredError('topicsGuid','Required parameter requestParameters.topicsGuid was null or undefined when calling updateViewpoint.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.imgFormat !== undefined) {
            queryParameters['img_format'] = requestParameters.imgFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projectsPk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topicsGuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedViewpointRequestToJSON(requestParameters.patchedViewpointRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewpointFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update some fields of a Viewpoint  Required scopes: bcf:write
     * Update some fields of a Viewpoint
     */
    async updateViewpoint(guid: string, projectsPk: number, topicsGuid: string, imgFormat?: UpdateViewpointImgFormatEnum, patchedViewpointRequest?: PatchedViewpointRequest): Promise<Viewpoint> {
        const response = await this.updateViewpointRaw({ guid: guid, projectsPk: projectsPk, topicsGuid: topicsGuid, imgFormat: imgFormat, patchedViewpointRequest: patchedViewpointRequest });
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum CreateFullTopicImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateViewpointImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum DeleteViewpointImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum FullUpdateFullTopicImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum FullUpdateViewpointImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetFullTopicImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetFullTopicsImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTopicViewpointsImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetViewpointImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetViewpointsImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateFullTopicImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateViewpointImgFormatEnum {
    Url = 'url'
}
