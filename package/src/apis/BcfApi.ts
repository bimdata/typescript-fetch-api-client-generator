/* tslint:disable */
/* eslint-disable */
/**
 * BIMData API
 * BIMData API is a tool to interact with your models stored on BIMDataâ€™s servers.     Through the API, you can manage your projects, the clouds, upload your IFC files and manage them through endpoints.
 *
 * The version of the OpenAPI document: v1 (v1)
 * Contact: support@bimdata.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Auth,
    AuthFromJSON,
    AuthToJSON,
    BcfProject,
    BcfProjectFromJSON,
    BcfProjectToJSON,
    BcfProjectRequest,
    BcfProjectRequestFromJSON,
    BcfProjectRequestToJSON,
    ColoringDefinition,
    ColoringDefinitionFromJSON,
    ColoringDefinitionToJSON,
    Comment,
    CommentFromJSON,
    CommentToJSON,
    CommentRequest,
    CommentRequestFromJSON,
    CommentRequestToJSON,
    DetailedExtensions,
    DetailedExtensionsFromJSON,
    DetailedExtensionsToJSON,
    Extensions,
    ExtensionsFromJSON,
    ExtensionsToJSON,
    FullTopic,
    FullTopicFromJSON,
    FullTopicToJSON,
    FullTopicRequest,
    FullTopicRequestFromJSON,
    FullTopicRequestToJSON,
    Label,
    LabelFromJSON,
    LabelToJSON,
    LabelRequest,
    LabelRequestFromJSON,
    LabelRequestToJSON,
    PatchedBcfProjectRequest,
    PatchedBcfProjectRequestFromJSON,
    PatchedBcfProjectRequestToJSON,
    PatchedCommentRequest,
    PatchedCommentRequestFromJSON,
    PatchedCommentRequestToJSON,
    PatchedFullTopicRequest,
    PatchedFullTopicRequestFromJSON,
    PatchedFullTopicRequestToJSON,
    PatchedLabelRequest,
    PatchedLabelRequestFromJSON,
    PatchedLabelRequestToJSON,
    PatchedPinRequest,
    PatchedPinRequestFromJSON,
    PatchedPinRequestToJSON,
    PatchedPriorityRequest,
    PatchedPriorityRequestFromJSON,
    PatchedPriorityRequestToJSON,
    PatchedStageRequest,
    PatchedStageRequestFromJSON,
    PatchedStageRequestToJSON,
    PatchedTopicRequest,
    PatchedTopicRequestFromJSON,
    PatchedTopicRequestToJSON,
    PatchedTopicStatusRequest,
    PatchedTopicStatusRequestFromJSON,
    PatchedTopicStatusRequestToJSON,
    PatchedTopicTypeRequest,
    PatchedTopicTypeRequestFromJSON,
    PatchedTopicTypeRequestToJSON,
    PatchedViewpointRequest,
    PatchedViewpointRequestFromJSON,
    PatchedViewpointRequestToJSON,
    Pin,
    PinFromJSON,
    PinToJSON,
    PinRequest,
    PinRequestFromJSON,
    PinRequestToJSON,
    Priority,
    PriorityFromJSON,
    PriorityToJSON,
    PriorityRequest,
    PriorityRequestFromJSON,
    PriorityRequestToJSON,
    SelectionDefinition,
    SelectionDefinitionFromJSON,
    SelectionDefinitionToJSON,
    SelfBcfUser,
    SelfBcfUserFromJSON,
    SelfBcfUserToJSON,
    Stage,
    StageFromJSON,
    StageToJSON,
    StageRequest,
    StageRequestFromJSON,
    StageRequestToJSON,
    Topic,
    TopicFromJSON,
    TopicToJSON,
    TopicPin,
    TopicPinFromJSON,
    TopicPinToJSON,
    TopicRequest,
    TopicRequestFromJSON,
    TopicRequestToJSON,
    TopicStatus,
    TopicStatusFromJSON,
    TopicStatusToJSON,
    TopicStatusRequest,
    TopicStatusRequestFromJSON,
    TopicStatusRequestToJSON,
    TopicType,
    TopicTypeFromJSON,
    TopicTypeToJSON,
    TopicTypeRequest,
    TopicTypeRequestFromJSON,
    TopicTypeRequestToJSON,
    Version,
    VersionFromJSON,
    VersionToJSON,
    Viewpoint,
    ViewpointFromJSON,
    ViewpointToJSON,
    ViewpointRequest,
    ViewpointRequestFromJSON,
    ViewpointRequestToJSON,
    VisibilityDefinition,
    VisibilityDefinitionFromJSON,
    VisibilityDefinitionToJSON,
} from '../models';

export interface CreateCommentRequest {
    projects_pk: number;
    topics_guid: string;
    CommentRequest?: CommentRequest;
}

export interface CreateExtensionLabelRequest {
    projects_pk: number;
    LabelRequest: LabelRequest;
}

export interface CreateExtensionPriorityRequest {
    projects_pk: number;
    PriorityRequest: PriorityRequest;
}

export interface CreateExtensionStageRequest {
    projects_pk: number;
    StageRequest: StageRequest;
}

export interface CreateExtensionStatusRequest {
    projects_pk: number;
    TopicStatusRequest: TopicStatusRequest;
}

export interface CreateExtensionTypeRequest {
    projects_pk: number;
    TopicTypeRequest: TopicTypeRequest;
}

export interface CreateFullTopicRequest {
    projects_pk: number;
    FullTopicRequest: FullTopicRequest;
    img_format?: CreateFullTopicImgFormatEnum;
}

export interface CreatePinRequest {
    projects_pk: number;
    topics_guid: string;
    viewpoints_guid: string;
    PinRequest: PinRequest;
}

export interface CreateTopicRequest {
    projects_pk: number;
    TopicRequest: TopicRequest;
}

export interface CreateViewpointRequest {
    projects_pk: number;
    topics_guid: string;
    img_format?: CreateViewpointImgFormatEnum;
    ViewpointRequest?: ViewpointRequest;
}

export interface DeleteCommentRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
}

export interface DeleteExtensionLabelRequest {
    id: number;
    projects_pk: number;
}

export interface DeleteExtensionPriorityRequest {
    id: number;
    projects_pk: number;
}

export interface DeleteExtensionStageRequest {
    id: number;
    projects_pk: number;
}

export interface DeleteExtensionStatusRequest {
    id: number;
    projects_pk: number;
}

export interface DeleteExtensionTypeRequest {
    id: number;
    projects_pk: number;
}

export interface DeletePinRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
    viewpoints_guid: string;
}

export interface DeleteTopicRequest {
    guid: string;
    projects_pk: number;
}

export interface DeleteViewpointRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
    img_format?: DeleteViewpointImgFormatEnum;
}

export interface DownloadBcfExportRequest {
    id: number;
    format?: string;
    topics?: string;
}

export interface DownloadBcfExportXlsxRequest {
    id: number;
    format?: string;
    locale?: DownloadBcfExportXlsxLocaleEnum;
    topics?: string;
}

export interface FullUpdateBcfProjectRequest {
    id: number;
    BcfProjectRequest: BcfProjectRequest;
}

export interface FullUpdateCommentRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
    CommentRequest?: CommentRequest;
}

export interface FullUpdateFullTopicRequest {
    guid: string;
    projects_pk: number;
    FullTopicRequest: FullTopicRequest;
    img_format?: FullUpdateFullTopicImgFormatEnum;
}

export interface FullUpdatePinRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
    viewpoints_guid: string;
    PinRequest: PinRequest;
}

export interface FullUpdateTopicRequest {
    guid: string;
    projects_pk: number;
    TopicRequest: TopicRequest;
}

export interface GetBcfProjectRequest {
    id: number;
}

export interface GetColoringsRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
}

export interface GetCommentRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
}

export interface GetCommentsRequest {
    projects_pk: number;
    topics_guid: string;
    $filter?: string;
    $orderby?: string;
}

export interface GetDetailedExtensionsRequest {
    id: number;
}

export interface GetExtensionsRequest {
    id: number;
}

export interface GetFullTopicRequest {
    guid: string;
    projects_pk: number;
    img_format?: GetFullTopicImgFormatEnum;
}

export interface GetFullTopicsRequest {
    projects_pk: number;
    $filter?: string;
    $orderby?: string;
    format?: string;
    ifcs?: Array<number>;
    img_format?: GetFullTopicsImgFormatEnum;
    models?: Array<number>;
}

export interface GetPinsRequest {
    projects_pk: number;
    topics_guid: string;
    viewpoints_guid: string;
}

export interface GetRelatedTopicsRequest {
    guid: string;
    projects_pk: number;
    format?: string;
    ifcs?: Array<number>;
    models?: Array<number>;
}

export interface GetSelectionsRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
}

export interface GetSnapshotRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
}

export interface GetTopicRequest {
    guid: string;
    projects_pk: number;
}

export interface GetTopicDocumentReferencesRequest {
    guid: string;
    projects_pk: number;
    format?: string;
    ifcs?: Array<number>;
    models?: Array<number>;
}

export interface GetTopicViewpointsRequest {
    projects_pk: number;
    topics_guid: string;
    img_format?: GetTopicViewpointsImgFormatEnum;
}

export interface GetTopicsRequest {
    projects_pk: number;
    $filter?: string;
    $orderby?: string;
    format?: string;
    ifcs?: Array<number>;
    models?: Array<number>;
}

export interface GetTopicsPinsRequest {
    projects_pk: number;
    format?: string;
    ifcs?: Array<number>;
    models?: Array<number>;
    topics?: string;
}

export interface GetViewpoinPinRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
    viewpoints_guid: string;
}

export interface GetViewpointRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
    img_format?: GetViewpointImgFormatEnum;
}

export interface GetViewpointsRequest {
    projects_pk: number;
    topics_guid: string;
    img_format?: GetViewpointsImgFormatEnum;
}

export interface GetVisibilitiesRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
}

export interface ImportBcfRequest {
    id: number;
    name: string;
}

export interface UpdateBcfProjectRequest {
    id: number;
    PatchedBcfProjectRequest?: PatchedBcfProjectRequest;
}

export interface UpdateCommentRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
    PatchedCommentRequest?: PatchedCommentRequest;
}

export interface UpdateExtensionLabelRequest {
    id: number;
    projects_pk: number;
    PatchedLabelRequest?: PatchedLabelRequest;
}

export interface UpdateExtensionPriorityRequest {
    id: number;
    projects_pk: number;
    PatchedPriorityRequest?: PatchedPriorityRequest;
}

export interface UpdateExtensionStageRequest {
    id: number;
    projects_pk: number;
    PatchedStageRequest?: PatchedStageRequest;
}

export interface UpdateExtensionStatusRequest {
    id: number;
    projects_pk: number;
    PatchedTopicStatusRequest?: PatchedTopicStatusRequest;
}

export interface UpdateExtensionTypeRequest {
    id: number;
    projects_pk: number;
    PatchedTopicTypeRequest?: PatchedTopicTypeRequest;
}

export interface UpdateFullTopicRequest {
    guid: string;
    projects_pk: number;
    img_format?: UpdateFullTopicImgFormatEnum;
    PatchedFullTopicRequest?: PatchedFullTopicRequest;
}

export interface UpdatePinRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
    viewpoints_guid: string;
    PatchedPinRequest?: PatchedPinRequest;
}

export interface UpdateTopicRequest {
    guid: string;
    projects_pk: number;
    PatchedTopicRequest?: PatchedTopicRequest;
}

export interface UpdateViewpointRequest {
    guid: string;
    projects_pk: number;
    topics_guid: string;
    img_format?: UpdateViewpointImgFormatEnum;
    PatchedViewpointRequest?: PatchedViewpointRequest;
}

/**
 * 
 */
export class BcfApi extends runtime.BaseAPI {

    /**
     * Create a comment  Required scopes: bcf:write
     * Create a comment
     */
    async createCommentRaw(requestParameters: CreateCommentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling createComment.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling createComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CommentRequestToJSON(requestParameters.CommentRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Create a comment  Required scopes: bcf:write
     * Create a comment
     */
    async createComment(projects_pk: number, topics_guid: string, CommentRequest?: CommentRequest, initOverrides?: RequestInit): Promise<Comment> {
        const response = await this.createCommentRaw({ projects_pk: projects_pk, topics_guid: topics_guid, CommentRequest: CommentRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Create a Label available for the project  Required scopes: bcf:write
     * Create a Label
     */
    async createExtensionLabelRaw(requestParameters: CreateExtensionLabelRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Label>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling createExtensionLabel.');
        }

        if (requestParameters.LabelRequest === null || requestParameters.LabelRequest === undefined) {
            throw new runtime.RequiredError('LabelRequest','Required parameter requestParameters.LabelRequest was null or undefined when calling createExtensionLabel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/label`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LabelRequestToJSON(requestParameters.LabelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LabelFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Create a Label available for the project  Required scopes: bcf:write
     * Create a Label
     */
    async createExtensionLabel(projects_pk: number, LabelRequest: LabelRequest, initOverrides?: RequestInit): Promise<Label> {
        const response = await this.createExtensionLabelRaw({ projects_pk: projects_pk, LabelRequest: LabelRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Create a Priority available for the project  Required scopes: bcf:write
     * Create a Priority
     */
    async createExtensionPriorityRaw(requestParameters: CreateExtensionPriorityRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Priority>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling createExtensionPriority.');
        }

        if (requestParameters.PriorityRequest === null || requestParameters.PriorityRequest === undefined) {
            throw new runtime.RequiredError('PriorityRequest','Required parameter requestParameters.PriorityRequest was null or undefined when calling createExtensionPriority.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/priority`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PriorityRequestToJSON(requestParameters.PriorityRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PriorityFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Create a Priority available for the project  Required scopes: bcf:write
     * Create a Priority
     */
    async createExtensionPriority(projects_pk: number, PriorityRequest: PriorityRequest, initOverrides?: RequestInit): Promise<Priority> {
        const response = await this.createExtensionPriorityRaw({ projects_pk: projects_pk, PriorityRequest: PriorityRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Create a Stage available for the project  Required scopes: bcf:write
     * Create a Stage
     */
    async createExtensionStageRaw(requestParameters: CreateExtensionStageRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Stage>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling createExtensionStage.');
        }

        if (requestParameters.StageRequest === null || requestParameters.StageRequest === undefined) {
            throw new runtime.RequiredError('StageRequest','Required parameter requestParameters.StageRequest was null or undefined when calling createExtensionStage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/stage`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StageRequestToJSON(requestParameters.StageRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StageFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Create a Stage available for the project  Required scopes: bcf:write
     * Create a Stage
     */
    async createExtensionStage(projects_pk: number, StageRequest: StageRequest, initOverrides?: RequestInit): Promise<Stage> {
        const response = await this.createExtensionStageRaw({ projects_pk: projects_pk, StageRequest: StageRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Create a TopicStatus available for the project  Required scopes: bcf:write
     * Create a TopicStatus
     */
    async createExtensionStatusRaw(requestParameters: CreateExtensionStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TopicStatus>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling createExtensionStatus.');
        }

        if (requestParameters.TopicStatusRequest === null || requestParameters.TopicStatusRequest === undefined) {
            throw new runtime.RequiredError('TopicStatusRequest','Required parameter requestParameters.TopicStatusRequest was null or undefined when calling createExtensionStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/status`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TopicStatusRequestToJSON(requestParameters.TopicStatusRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicStatusFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Create a TopicStatus available for the project  Required scopes: bcf:write
     * Create a TopicStatus
     */
    async createExtensionStatus(projects_pk: number, TopicStatusRequest: TopicStatusRequest, initOverrides?: RequestInit): Promise<TopicStatus> {
        const response = await this.createExtensionStatusRaw({ projects_pk: projects_pk, TopicStatusRequest: TopicStatusRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Create a TopicType available for the project  Required scopes: bcf:write
     * Create a TopicType
     */
    async createExtensionTypeRaw(requestParameters: CreateExtensionTypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TopicType>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling createExtensionType.');
        }

        if (requestParameters.TopicTypeRequest === null || requestParameters.TopicTypeRequest === undefined) {
            throw new runtime.RequiredError('TopicTypeRequest','Required parameter requestParameters.TopicTypeRequest was null or undefined when calling createExtensionType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/type`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TopicTypeRequestToJSON(requestParameters.TopicTypeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicTypeFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Create a TopicType available for the project  Required scopes: bcf:write
     * Create a TopicType
     */
    async createExtensionType(projects_pk: number, TopicTypeRequest: TopicTypeRequest, initOverrides?: RequestInit): Promise<TopicType> {
        const response = await this.createExtensionTypeRaw({ projects_pk: projects_pk, TopicTypeRequest: TopicTypeRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. You can send a topic, viewpoints and comments in a single call  Required scopes: bcf:write
     * Create a Topic with viewpoints and comments
     */
    async createFullTopicRaw(requestParameters: CreateFullTopicRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FullTopic>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling createFullTopic.');
        }

        if (requestParameters.FullTopicRequest === null || requestParameters.FullTopicRequest === undefined) {
            throw new runtime.RequiredError('FullTopicRequest','Required parameter requestParameters.FullTopicRequest was null or undefined when calling createFullTopic.');
        }

        const queryParameters: any = {};

        if (requestParameters.img_format !== undefined) {
            queryParameters['img_format'] = requestParameters.img_format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FullTopicRequestToJSON(requestParameters.FullTopicRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTopicFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. You can send a topic, viewpoints and comments in a single call  Required scopes: bcf:write
     * Create a Topic with viewpoints and comments
     */
    async createFullTopic(projects_pk: number, FullTopicRequest: FullTopicRequest, img_format?: CreateFullTopicImgFormatEnum, initOverrides?: RequestInit): Promise<FullTopic> {
        const response = await this.createFullTopicRaw({ projects_pk: projects_pk, FullTopicRequest: FullTopicRequest, img_format: img_format }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Create a Pin  Required scopes: bcf:write
     * Create a Pin
     */
    async createPinRaw(requestParameters: CreatePinRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Pin>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling createPin.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling createPin.');
        }

        if (requestParameters.viewpoints_guid === null || requestParameters.viewpoints_guid === undefined) {
            throw new runtime.RequiredError('viewpoints_guid','Required parameter requestParameters.viewpoints_guid was null or undefined when calling createPin.');
        }

        if (requestParameters.PinRequest === null || requestParameters.PinRequest === undefined) {
            throw new runtime.RequiredError('PinRequest','Required parameter requestParameters.PinRequest was null or undefined when calling createPin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{viewpoints_guid}/pin`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))).replace(`{${"viewpoints_guid"}}`, encodeURIComponent(String(requestParameters.viewpoints_guid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PinRequestToJSON(requestParameters.PinRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PinFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Create a Pin  Required scopes: bcf:write
     * Create a Pin
     */
    async createPin(projects_pk: number, topics_guid: string, viewpoints_guid: string, PinRequest: PinRequest, initOverrides?: RequestInit): Promise<Pin> {
        const response = await this.createPinRaw({ projects_pk: projects_pk, topics_guid: topics_guid, viewpoints_guid: viewpoints_guid, PinRequest: PinRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Create a topic  Required scopes: bcf:write
     * Create a topic
     */
    async createTopicRaw(requestParameters: CreateTopicRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling createTopic.');
        }

        if (requestParameters.TopicRequest === null || requestParameters.TopicRequest === undefined) {
            throw new runtime.RequiredError('TopicRequest','Required parameter requestParameters.TopicRequest was null or undefined when calling createTopic.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TopicRequestToJSON(requestParameters.TopicRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * Create a topic  Required scopes: bcf:write
     * Create a topic
     */
    async createTopic(projects_pk: number, TopicRequest: TopicRequest, initOverrides?: RequestInit): Promise<Topic> {
        const response = await this.createTopicRaw({ projects_pk: projects_pk, TopicRequest: TopicRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Create a Viewpoint  Required scopes: bcf:write
     * Create a Viewpoint
     */
    async createViewpointRaw(requestParameters: CreateViewpointRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Viewpoint>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling createViewpoint.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling createViewpoint.');
        }

        const queryParameters: any = {};

        if (requestParameters.img_format !== undefined) {
            queryParameters['img_format'] = requestParameters.img_format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ViewpointRequestToJSON(requestParameters.ViewpointRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewpointFromJSON(jsonValue));
    }

    /**
     * Create a Viewpoint  Required scopes: bcf:write
     * Create a Viewpoint
     */
    async createViewpoint(projects_pk: number, topics_guid: string, img_format?: CreateViewpointImgFormatEnum, ViewpointRequest?: ViewpointRequest, initOverrides?: RequestInit): Promise<Viewpoint> {
        const response = await this.createViewpointRaw({ projects_pk: projects_pk, topics_guid: topics_guid, img_format: img_format, ViewpointRequest: ViewpointRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Delete a comment  Required scopes: bcf:write
     * Delete a comment
     */
    async deleteCommentRaw(requestParameters: DeleteCommentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling deleteComment.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling deleteComment.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling deleteComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a comment  Required scopes: bcf:write
     * Delete a comment
     */
    async deleteComment(guid: string, projects_pk: number, topics_guid: string, initOverrides?: RequestInit): Promise<void> {
        await this.deleteCommentRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid }, initOverrides);
    }

    /**
     * This is not a standard route. Delete a Label. Topics using this label won\'t be deleted   Required scopes: bcf:write
     * Delete a Label
     */
    async deleteExtensionLabelRaw(requestParameters: DeleteExtensionLabelRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteExtensionLabel.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling deleteExtensionLabel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/label/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a Label. Topics using this label won\'t be deleted   Required scopes: bcf:write
     * Delete a Label
     */
    async deleteExtensionLabel(id: number, projects_pk: number, initOverrides?: RequestInit): Promise<void> {
        await this.deleteExtensionLabelRaw({ id: id, projects_pk: projects_pk }, initOverrides);
    }

    /**
     * This is not a standard route. Delete a Priority. Topics using this priority won\'t be deleted   Required scopes: bcf:write
     * Delete a Priority
     */
    async deleteExtensionPriorityRaw(requestParameters: DeleteExtensionPriorityRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteExtensionPriority.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling deleteExtensionPriority.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/priority/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a Priority. Topics using this priority won\'t be deleted   Required scopes: bcf:write
     * Delete a Priority
     */
    async deleteExtensionPriority(id: number, projects_pk: number, initOverrides?: RequestInit): Promise<void> {
        await this.deleteExtensionPriorityRaw({ id: id, projects_pk: projects_pk }, initOverrides);
    }

    /**
     * This is not a standard route. Delete a Stage. Topics using this stage won\'t be deleted   Required scopes: bcf:write
     * Delete a Stage
     */
    async deleteExtensionStageRaw(requestParameters: DeleteExtensionStageRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteExtensionStage.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling deleteExtensionStage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/stage/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a Stage. Topics using this stage won\'t be deleted   Required scopes: bcf:write
     * Delete a Stage
     */
    async deleteExtensionStage(id: number, projects_pk: number, initOverrides?: RequestInit): Promise<void> {
        await this.deleteExtensionStageRaw({ id: id, projects_pk: projects_pk }, initOverrides);
    }

    /**
     * This is not a standard route. Delete a TopicStatus. Topics using this status won\'t be deleted   Required scopes: bcf:write
     * Delete a TopicStatus
     */
    async deleteExtensionStatusRaw(requestParameters: DeleteExtensionStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteExtensionStatus.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling deleteExtensionStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/status/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a TopicStatus. Topics using this status won\'t be deleted   Required scopes: bcf:write
     * Delete a TopicStatus
     */
    async deleteExtensionStatus(id: number, projects_pk: number, initOverrides?: RequestInit): Promise<void> {
        await this.deleteExtensionStatusRaw({ id: id, projects_pk: projects_pk }, initOverrides);
    }

    /**
     * This is not a standard route. Delete a TopicType. Topics using this type won\'t be deleted  Required scopes: bcf:write
     * Delete a TopicType
     */
    async deleteExtensionTypeRaw(requestParameters: DeleteExtensionTypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteExtensionType.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling deleteExtensionType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/type/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a TopicType. Topics using this type won\'t be deleted  Required scopes: bcf:write
     * Delete a TopicType
     */
    async deleteExtensionType(id: number, projects_pk: number, initOverrides?: RequestInit): Promise<void> {
        await this.deleteExtensionTypeRaw({ id: id, projects_pk: projects_pk }, initOverrides);
    }

    /**
     * This is not a standard route. Delete a Pin  Required scopes: bcf:write
     * Delete a Pin
     */
    async deletePinRaw(requestParameters: DeletePinRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling deletePin.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling deletePin.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling deletePin.');
        }

        if (requestParameters.viewpoints_guid === null || requestParameters.viewpoints_guid === undefined) {
            throw new runtime.RequiredError('viewpoints_guid','Required parameter requestParameters.viewpoints_guid was null or undefined when calling deletePin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{viewpoints_guid}/pin/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))).replace(`{${"viewpoints_guid"}}`, encodeURIComponent(String(requestParameters.viewpoints_guid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a Pin  Required scopes: bcf:write
     * Delete a Pin
     */
    async deletePin(guid: string, projects_pk: number, topics_guid: string, viewpoints_guid: string, initOverrides?: RequestInit): Promise<void> {
        await this.deletePinRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid, viewpoints_guid: viewpoints_guid }, initOverrides);
    }

    /**
     * Delete a topic  Required scopes: bcf:write
     * Delete a topic
     */
    async deleteTopicRaw(requestParameters: DeleteTopicRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling deleteTopic.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling deleteTopic.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a topic  Required scopes: bcf:write
     * Delete a topic
     */
    async deleteTopic(guid: string, projects_pk: number, initOverrides?: RequestInit): Promise<void> {
        await this.deleteTopicRaw({ guid: guid, projects_pk: projects_pk }, initOverrides);
    }

    /**
     * This is not a standard route. Delete a Viewpoint  Required scopes: bcf:write
     * Delete a Viewpoint
     */
    async deleteViewpointRaw(requestParameters: DeleteViewpointRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling deleteViewpoint.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling deleteViewpoint.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling deleteViewpoint.');
        }

        const queryParameters: any = {};

        if (requestParameters.img_format !== undefined) {
            queryParameters['img_format'] = requestParameters.img_format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Delete a Viewpoint  Required scopes: bcf:write
     * Delete a Viewpoint
     */
    async deleteViewpoint(guid: string, projects_pk: number, topics_guid: string, img_format?: DeleteViewpointImgFormatEnum, initOverrides?: RequestInit): Promise<void> {
        await this.deleteViewpointRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid, img_format: img_format }, initOverrides);
    }

    /**
     * This is not a standard route. Export project\'s topics in bcf-xml format  Required scopes: bcf:read
     * Export project\'s topics in bcf-xml format
     */
    async downloadBcfExportRaw(requestParameters: DownloadBcfExportRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling downloadBcfExport.');
        }

        const queryParameters: any = {};

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.topics !== undefined) {
            queryParameters['topics'] = requestParameters.topics;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}/export`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * This is not a standard route. Export project\'s topics in bcf-xml format  Required scopes: bcf:read
     * Export project\'s topics in bcf-xml format
     */
    async downloadBcfExport(id: number, format?: string, topics?: string, initOverrides?: RequestInit): Promise<Blob> {
        const response = await this.downloadBcfExportRaw({ id: id, format: format, topics: topics }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Export project\'s topics in excel format  Required scopes: bcf:read
     * Export project\'s topics in excel format
     */
    async downloadBcfExportXlsxRaw(requestParameters: DownloadBcfExportXlsxRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling downloadBcfExportXlsx.');
        }

        const queryParameters: any = {};

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.locale !== undefined) {
            queryParameters['locale'] = requestParameters.locale;
        }

        if (requestParameters.topics !== undefined) {
            queryParameters['topics'] = requestParameters.topics;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}/export-xlsx`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * This is not a standard route. Export project\'s topics in excel format  Required scopes: bcf:read
     * Export project\'s topics in excel format
     */
    async downloadBcfExportXlsx(id: number, format?: string, locale?: DownloadBcfExportXlsxLocaleEnum, topics?: string, initOverrides?: RequestInit): Promise<Blob> {
        const response = await this.downloadBcfExportXlsxRaw({ id: id, format: format, locale: locale, topics: topics }, initOverrides);
        return await response.value();
    }

    /**
     * Update all fields of a BCF project  Required scopes: bcf:write
     * Update all fields of a BCF project
     */
    async fullUpdateBcfProjectRaw(requestParameters: FullUpdateBcfProjectRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BcfProject>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling fullUpdateBcfProject.');
        }

        if (requestParameters.BcfProjectRequest === null || requestParameters.BcfProjectRequest === undefined) {
            throw new runtime.RequiredError('BcfProjectRequest','Required parameter requestParameters.BcfProjectRequest was null or undefined when calling fullUpdateBcfProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BcfProjectRequestToJSON(requestParameters.BcfProjectRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BcfProjectFromJSON(jsonValue));
    }

    /**
     * Update all fields of a BCF project  Required scopes: bcf:write
     * Update all fields of a BCF project
     */
    async fullUpdateBcfProject(id: number, BcfProjectRequest: BcfProjectRequest, initOverrides?: RequestInit): Promise<BcfProject> {
        const response = await this.fullUpdateBcfProjectRaw({ id: id, BcfProjectRequest: BcfProjectRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Update all fields of a comment  Required scopes: bcf:write
     * Update all fields of a comment
     */
    async fullUpdateCommentRaw(requestParameters: FullUpdateCommentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling fullUpdateComment.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling fullUpdateComment.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling fullUpdateComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CommentRequestToJSON(requestParameters.CommentRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Update all fields of a comment  Required scopes: bcf:write
     * Update all fields of a comment
     */
    async fullUpdateComment(guid: string, projects_pk: number, topics_guid: string, CommentRequest?: CommentRequest, initOverrides?: RequestInit): Promise<Comment> {
        const response = await this.fullUpdateCommentRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid, CommentRequest: CommentRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. You can update topic, viewpoints and comment is a signle call  Required scopes: bcf:write
     * Update all fields of a topic
     */
    async fullUpdateFullTopicRaw(requestParameters: FullUpdateFullTopicRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FullTopic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling fullUpdateFullTopic.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling fullUpdateFullTopic.');
        }

        if (requestParameters.FullTopicRequest === null || requestParameters.FullTopicRequest === undefined) {
            throw new runtime.RequiredError('FullTopicRequest','Required parameter requestParameters.FullTopicRequest was null or undefined when calling fullUpdateFullTopic.');
        }

        const queryParameters: any = {};

        if (requestParameters.img_format !== undefined) {
            queryParameters['img_format'] = requestParameters.img_format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FullTopicRequestToJSON(requestParameters.FullTopicRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTopicFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. You can update topic, viewpoints and comment is a signle call  Required scopes: bcf:write
     * Update all fields of a topic
     */
    async fullUpdateFullTopic(guid: string, projects_pk: number, FullTopicRequest: FullTopicRequest, img_format?: FullUpdateFullTopicImgFormatEnum, initOverrides?: RequestInit): Promise<FullTopic> {
        const response = await this.fullUpdateFullTopicRaw({ guid: guid, projects_pk: projects_pk, FullTopicRequest: FullTopicRequest, img_format: img_format }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Update all fields of a Pin  Required scopes: bcf:write
     * Update all fields of a Pin
     */
    async fullUpdatePinRaw(requestParameters: FullUpdatePinRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Pin>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling fullUpdatePin.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling fullUpdatePin.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling fullUpdatePin.');
        }

        if (requestParameters.viewpoints_guid === null || requestParameters.viewpoints_guid === undefined) {
            throw new runtime.RequiredError('viewpoints_guid','Required parameter requestParameters.viewpoints_guid was null or undefined when calling fullUpdatePin.');
        }

        if (requestParameters.PinRequest === null || requestParameters.PinRequest === undefined) {
            throw new runtime.RequiredError('PinRequest','Required parameter requestParameters.PinRequest was null or undefined when calling fullUpdatePin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{viewpoints_guid}/pin/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))).replace(`{${"viewpoints_guid"}}`, encodeURIComponent(String(requestParameters.viewpoints_guid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PinRequestToJSON(requestParameters.PinRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PinFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update all fields of a Pin  Required scopes: bcf:write
     * Update all fields of a Pin
     */
    async fullUpdatePin(guid: string, projects_pk: number, topics_guid: string, viewpoints_guid: string, PinRequest: PinRequest, initOverrides?: RequestInit): Promise<Pin> {
        const response = await this.fullUpdatePinRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid, viewpoints_guid: viewpoints_guid, PinRequest: PinRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Update all fields of a topic  Required scopes: bcf:write
     * Update all fields of a topic
     */
    async fullUpdateTopicRaw(requestParameters: FullUpdateTopicRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling fullUpdateTopic.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling fullUpdateTopic.');
        }

        if (requestParameters.TopicRequest === null || requestParameters.TopicRequest === undefined) {
            throw new runtime.RequiredError('TopicRequest','Required parameter requestParameters.TopicRequest was null or undefined when calling fullUpdateTopic.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TopicRequestToJSON(requestParameters.TopicRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * Update all fields of a topic  Required scopes: bcf:write
     * Update all fields of a topic
     */
    async fullUpdateTopic(guid: string, projects_pk: number, TopicRequest: TopicRequest, initOverrides?: RequestInit): Promise<Topic> {
        const response = await this.fullUpdateTopicRaw({ guid: guid, projects_pk: projects_pk, TopicRequest: TopicRequest }, initOverrides);
        return await response.value();
    }

    /**
     * oauth2_dynamic_client_reg_url is not supported, http_basic_supported is always set to false, 
     * Retrieve Authentication Information
     */
    async getAuthRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Auth>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/auth`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuthFromJSON));
    }

    /**
     * oauth2_dynamic_client_reg_url is not supported, http_basic_supported is always set to false, 
     * Retrieve Authentication Information
     */
    async getAuth(initOverrides?: RequestInit): Promise<Array<Auth>> {
        const response = await this.getAuthRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a BCF project  Required scopes: bcf:read
     * Retrieve a BCF project
     */
    async getBcfProjectRaw(requestParameters: GetBcfProjectRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BcfProject>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getBcfProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BcfProjectFromJSON(jsonValue));
    }

    /**
     * Retrieve a BCF project  Required scopes: bcf:read
     * Retrieve a BCF project
     */
    async getBcfProject(id: number, initOverrides?: RequestInit): Promise<BcfProject> {
        const response = await this.getBcfProjectRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all BCF projects  Required scopes: bcf:read
     * Retrieve all BCF projects
     */
    async getBcfProjectsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<BcfProject>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BcfProjectFromJSON));
    }

    /**
     * Retrieve all BCF projects  Required scopes: bcf:read
     * Retrieve all BCF projects
     */
    async getBcfProjects(initOverrides?: RequestInit): Promise<Array<BcfProject>> {
        const response = await this.getBcfProjectsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all colorings of a viewpoint  Required scopes: bcf:read
     * Retrieve all colorings of a viewpoint
     */
    async getColoringsRaw(requestParameters: GetColoringsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ColoringDefinition>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getColorings.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getColorings.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling getColorings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/coloring`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ColoringDefinitionFromJSON(jsonValue));
    }

    /**
     * Retrieve all colorings of a viewpoint  Required scopes: bcf:read
     * Retrieve all colorings of a viewpoint
     */
    async getColorings(guid: string, projects_pk: number, topics_guid: string, initOverrides?: RequestInit): Promise<ColoringDefinition> {
        const response = await this.getColoringsRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a comment  Required scopes: bcf:read
     * Retrieve a comment
     */
    async getCommentRaw(requestParameters: GetCommentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getComment.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getComment.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling getComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Retrieve a comment  Required scopes: bcf:read
     * Retrieve a comment
     */
    async getComment(guid: string, projects_pk: number, topics_guid: string, initOverrides?: RequestInit): Promise<Comment> {
        const response = await this.getCommentRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all comments  Required scopes: bcf:read
     * Retrieve all comments
     */
    async getCommentsRaw(requestParameters: GetCommentsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Comment>>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getComments.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling getComments.');
        }

        const queryParameters: any = {};

        if (requestParameters.$filter !== undefined) {
            queryParameters['$filter'] = requestParameters.$filter;
        }

        if (requestParameters.$orderby !== undefined) {
            queryParameters['$orderby'] = requestParameters.$orderby;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CommentFromJSON));
    }

    /**
     * Retrieve all comments  Required scopes: bcf:read
     * Retrieve all comments
     */
    async getComments(projects_pk: number, topics_guid: string, $filter?: string, $orderby?: string, initOverrides?: RequestInit): Promise<Array<Comment>> {
        const response = await this.getCommentsRaw({ projects_pk: projects_pk, topics_guid: topics_guid, $filter: $filter, $orderby: $orderby }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Retrieve project detailed extensions  Required scopes: bcf:read
     * Retrieve project detailed extensions
     */
    async getDetailedExtensionsRaw(requestParameters: GetDetailedExtensionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<DetailedExtensions>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getDetailedExtensions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}/detailed-extensions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DetailedExtensionsFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Retrieve project detailed extensions  Required scopes: bcf:read
     * Retrieve project detailed extensions
     */
    async getDetailedExtensions(id: number, initOverrides?: RequestInit): Promise<DetailedExtensions> {
        const response = await this.getDetailedExtensionsRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve project extensions  Required scopes: bcf:read
     * Retrieve project extensions
     */
    async getExtensionsRaw(requestParameters: GetExtensionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Extensions>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getExtensions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}/extensions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExtensionsFromJSON(jsonValue));
    }

    /**
     * Retrieve project extensions  Required scopes: bcf:read
     * Retrieve project extensions
     */
    async getExtensions(id: number, initOverrides?: RequestInit): Promise<Extensions> {
        const response = await this.getExtensionsRaw({ id: id }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. It responds with a topic, its viewpoints and its comments  Required scopes: bcf:read
     * Retrieve a full topic
     */
    async getFullTopicRaw(requestParameters: GetFullTopicRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FullTopic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getFullTopic.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getFullTopic.');
        }

        const queryParameters: any = {};

        if (requestParameters.img_format !== undefined) {
            queryParameters['img_format'] = requestParameters.img_format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTopicFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. It responds with a topic, its viewpoints and its comments  Required scopes: bcf:read
     * Retrieve a full topic
     */
    async getFullTopic(guid: string, projects_pk: number, img_format?: GetFullTopicImgFormatEnum, initOverrides?: RequestInit): Promise<FullTopic> {
        const response = await this.getFullTopicRaw({ guid: guid, projects_pk: projects_pk, img_format: img_format }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. It responds with all topics, their viewpoints and their comments  Required scopes: bcf:read
     * Retrieve all full topics
     */
    async getFullTopicsRaw(requestParameters: GetFullTopicsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<FullTopic>>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getFullTopics.');
        }

        const queryParameters: any = {};

        if (requestParameters.$filter !== undefined) {
            queryParameters['$filter'] = requestParameters.$filter;
        }

        if (requestParameters.$orderby !== undefined) {
            queryParameters['$orderby'] = requestParameters.$orderby;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.ifcs) {
            queryParameters['ifcs'] = requestParameters.ifcs;
        }

        if (requestParameters.img_format !== undefined) {
            queryParameters['img_format'] = requestParameters.img_format;
        }

        if (requestParameters.models) {
            queryParameters['models'] = requestParameters.models;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FullTopicFromJSON));
    }

    /**
     * This is not a standard route. It responds with all topics, their viewpoints and their comments  Required scopes: bcf:read
     * Retrieve all full topics
     */
    async getFullTopics(projects_pk: number, $filter?: string, $orderby?: string, format?: string, ifcs?: Array<number>, img_format?: GetFullTopicsImgFormatEnum, models?: Array<number>, initOverrides?: RequestInit): Promise<Array<FullTopic>> {
        const response = await this.getFullTopicsRaw({ projects_pk: projects_pk, $filter: $filter, $orderby: $orderby, format: format, ifcs: ifcs, img_format: img_format, models: models }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Retrieve all Pins of a viewpoint  Required scopes: bcf:read
     * Retrieve all Pins of a viewpoint
     */
    async getPinsRaw(requestParameters: GetPinsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Pin>>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getPins.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling getPins.');
        }

        if (requestParameters.viewpoints_guid === null || requestParameters.viewpoints_guid === undefined) {
            throw new runtime.RequiredError('viewpoints_guid','Required parameter requestParameters.viewpoints_guid was null or undefined when calling getPins.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{viewpoints_guid}/pin`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))).replace(`{${"viewpoints_guid"}}`, encodeURIComponent(String(requestParameters.viewpoints_guid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PinFromJSON));
    }

    /**
     * This is not a standard route. Retrieve all Pins of a viewpoint  Required scopes: bcf:read
     * Retrieve all Pins of a viewpoint
     */
    async getPins(projects_pk: number, topics_guid: string, viewpoints_guid: string, initOverrides?: RequestInit): Promise<Array<Pin>> {
        const response = await this.getPinsRaw({ projects_pk: projects_pk, topics_guid: topics_guid, viewpoints_guid: viewpoints_guid }, initOverrides);
        return await response.value();
    }

    /**
     * This feature is not supported yet and will always respond with an empty array  Required scopes: bcf:read
     * Get all related topics
     */
    async getRelatedTopicsRaw(requestParameters: GetRelatedTopicsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getRelatedTopics.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getRelatedTopics.');
        }

        const queryParameters: any = {};

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.ifcs) {
            queryParameters['ifcs'] = requestParameters.ifcs;
        }

        if (requestParameters.models) {
            queryParameters['models'] = requestParameters.models;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}/related_topics`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This feature is not supported yet and will always respond with an empty array  Required scopes: bcf:read
     * Get all related topics
     */
    async getRelatedTopics(guid: string, projects_pk: number, format?: string, ifcs?: Array<number>, models?: Array<number>, initOverrides?: RequestInit): Promise<Array<string>> {
        const response = await this.getRelatedTopicsRaw({ guid: guid, projects_pk: projects_pk, format: format, ifcs: ifcs, models: models }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all selections of a viewpoint  Required scopes: bcf:read
     * Retrieve all selections of a viewpoint
     */
    async getSelectionsRaw(requestParameters: GetSelectionsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<SelectionDefinition>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getSelections.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getSelections.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling getSelections.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/selection`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SelectionDefinitionFromJSON(jsonValue));
    }

    /**
     * Retrieve all selections of a viewpoint  Required scopes: bcf:read
     * Retrieve all selections of a viewpoint
     */
    async getSelections(guid: string, projects_pk: number, topics_guid: string, initOverrides?: RequestInit): Promise<SelectionDefinition> {
        const response = await this.getSelectionsRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the viewpoint\' snapshot  Required scopes: bcf:read
     * Retrieve the viewpoint\' snapshot
     */
    async getSnapshotRaw(requestParameters: GetSnapshotRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getSnapshot.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getSnapshot.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling getSnapshot.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/snapshot`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Retrieve the viewpoint\' snapshot  Required scopes: bcf:read
     * Retrieve the viewpoint\' snapshot
     */
    async getSnapshot(guid: string, projects_pk: number, topics_guid: string, initOverrides?: RequestInit): Promise<Blob> {
        const response = await this.getSnapshotRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a topic  Required scopes: bcf:read
     * Retrieve a topic
     */
    async getTopicRaw(requestParameters: GetTopicRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getTopic.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getTopic.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * Retrieve a topic  Required scopes: bcf:read
     * Retrieve a topic
     */
    async getTopic(guid: string, projects_pk: number, initOverrides?: RequestInit): Promise<Topic> {
        const response = await this.getTopicRaw({ guid: guid, projects_pk: projects_pk }, initOverrides);
        return await response.value();
    }

    /**
     * This feature is not supported yet and will always respond with an empty array  Required scopes: bcf:read
     * Get all related documents
     */
    async getTopicDocumentReferencesRaw(requestParameters: GetTopicDocumentReferencesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getTopicDocumentReferences.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getTopicDocumentReferences.');
        }

        const queryParameters: any = {};

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.ifcs) {
            queryParameters['ifcs'] = requestParameters.ifcs;
        }

        if (requestParameters.models) {
            queryParameters['models'] = requestParameters.models;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}/document_references`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This feature is not supported yet and will always respond with an empty array  Required scopes: bcf:read
     * Get all related documents
     */
    async getTopicDocumentReferences(guid: string, projects_pk: number, format?: string, ifcs?: Array<number>, models?: Array<number>, initOverrides?: RequestInit): Promise<Array<string>> {
        const response = await this.getTopicDocumentReferencesRaw({ guid: guid, projects_pk: projects_pk, format: format, ifcs: ifcs, models: models }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. It returns all viewpoints of the topic that are not attached to a comment.  Required scopes: bcf:read
     * Retrieve all viewpoints attached to the topic
     */
    async getTopicViewpointsRaw(requestParameters: GetTopicViewpointsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Viewpoint>>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getTopicViewpoints.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling getTopicViewpoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.img_format !== undefined) {
            queryParameters['img_format'] = requestParameters.img_format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/topic-viewpoints`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ViewpointFromJSON));
    }

    /**
     * This is not a standard route. It returns all viewpoints of the topic that are not attached to a comment.  Required scopes: bcf:read
     * Retrieve all viewpoints attached to the topic
     */
    async getTopicViewpoints(projects_pk: number, topics_guid: string, img_format?: GetTopicViewpointsImgFormatEnum, initOverrides?: RequestInit): Promise<Array<Viewpoint>> {
        const response = await this.getTopicViewpointsRaw({ projects_pk: projects_pk, topics_guid: topics_guid, img_format: img_format }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all topics  Required scopes: bcf:read
     * Retrieve all topics
     */
    async getTopicsRaw(requestParameters: GetTopicsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Topic>>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getTopics.');
        }

        const queryParameters: any = {};

        if (requestParameters.$filter !== undefined) {
            queryParameters['$filter'] = requestParameters.$filter;
        }

        if (requestParameters.$orderby !== undefined) {
            queryParameters['$orderby'] = requestParameters.$orderby;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.ifcs) {
            queryParameters['ifcs'] = requestParameters.ifcs;
        }

        if (requestParameters.models) {
            queryParameters['models'] = requestParameters.models;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TopicFromJSON));
    }

    /**
     * Retrieve all topics  Required scopes: bcf:read
     * Retrieve all topics
     */
    async getTopics(projects_pk: number, $filter?: string, $orderby?: string, format?: string, ifcs?: Array<number>, models?: Array<number>, initOverrides?: RequestInit): Promise<Array<Topic>> {
        const response = await this.getTopicsRaw({ projects_pk: projects_pk, $filter: $filter, $orderby: $orderby, format: format, ifcs: ifcs, models: models }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Get pins of all or many topics  Required scopes: bcf:read
     * Get pins of all or many topics
     */
    async getTopicsPinsRaw(requestParameters: GetTopicsPinsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<TopicPin>>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getTopicsPins.');
        }

        const queryParameters: any = {};

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        if (requestParameters.ifcs) {
            queryParameters['ifcs'] = requestParameters.ifcs;
        }

        if (requestParameters.models) {
            queryParameters['models'] = requestParameters.models;
        }

        if (requestParameters.topics !== undefined) {
            queryParameters['topics'] = requestParameters.topics;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/pins`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TopicPinFromJSON));
    }

    /**
     * This is not a standard route. Get pins of all or many topics  Required scopes: bcf:read
     * Get pins of all or many topics
     */
    async getTopicsPins(projects_pk: number, format?: string, ifcs?: Array<number>, models?: Array<number>, topics?: string, initOverrides?: RequestInit): Promise<Array<TopicPin>> {
        const response = await this.getTopicsPinsRaw({ projects_pk: projects_pk, format: format, ifcs: ifcs, models: models, topics: topics }, initOverrides);
        return await response.value();
    }

    /**
     * Get current user info. If request comes from an App, the response is always:{    \"id\": None,    \"name\": None,    \"is_client\": True,}  Required scopes: bcf:read
     * Get current user info
     */
    async getUserRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<SelfBcfUser>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/current-user`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SelfBcfUserFromJSON(jsonValue));
    }

    /**
     * Get current user info. If request comes from an App, the response is always:{    \"id\": None,    \"name\": None,    \"is_client\": True,}  Required scopes: bcf:read
     * Get current user info
     */
    async getUser(initOverrides?: RequestInit): Promise<SelfBcfUser> {
        const response = await this.getUserRaw(initOverrides);
        return await response.value();
    }

    /**
     * Spoiler: it\'s only v2.1
     * Retrieve all supported BCF versions by this API
     */
    async getVersionsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Version>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/versions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(VersionFromJSON));
    }

    /**
     * Spoiler: it\'s only v2.1
     * Retrieve all supported BCF versions by this API
     */
    async getVersions(initOverrides?: RequestInit): Promise<Array<Version>> {
        const response = await this.getVersionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Retrieve a Pin  Required scopes: bcf:read
     * Retrieve a Pin
     */
    async getViewpoinPinRaw(requestParameters: GetViewpoinPinRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Pin>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getViewpoinPin.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getViewpoinPin.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling getViewpoinPin.');
        }

        if (requestParameters.viewpoints_guid === null || requestParameters.viewpoints_guid === undefined) {
            throw new runtime.RequiredError('viewpoints_guid','Required parameter requestParameters.viewpoints_guid was null or undefined when calling getViewpoinPin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{viewpoints_guid}/pin/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))).replace(`{${"viewpoints_guid"}}`, encodeURIComponent(String(requestParameters.viewpoints_guid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PinFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Retrieve a Pin  Required scopes: bcf:read
     * Retrieve a Pin
     */
    async getViewpoinPin(guid: string, projects_pk: number, topics_guid: string, viewpoints_guid: string, initOverrides?: RequestInit): Promise<Pin> {
        const response = await this.getViewpoinPinRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid, viewpoints_guid: viewpoints_guid }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a Viewpoint  Required scopes: bcf:read
     * Retrieve a Viewpoint
     */
    async getViewpointRaw(requestParameters: GetViewpointRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Viewpoint>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getViewpoint.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getViewpoint.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling getViewpoint.');
        }

        const queryParameters: any = {};

        if (requestParameters.img_format !== undefined) {
            queryParameters['img_format'] = requestParameters.img_format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewpointFromJSON(jsonValue));
    }

    /**
     * Retrieve a Viewpoint  Required scopes: bcf:read
     * Retrieve a Viewpoint
     */
    async getViewpoint(guid: string, projects_pk: number, topics_guid: string, img_format?: GetViewpointImgFormatEnum, initOverrides?: RequestInit): Promise<Viewpoint> {
        const response = await this.getViewpointRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid, img_format: img_format }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all Viewpoints of a topic  Required scopes: bcf:read
     * Retrieve all Viewpoints of a topic
     */
    async getViewpointsRaw(requestParameters: GetViewpointsRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<Viewpoint>>> {
        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getViewpoints.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling getViewpoints.');
        }

        const queryParameters: any = {};

        if (requestParameters.img_format !== undefined) {
            queryParameters['img_format'] = requestParameters.img_format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints`.replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ViewpointFromJSON));
    }

    /**
     * Retrieve all Viewpoints of a topic  Required scopes: bcf:read
     * Retrieve all Viewpoints of a topic
     */
    async getViewpoints(projects_pk: number, topics_guid: string, img_format?: GetViewpointsImgFormatEnum, initOverrides?: RequestInit): Promise<Array<Viewpoint>> {
        const response = await this.getViewpointsRaw({ projects_pk: projects_pk, topics_guid: topics_guid, img_format: img_format }, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all visibilities of a viewpoint  Required scopes: bcf:read
     * Retrieve all visibilities of a viewpoint
     */
    async getVisibilitiesRaw(requestParameters: GetVisibilitiesRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<VisibilityDefinition>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling getVisibilities.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling getVisibilities.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling getVisibilities.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/visibility`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VisibilityDefinitionFromJSON(jsonValue));
    }

    /**
     * Retrieve all visibilities of a viewpoint  Required scopes: bcf:read
     * Retrieve all visibilities of a viewpoint
     */
    async getVisibilities(guid: string, projects_pk: number, topics_guid: string, initOverrides?: RequestInit): Promise<VisibilityDefinition> {
        const response = await this.getVisibilitiesRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Import bcf-xml format into this project. If there are guid conflict, an error will be raised. If there are index conflicts, indexes of the imported file will be overriden with a new index. Author and assigned_to fields will be linked to existing users in the project. If no matching user are found, fields will be emptied. Only BCF 2.1 is supported  Required scopes: bcf:write
     * Import bcf-xml format into this project
     */
    async importBcfRaw(requestParameters: ImportBcfRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling importBcf.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling importBcf.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}/import`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This is not a standard route. Import bcf-xml format into this project. If there are guid conflict, an error will be raised. If there are index conflicts, indexes of the imported file will be overriden with a new index. Author and assigned_to fields will be linked to existing users in the project. If no matching user are found, fields will be emptied. Only BCF 2.1 is supported  Required scopes: bcf:write
     * Import bcf-xml format into this project
     */
    async importBcf(id: number, name: string, initOverrides?: RequestInit): Promise<void> {
        await this.importBcfRaw({ id: id, name: name }, initOverrides);
    }

    /**
     * Update some fields of a BCF project  Required scopes: bcf:write
     * Update some fields of a BCF project
     */
    async updateBcfProjectRaw(requestParameters: UpdateBcfProjectRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<BcfProject>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateBcfProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedBcfProjectRequestToJSON(requestParameters.PatchedBcfProjectRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BcfProjectFromJSON(jsonValue));
    }

    /**
     * Update some fields of a BCF project  Required scopes: bcf:write
     * Update some fields of a BCF project
     */
    async updateBcfProject(id: number, PatchedBcfProjectRequest?: PatchedBcfProjectRequest, initOverrides?: RequestInit): Promise<BcfProject> {
        const response = await this.updateBcfProjectRaw({ id: id, PatchedBcfProjectRequest: PatchedBcfProjectRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Update some fields of a comment  Required scopes: bcf:write
     * Update some fields of a comment
     */
    async updateCommentRaw(requestParameters: UpdateCommentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updateComment.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling updateComment.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling updateComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedCommentRequestToJSON(requestParameters.PatchedCommentRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Update some fields of a comment  Required scopes: bcf:write
     * Update some fields of a comment
     */
    async updateComment(guid: string, projects_pk: number, topics_guid: string, PatchedCommentRequest?: PatchedCommentRequest, initOverrides?: RequestInit): Promise<Comment> {
        const response = await this.updateCommentRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid, PatchedCommentRequest: PatchedCommentRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Update a Label. All topics using this label will be updated  Required scopes: bcf:write
     * Update a Label
     */
    async updateExtensionLabelRaw(requestParameters: UpdateExtensionLabelRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Label>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateExtensionLabel.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling updateExtensionLabel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/label/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedLabelRequestToJSON(requestParameters.PatchedLabelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LabelFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update a Label. All topics using this label will be updated  Required scopes: bcf:write
     * Update a Label
     */
    async updateExtensionLabel(id: number, projects_pk: number, PatchedLabelRequest?: PatchedLabelRequest, initOverrides?: RequestInit): Promise<Label> {
        const response = await this.updateExtensionLabelRaw({ id: id, projects_pk: projects_pk, PatchedLabelRequest: PatchedLabelRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Update a Priority. All topics using this priority will be updated  Required scopes: bcf:write
     * Update a Priority
     */
    async updateExtensionPriorityRaw(requestParameters: UpdateExtensionPriorityRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Priority>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateExtensionPriority.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling updateExtensionPriority.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/priority/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPriorityRequestToJSON(requestParameters.PatchedPriorityRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PriorityFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update a Priority. All topics using this priority will be updated  Required scopes: bcf:write
     * Update a Priority
     */
    async updateExtensionPriority(id: number, projects_pk: number, PatchedPriorityRequest?: PatchedPriorityRequest, initOverrides?: RequestInit): Promise<Priority> {
        const response = await this.updateExtensionPriorityRaw({ id: id, projects_pk: projects_pk, PatchedPriorityRequest: PatchedPriorityRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Update a Stage. All topics using this stage will be updated  Required scopes: bcf:write
     * Update a Stage
     */
    async updateExtensionStageRaw(requestParameters: UpdateExtensionStageRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Stage>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateExtensionStage.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling updateExtensionStage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/stage/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedStageRequestToJSON(requestParameters.PatchedStageRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StageFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update a Stage. All topics using this stage will be updated  Required scopes: bcf:write
     * Update a Stage
     */
    async updateExtensionStage(id: number, projects_pk: number, PatchedStageRequest?: PatchedStageRequest, initOverrides?: RequestInit): Promise<Stage> {
        const response = await this.updateExtensionStageRaw({ id: id, projects_pk: projects_pk, PatchedStageRequest: PatchedStageRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Update a TopicStatus. All topics using this status will be updated  Required scopes: bcf:write
     * Update a TopicStatus
     */
    async updateExtensionStatusRaw(requestParameters: UpdateExtensionStatusRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TopicStatus>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateExtensionStatus.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling updateExtensionStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/status/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedTopicStatusRequestToJSON(requestParameters.PatchedTopicStatusRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicStatusFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update a TopicStatus. All topics using this status will be updated  Required scopes: bcf:write
     * Update a TopicStatus
     */
    async updateExtensionStatus(id: number, projects_pk: number, PatchedTopicStatusRequest?: PatchedTopicStatusRequest, initOverrides?: RequestInit): Promise<TopicStatus> {
        const response = await this.updateExtensionStatusRaw({ id: id, projects_pk: projects_pk, PatchedTopicStatusRequest: PatchedTopicStatusRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Update a TopicType. All topics using this type will be updated  Required scopes: bcf:write
     * Update a TopicType
     */
    async updateExtensionTypeRaw(requestParameters: UpdateExtensionTypeRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<TopicType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateExtensionType.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling updateExtensionType.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/extension/type/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedTopicTypeRequestToJSON(requestParameters.PatchedTopicTypeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicTypeFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update a TopicType. All topics using this type will be updated  Required scopes: bcf:write
     * Update a TopicType
     */
    async updateExtensionType(id: number, projects_pk: number, PatchedTopicTypeRequest?: PatchedTopicTypeRequest, initOverrides?: RequestInit): Promise<TopicType> {
        const response = await this.updateExtensionTypeRaw({ id: id, projects_pk: projects_pk, PatchedTopicTypeRequest: PatchedTopicTypeRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. You can update topic, viewpoints and comment is a signle call  Required scopes: bcf:write
     * Update some fields of a topic
     */
    async updateFullTopicRaw(requestParameters: UpdateFullTopicRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FullTopic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updateFullTopic.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling updateFullTopic.');
        }

        const queryParameters: any = {};

        if (requestParameters.img_format !== undefined) {
            queryParameters['img_format'] = requestParameters.img_format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/full-topic/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedFullTopicRequestToJSON(requestParameters.PatchedFullTopicRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTopicFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. You can update topic, viewpoints and comment is a signle call  Required scopes: bcf:write
     * Update some fields of a topic
     */
    async updateFullTopic(guid: string, projects_pk: number, img_format?: UpdateFullTopicImgFormatEnum, PatchedFullTopicRequest?: PatchedFullTopicRequest, initOverrides?: RequestInit): Promise<FullTopic> {
        const response = await this.updateFullTopicRaw({ guid: guid, projects_pk: projects_pk, img_format: img_format, PatchedFullTopicRequest: PatchedFullTopicRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Update some fields of a Pin  Required scopes: bcf:write
     * Update some fields of a Pin
     */
    async updatePinRaw(requestParameters: UpdatePinRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Pin>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updatePin.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling updatePin.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling updatePin.');
        }

        if (requestParameters.viewpoints_guid === null || requestParameters.viewpoints_guid === undefined) {
            throw new runtime.RequiredError('viewpoints_guid','Required parameter requestParameters.viewpoints_guid was null or undefined when calling updatePin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{viewpoints_guid}/pin/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))).replace(`{${"viewpoints_guid"}}`, encodeURIComponent(String(requestParameters.viewpoints_guid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPinRequestToJSON(requestParameters.PatchedPinRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PinFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update some fields of a Pin  Required scopes: bcf:write
     * Update some fields of a Pin
     */
    async updatePin(guid: string, projects_pk: number, topics_guid: string, viewpoints_guid: string, PatchedPinRequest?: PatchedPinRequest, initOverrides?: RequestInit): Promise<Pin> {
        const response = await this.updatePinRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid, viewpoints_guid: viewpoints_guid, PatchedPinRequest: PatchedPinRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Update some fields of a topic  Required scopes: bcf:write
     * Update some fields of a topic
     */
    async updateTopicRaw(requestParameters: UpdateTopicRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Topic>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updateTopic.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling updateTopic.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedTopicRequestToJSON(requestParameters.PatchedTopicRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopicFromJSON(jsonValue));
    }

    /**
     * Update some fields of a topic  Required scopes: bcf:write
     * Update some fields of a topic
     */
    async updateTopic(guid: string, projects_pk: number, PatchedTopicRequest?: PatchedTopicRequest, initOverrides?: RequestInit): Promise<Topic> {
        const response = await this.updateTopicRaw({ guid: guid, projects_pk: projects_pk, PatchedTopicRequest: PatchedTopicRequest }, initOverrides);
        return await response.value();
    }

    /**
     * This is not a standard route. Update some fields of a Viewpoint  Required scopes: bcf:write
     * Update some fields of a Viewpoint
     */
    async updateViewpointRaw(requestParameters: UpdateViewpointRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Viewpoint>> {
        if (requestParameters.guid === null || requestParameters.guid === undefined) {
            throw new runtime.RequiredError('guid','Required parameter requestParameters.guid was null or undefined when calling updateViewpoint.');
        }

        if (requestParameters.projects_pk === null || requestParameters.projects_pk === undefined) {
            throw new runtime.RequiredError('projects_pk','Required parameter requestParameters.projects_pk was null or undefined when calling updateViewpoint.');
        }

        if (requestParameters.topics_guid === null || requestParameters.topics_guid === undefined) {
            throw new runtime.RequiredError('topics_guid','Required parameter requestParameters.topics_guid was null or undefined when calling updateViewpoint.');
        }

        const queryParameters: any = {};

        if (requestParameters.img_format !== undefined) {
            queryParameters['img_format'] = requestParameters.img_format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("BIMData_Connect", []);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}`.replace(`{${"guid"}}`, encodeURIComponent(String(requestParameters.guid))).replace(`{${"projects_pk"}}`, encodeURIComponent(String(requestParameters.projects_pk))).replace(`{${"topics_guid"}}`, encodeURIComponent(String(requestParameters.topics_guid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedViewpointRequestToJSON(requestParameters.PatchedViewpointRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewpointFromJSON(jsonValue));
    }

    /**
     * This is not a standard route. Update some fields of a Viewpoint  Required scopes: bcf:write
     * Update some fields of a Viewpoint
     */
    async updateViewpoint(guid: string, projects_pk: number, topics_guid: string, img_format?: UpdateViewpointImgFormatEnum, PatchedViewpointRequest?: PatchedViewpointRequest, initOverrides?: RequestInit): Promise<Viewpoint> {
        const response = await this.updateViewpointRaw({ guid: guid, projects_pk: projects_pk, topics_guid: topics_guid, img_format: img_format, PatchedViewpointRequest: PatchedViewpointRequest }, initOverrides);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum CreateFullTopicImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateViewpointImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum DeleteViewpointImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum DownloadBcfExportXlsxLocaleEnum {
    En = 'en',
    Fr = 'fr'
}
/**
    * @export
    * @enum {string}
    */
export enum FullUpdateFullTopicImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetFullTopicImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetFullTopicsImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetTopicViewpointsImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetViewpointImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum GetViewpointsImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateFullTopicImgFormatEnum {
    Url = 'url'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateViewpointImgFormatEnum {
    Url = 'url'
}
