/* tslint:disable */
/* eslint-disable */
/**
 * BIMData API
 * BIMData API is a tool to interact with your models stored on BIMDataâ€™s servers.     Through the API, you can manage your projects, the clouds, upload your IFC files and manage them through endpoints.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@bimdata.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Classification,
    ClassificationFromJSON,
    ClassificationToJSON,
    CreateBuilding,
    CreateBuildingFromJSON,
    CreateBuildingToJSON,
    CreateModel,
    CreateModelFromJSON,
    CreateModelToJSON,
    Document,
    DocumentFromJSON,
    DocumentToJSON,
    DocumentWithElementList,
    DocumentWithElementListFromJSON,
    DocumentWithElementListToJSON,
    Element,
    ElementFromJSON,
    ElementToJSON,
    ElementClassificationRelation,
    ElementClassificationRelationFromJSON,
    ElementClassificationRelationToJSON,
    ElementPropertySetRelation,
    ElementPropertySetRelationFromJSON,
    ElementPropertySetRelationToJSON,
    IfcAccessToken,
    IfcAccessTokenFromJSON,
    IfcAccessTokenToJSON,
    IfcExport,
    IfcExportFromJSON,
    IfcExportToJSON,
    IfcMerge,
    IfcMergeFromJSON,
    IfcMergeToJSON,
    IfcOptimize,
    IfcOptimizeFromJSON,
    IfcOptimizeToJSON,
    InlineObject5,
    InlineObject5FromJSON,
    InlineObject5ToJSON,
    Layer,
    LayerFromJSON,
    LayerToJSON,
    Material,
    MaterialFromJSON,
    MaterialToJSON,
    Model,
    ModelFromJSON,
    ModelToJSON,
    ModelErrors,
    ModelErrorsFromJSON,
    ModelErrorsToJSON,
    ModelFiles,
    ModelFilesFromJSON,
    ModelFilesToJSON,
    PositioningPlan,
    PositioningPlanFromJSON,
    PositioningPlanToJSON,
    ProcessorHandler,
    ProcessorHandlerFromJSON,
    ProcessorHandlerToJSON,
    Property,
    PropertyFromJSON,
    PropertyToJSON,
    PropertyDefinition,
    PropertyDefinitionFromJSON,
    PropertyDefinitionToJSON,
    PropertySet,
    PropertySetFromJSON,
    PropertySetToJSON,
    RawElements,
    RawElementsFromJSON,
    RawElementsToJSON,
    SimpleElement,
    SimpleElementFromJSON,
    SimpleElementToJSON,
    Space,
    SpaceFromJSON,
    SpaceToJSON,
    Storey,
    StoreyFromJSON,
    StoreyToJSON,
    StoreyRequest,
    StoreyRequestFromJSON,
    StoreyRequestToJSON,
    System,
    SystemFromJSON,
    SystemToJSON,
    Unit,
    UnitFromJSON,
    UnitToJSON,
    Zone,
    ZoneFromJSON,
    ZoneToJSON,
    ZoneSpace,
    ZoneSpaceFromJSON,
    ZoneSpaceToJSON,
} from '../models';

export interface AddModelErrorsRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    data: ModelErrors;
}

export interface BulkDeleteModelClassificationsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface BulkDeleteModelPropertiesRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<number>;
}

export interface BulkDeleteModelPropertyDefinitionsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<number>;
}

export interface BulkDeleteModelUnitsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<number>;
}

export interface BulkDeletePropertySetRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<number>;
}

export interface BulkFullUpdateElementsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<Element>;
}

export interface BulkFullUpdateModelPropertyRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<Property>;
}

export interface BulkRemoveClassificationsOfElementRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
    data: Array<number>;
}

export interface BulkRemoveDocumentsOfElementRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
    data: Array<number>;
}

export interface BulkRemoveElementsFromClassificationRequest {
    cloudPk: string;
    modelClassificationPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<number>;
}

export interface BulkUpdateElementsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<Element>;
}

export interface BulkUpdateModelPropertyRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<Property>;
}

export interface CreateAccessTokenRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: IfcAccessToken;
}

export interface CreateClassificationElementRelationsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<ElementClassificationRelation>;
}

export interface CreateClassificationsOfElementRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
    data: Array<Classification>;
}

export interface CreateElementRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<Element>;
}

export interface CreateElementPropertySetRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
    data: PropertySet;
}

export interface CreateElementPropertySetPropertyRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
    propertysetPk: string;
    data: Property;
}

export interface CreateElementPropertySetPropertyDefinitionRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
    propertyPk: string;
    propertysetPk: string;
    data: PropertyDefinition;
}

export interface CreateElementPropertySetPropertyDefinitionUnitRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
    propertyPk: string;
    propertydefinitionPk: string;
    propertysetPk: string;
    data: Unit;
}

export interface CreateLayerRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Layer;
}

export interface CreateMetaBuildingRequest {
    cloudPk: string;
    projectPk: string;
    data: CreateBuilding;
}

export interface CreateModelRequest {
    cloudPk: string;
    projectPk: string;
    data: CreateModel;
}

export interface CreateModelPropertyDefinitionRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<PropertyDefinition>;
}

export interface CreateModelUnitRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<Unit>;
}

export interface CreatePropertySetRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<PropertySet>;
}

export interface CreatePropertySetElementRelationsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<ElementPropertySetRelation>;
}

export interface CreateRawElementsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: RawElements;
}

export interface CreateSpaceRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<Space>;
}

export interface CreateStoreyPlanRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    storeyPk: string;
    data: InlineObject5;
}

export interface CreateSystemRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: System;
}

export interface CreateZoneRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<Zone>;
}

export interface CreateZoneSpaceRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    zonePk: string;
    data: ZoneSpace;
}

export interface DeleteAccessTokenRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    token: string;
}

export interface DeleteElementRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    uuid: string;
}

export interface DeleteLayerRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface DeleteModelRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface DeleteModelPropertyRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface DeleteModelPropertyDefinitionRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface DeleteModelUnitRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface DeleteModelWithoutDocRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface DeletePropertySetRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface DeleteSpaceRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface DeleteStoreyRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface DeleteStoreyPlanRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    storeyPk: string;
}

export interface DeleteSystemRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    uuid: string;
}

export interface DeleteZoneRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface DeleteZoneSpaceRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    zonePk: string;
}

export interface ExportIfcRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    data: IfcExport;
}

export interface FullUpdateElementRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    uuid: string;
    data: Element;
}

export interface FullUpdateStoreysRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    data: Array<StoreyRequest>;
}

export interface GetAccessTokenRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    token: string;
}

export interface GetAccessTokensRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetClassificationsOfElementRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
}

export interface GetDocumentsOfElementRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
}

export interface GetElementRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    uuid: string;
}

export interface GetElementLinkedDocumentsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    type?: string;
    classification?: string;
    classificationNotation?: string;
}

export interface GetElementPropertySetRequest {
    cloudPk: string;
    elementUuid: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface GetElementPropertySetPropertiesRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
    propertysetPk: string;
}

export interface GetElementPropertySetPropertyRequest {
    cloudPk: string;
    elementUuid: string;
    id: number;
    modelPk: string;
    projectPk: string;
    propertysetPk: string;
}

export interface GetElementPropertySetPropertyDefinitionRequest {
    cloudPk: string;
    elementUuid: string;
    id: number;
    modelPk: string;
    projectPk: string;
    propertyPk: string;
    propertysetPk: string;
}

export interface GetElementPropertySetPropertyDefinitionUnitRequest {
    cloudPk: string;
    elementUuid: string;
    id: number;
    modelPk: string;
    projectPk: string;
    propertyPk: string;
    propertydefinitionPk: string;
    propertysetPk: string;
}

export interface GetElementPropertySetPropertyDefinitionUnitsRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
    propertyPk: string;
    propertydefinitionPk: string;
    propertysetPk: string;
}

export interface GetElementPropertySetPropertyDefinitionsRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
    propertyPk: string;
    propertysetPk: string;
}

export interface GetElementPropertySetsRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
}

export interface GetElementsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    type?: string;
    classification?: string;
    classificationNotation?: string;
}

export interface GetElementsFromClassificationRequest {
    cloudPk: string;
    modelClassificationPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetLayerRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface GetLayersRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetMaterialRequest {
    cloudPk: string;
    elementUuid: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface GetMaterialsRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
}

export interface GetModelRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface GetModelClassificationsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetModelMaterialRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface GetModelMaterialsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetModelPropertiesRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetModelPropertyRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface GetModelPropertyDefinitionRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface GetModelPropertyDefinitionsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetModelUnitRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface GetModelUnitsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetModelsRequest {
    cloudPk: string;
    projectPk: string;
    status?: string;
    source?: string;
    type?: string;
}

export interface GetPlanPositioningRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    storeyPk: string;
}

export interface GetProcessorHandlerRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface GetProcessorHandlersRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetPropertySetRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface GetPropertySetsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetRawElementsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    type?: string;
    classification?: string;
    classificationNotation?: string;
}

export interface GetSimpleElementRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    uuid: string;
}

export interface GetSimpleElementsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    type?: string;
    classification?: string;
    classificationNotation?: string;
}

export interface GetSpaceRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface GetSpacesRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetStoreyRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface GetStoreysRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetSystemRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    uuid: string;
}

export interface GetSystemsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface GetZoneRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface GetZoneSpaceRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    zonePk: string;
}

export interface GetZoneSpacesRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    zonePk: string;
}

export interface GetZonesRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    color?: string;
}

export interface LinkDocumentsOfElementRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
    data: Array<number>;
}

export interface ListClassificationElementRelationsRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
}

export interface MergeIfcsRequest {
    cloudPk: string;
    projectPk: string;
    data: IfcMerge;
}

export interface OptimizeIfcRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    data: IfcOptimize;
}

export interface RemoveAllElementPropertySetRequest {
    cloudPk: string;
    elementUuid: string;
    modelPk: string;
    projectPk: string;
}

export interface RemoveClassificationOfElementRequest {
    cloudPk: string;
    elementUuid: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface RemoveDocumentOfElementRequest {
    cloudPk: string;
    elementUuid: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface RemoveElementPropertySetRequest {
    cloudPk: string;
    elementUuid: string;
    id: number;
    modelPk: string;
    projectPk: string;
}

export interface RemoveElementPropertySetPropertyRequest {
    cloudPk: string;
    elementUuid: string;
    id: number;
    modelPk: string;
    projectPk: string;
    propertysetPk: string;
}

export interface RemoveElementPropertySetPropertyDefinitionRequest {
    cloudPk: string;
    elementUuid: string;
    id: number;
    modelPk: string;
    projectPk: string;
    propertyPk: string;
    propertysetPk: string;
}

export interface RemoveElementPropertySetPropertyDefinitionUnitRequest {
    cloudPk: string;
    elementUuid: string;
    id: number;
    modelPk: string;
    projectPk: string;
    propertyPk: string;
    propertydefinitionPk: string;
    propertysetPk: string;
}

export interface RemoveElementsFromClassificationRequest {
    cloudPk: string;
    modelClassificationPk: string;
    modelPk: string;
    projectPk: string;
    uuid: string;
}

export interface ReprocessModelRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
}

export interface UpdateAccessTokenRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    token: string;
    data: IfcAccessToken;
}

export interface UpdateElementRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    uuid: string;
    data: Element;
}

export interface UpdateElementPropertySetPropertyRequest {
    cloudPk: string;
    elementUuid: string;
    id: number;
    modelPk: string;
    projectPk: string;
    propertysetPk: string;
    data: Property;
}

export interface UpdateLayerRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    data: Layer;
}

export interface UpdateModelRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    data: Model;
}

export interface UpdateModelFilesRequest {
    cloudPk: string;
    id: number;
    projectPk: string;
    structureFile?: Blob | null;
    systemsFile?: Blob | null;
    mapFile?: Blob | null;
    gltfFile?: Blob | null;
    gltfWithOpeningsFile?: Blob | null;
    bvhTreeFile?: Blob | null;
    viewer360File?: Blob | null;
    xktFile?: Blob | null;
}

export interface UpdateModelPropertyRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    data: Property;
}

export interface UpdateModelPropertyDefinitionRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    data: PropertyDefinition;
}

export interface UpdateModelUnitRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    data: Unit;
}

export interface UpdatePlanPositioningRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    storeyPk: string;
    data: PositioningPlan;
}

export interface UpdateProcessorHandlerRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    data: ProcessorHandler;
}

export interface UpdatePropertySetRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    data: PropertySet;
}

export interface UpdateSpaceRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    data: Space;
}

export interface UpdateStoreyRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    data: Storey;
}

export interface UpdateSystemRequest {
    cloudPk: string;
    modelPk: string;
    projectPk: string;
    uuid: string;
    data: System;
}

export interface UpdateZoneRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    data: Zone;
}

export interface UpdateZoneSpaceRequest {
    cloudPk: string;
    id: number;
    modelPk: string;
    projectPk: string;
    zonePk: string;
    data: ZoneSpace;
}

/**
 * 
 */
export class ModelApi extends runtime.BaseAPI {

    /**
     * Model errors are warnings and errors during model process. They alert about missing elements or malformed files Required scopes: ifc:write, model:write
     * Add errors to model
     */
    async addModelErrorsRaw(requestParameters: AddModelErrorsRequest): Promise<runtime.ApiResponse<ModelErrors>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling addModelErrors.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling addModelErrors.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling addModelErrors.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling addModelErrors.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}/errors`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModelErrorsToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelErrorsFromJSON(jsonValue));
    }

    /**
     * Model errors are warnings and errors during model process. They alert about missing elements or malformed files Required scopes: ifc:write, model:write
     * Add errors to model
     */
    async addModelErrors(requestParameters: AddModelErrorsRequest): Promise<ModelErrors> {
        const response = await this.addModelErrorsRaw(requestParameters);
        return await response.value();
    }

    /**
     *              Delete relation between filtered classifications (eg. /classifications?name=untec) and all mode\'s elements.             No classification will be deleted on this endpoint, only the relation between model\'s elements and their classification.  Required scopes: ifc:write, model:write
     * Remove all classifications from model\'s elements
     */
    async bulkDeleteModelClassificationsRaw(requestParameters: BulkDeleteModelClassificationsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkDeleteModelClassifications.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkDeleteModelClassifications.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkDeleteModelClassifications.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification/list_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *              Delete relation between filtered classifications (eg. /classifications?name=untec) and all mode\'s elements.             No classification will be deleted on this endpoint, only the relation between model\'s elements and their classification.  Required scopes: ifc:write, model:write
     * Remove all classifications from model\'s elements
     */
    async bulkDeleteModelClassifications(requestParameters: BulkDeleteModelClassificationsRequest): Promise<void> {
        await this.bulkDeleteModelClassificationsRaw(requestParameters);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Delete many Property of a model
     */
    async bulkDeleteModelPropertiesRaw(requestParameters: BulkDeleteModelPropertiesRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkDeleteModelProperties.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkDeleteModelProperties.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkDeleteModelProperties.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling bulkDeleteModelProperties.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Delete many Property of a model
     */
    async bulkDeleteModelProperties(requestParameters: BulkDeleteModelPropertiesRequest): Promise<void> {
        await this.bulkDeleteModelPropertiesRaw(requestParameters);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Delete many PropertyDefinitions of a model
     */
    async bulkDeleteModelPropertyDefinitionsRaw(requestParameters: BulkDeleteModelPropertyDefinitionsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkDeleteModelPropertyDefinitions.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkDeleteModelPropertyDefinitions.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkDeleteModelPropertyDefinitions.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling bulkDeleteModelPropertyDefinitions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertydefinition/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Delete many PropertyDefinitions of a model
     */
    async bulkDeleteModelPropertyDefinitions(requestParameters: BulkDeleteModelPropertyDefinitionsRequest): Promise<void> {
        await this.bulkDeleteModelPropertyDefinitionsRaw(requestParameters);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Delete many Units of a model
     */
    async bulkDeleteModelUnitsRaw(requestParameters: BulkDeleteModelUnitsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkDeleteModelUnits.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkDeleteModelUnits.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkDeleteModelUnits.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling bulkDeleteModelUnits.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/unit/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Delete many Units of a model
     */
    async bulkDeleteModelUnits(requestParameters: BulkDeleteModelUnitsRequest): Promise<void> {
        await this.bulkDeleteModelUnitsRaw(requestParameters);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Delete many PropertySet of a model
     */
    async bulkDeletePropertySetRaw(requestParameters: BulkDeletePropertySetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkDeletePropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkDeletePropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkDeletePropertySet.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling bulkDeletePropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Delete many PropertySet of a model
     */
    async bulkDeletePropertySet(requestParameters: BulkDeletePropertySetRequest): Promise<void> {
        await this.bulkDeletePropertySetRaw(requestParameters);
    }

    /**
     *          Bulk update.         Similar to update, but the body should be a list of objects to patch or put         The response will be a list (in the same order) of updated objects or of errors if any         If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Update many elements at once (only changing fields may be defined)
     */
    async bulkFullUpdateElementsRaw(requestParameters: BulkFullUpdateElementsRequest): Promise<runtime.ApiResponse<Array<Element>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkFullUpdateElements.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkFullUpdateElements.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkFullUpdateElements.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling bulkFullUpdateElements.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/bulk_update`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(ElementToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ElementFromJSON));
    }

    /**
     *          Bulk update.         Similar to update, but the body should be a list of objects to patch or put         The response will be a list (in the same order) of updated objects or of errors if any         If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Update many elements at once (only changing fields may be defined)
     */
    async bulkFullUpdateElements(requestParameters: BulkFullUpdateElementsRequest): Promise<Array<Element>> {
        const response = await this.bulkFullUpdateElementsRaw(requestParameters);
        return await response.value();
    }

    /**
     *          Bulk update.         Similar to update, but the body should be a list of objects to patch or put         The response will be a list (in the same order) of updated objects or of errors if any         If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Update some fields of many properties of a model
     */
    async bulkFullUpdateModelPropertyRaw(requestParameters: BulkFullUpdateModelPropertyRequest): Promise<runtime.ApiResponse<Array<Property>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkFullUpdateModelProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkFullUpdateModelProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkFullUpdateModelProperty.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling bulkFullUpdateModelProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property/bulk_update`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(PropertyToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyFromJSON));
    }

    /**
     *          Bulk update.         Similar to update, but the body should be a list of objects to patch or put         The response will be a list (in the same order) of updated objects or of errors if any         If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Update some fields of many properties of a model
     */
    async bulkFullUpdateModelProperty(requestParameters: BulkFullUpdateModelPropertyRequest): Promise<Array<Property>> {
        const response = await this.bulkFullUpdateModelPropertyRaw(requestParameters);
        return await response.value();
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Remove many classifications from an element
     */
    async bulkRemoveClassificationsOfElementRaw(requestParameters: BulkRemoveClassificationsOfElementRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkRemoveClassificationsOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling bulkRemoveClassificationsOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkRemoveClassificationsOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkRemoveClassificationsOfElement.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling bulkRemoveClassificationsOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/classification/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Remove many classifications from an element
     */
    async bulkRemoveClassificationsOfElement(requestParameters: BulkRemoveClassificationsOfElementRequest): Promise<void> {
        await this.bulkRemoveClassificationsOfElementRaw(requestParameters);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Remove many documents from an element
     */
    async bulkRemoveDocumentsOfElementRaw(requestParameters: BulkRemoveDocumentsOfElementRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkRemoveDocumentsOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling bulkRemoveDocumentsOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkRemoveDocumentsOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkRemoveDocumentsOfElement.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling bulkRemoveDocumentsOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/documents/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Remove many documents from an element
     */
    async bulkRemoveDocumentsOfElement(requestParameters: BulkRemoveDocumentsOfElementRequest): Promise<void> {
        await this.bulkRemoveDocumentsOfElementRaw(requestParameters);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Remove the classifications from all elements
     */
    async bulkRemoveElementsFromClassificationRaw(requestParameters: BulkRemoveElementsFromClassificationRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkRemoveElementsFromClassification.');
        }

        if (requestParameters.modelClassificationPk === null || requestParameters.modelClassificationPk === undefined) {
            throw new runtime.RequiredError('modelClassificationPk','Required parameter requestParameters.modelClassificationPk was null or undefined when calling bulkRemoveElementsFromClassification.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkRemoveElementsFromClassification.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkRemoveElementsFromClassification.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling bulkRemoveElementsFromClassification.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification/{model_classification_pk}/element/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_classification_pk"}}`, encodeURIComponent(String(requestParameters.modelClassificationPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *          Bulk delete.         You must send a list of ids in the body.         These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted  Required scopes: ifc:write, model:write
     * Remove the classifications from all elements
     */
    async bulkRemoveElementsFromClassification(requestParameters: BulkRemoveElementsFromClassificationRequest): Promise<void> {
        await this.bulkRemoveElementsFromClassificationRaw(requestParameters);
    }

    /**
     *          Bulk update.         Similar to update, but the body should be a list of objects to patch or put         The response will be a list (in the same order) of updated objects or of errors if any         If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Update many elements at once (all field must be defined)
     */
    async bulkUpdateElementsRaw(requestParameters: BulkUpdateElementsRequest): Promise<runtime.ApiResponse<Array<Element>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkUpdateElements.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkUpdateElements.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkUpdateElements.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling bulkUpdateElements.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/bulk_update`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(ElementToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ElementFromJSON));
    }

    /**
     *          Bulk update.         Similar to update, but the body should be a list of objects to patch or put         The response will be a list (in the same order) of updated objects or of errors if any         If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Update many elements at once (all field must be defined)
     */
    async bulkUpdateElements(requestParameters: BulkUpdateElementsRequest): Promise<Array<Element>> {
        const response = await this.bulkUpdateElementsRaw(requestParameters);
        return await response.value();
    }

    /**
     *  Bulk update. Similar to update, but the body should be a list of objects to patch or put The response will be a list (in the same order) of updated objects or of errors if any If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors 
     * Update all fields of many properties of a model
     */
    async bulkUpdateModelPropertyRaw(requestParameters: BulkUpdateModelPropertyRequest): Promise<runtime.ApiResponse<Array<Property>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkUpdateModelProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkUpdateModelProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkUpdateModelProperty.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling bulkUpdateModelProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property/bulk_update`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(PropertyToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyFromJSON));
    }

    /**
     *  Bulk update. Similar to update, but the body should be a list of objects to patch or put The response will be a list (in the same order) of updated objects or of errors if any If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors 
     * Update all fields of many properties of a model
     */
    async bulkUpdateModelProperty(requestParameters: BulkUpdateModelPropertyRequest): Promise<Array<Property>> {
        const response = await this.bulkUpdateModelPropertyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Tokens are read_only by default and are valid 1 day Required scopes: ifc:token_manage, model:token_manage
     * Create a token for this model
     */
    async createAccessTokenRaw(requestParameters: CreateAccessTokenRequest): Promise<runtime.ApiResponse<IfcAccessToken>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createAccessToken.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createAccessToken.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/access_token`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IfcAccessTokenToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IfcAccessTokenFromJSON(jsonValue));
    }

    /**
     * Tokens are read_only by default and are valid 1 day Required scopes: ifc:token_manage, model:token_manage
     * Create a token for this model
     */
    async createAccessToken(requestParameters: CreateAccessTokenRequest): Promise<IfcAccessToken> {
        const response = await this.createAccessTokenRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create association between existing classification and existing element Required scopes: ifc:write, model:write
     * Create association between existing classification and existing element
     */
    async createClassificationElementRelationsRaw(requestParameters: CreateClassificationElementRelationsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createClassificationElementRelations.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createClassificationElementRelations.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createClassificationElementRelations.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createClassificationElementRelations.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification-element`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(ElementClassificationRelationToJSON),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create association between existing classification and existing element Required scopes: ifc:write, model:write
     * Create association between existing classification and existing element
     */
    async createClassificationElementRelations(requestParameters: CreateClassificationElementRelationsRequest): Promise<void> {
        await this.createClassificationElementRelationsRaw(requestParameters);
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors      If classification created already exists, it will just be added to item\'s classifications and will not be duplicated  Required scopes: ifc:write, model:write
     * Create one or many classifications to an element
     */
    async createClassificationsOfElementRaw(requestParameters: CreateClassificationsOfElementRequest): Promise<runtime.ApiResponse<Array<Classification>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createClassificationsOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling createClassificationsOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createClassificationsOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createClassificationsOfElement.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createClassificationsOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/classification`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(ClassificationToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClassificationFromJSON));
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors      If classification created already exists, it will just be added to item\'s classifications and will not be duplicated  Required scopes: ifc:write, model:write
     * Create one or many classifications to an element
     */
    async createClassificationsOfElement(requestParameters: CreateClassificationsOfElementRequest): Promise<Array<Classification>> {
        const response = await this.createClassificationsOfElementRaw(requestParameters);
        return await response.value();
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Create an element in the model
     */
    async createElementRaw(requestParameters: CreateElementRequest): Promise<runtime.ApiResponse<Array<Element>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createElement.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(ElementToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ElementFromJSON));
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Create an element in the model
     */
    async createElement(requestParameters: CreateElementRequest): Promise<Array<Element>> {
        const response = await this.createElementRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a PropertySets that will be automatically linked to the element Required scopes: ifc:write, model:write
     * Create a PropertySets to an element
     */
    async createElementPropertySetRaw(requestParameters: CreateElementPropertySetRequest): Promise<runtime.ApiResponse<PropertySet>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createElementPropertySet.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling createElementPropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createElementPropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createElementPropertySet.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createElementPropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PropertySetToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertySetFromJSON(jsonValue));
    }

    /**
     * Create a PropertySets that will be automatically linked to the element Required scopes: ifc:write, model:write
     * Create a PropertySets to an element
     */
    async createElementPropertySet(requestParameters: CreateElementPropertySetRequest): Promise<PropertySet> {
        const response = await this.createElementPropertySetRaw(requestParameters);
        return await response.value();
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Create a property to a PropertySet
     */
    async createElementPropertySetPropertyRaw(requestParameters: CreateElementPropertySetPropertyRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createElementPropertySetProperty.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling createElementPropertySetProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createElementPropertySetProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createElementPropertySetProperty.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling createElementPropertySetProperty.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createElementPropertySetProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Create a property to a PropertySet
     */
    async createElementPropertySetProperty(requestParameters: CreateElementPropertySetPropertyRequest): Promise<Property> {
        const response = await this.createElementPropertySetPropertyRaw(requestParameters);
        return await response.value();
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Create a Definition to a Property
     */
    async createElementPropertySetPropertyDefinitionRaw(requestParameters: CreateElementPropertySetPropertyDefinitionRequest): Promise<runtime.ApiResponse<PropertyDefinition>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyDefinitionToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyDefinitionFromJSON(jsonValue));
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Create a Definition to a Property
     */
    async createElementPropertySetPropertyDefinition(requestParameters: CreateElementPropertySetPropertyDefinitionRequest): Promise<PropertyDefinition> {
        const response = await this.createElementPropertySetPropertyDefinitionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a Unit to a Definition Required scopes: ifc:write, model:write
     * Create a Unit to a Definition
     */
    async createElementPropertySetPropertyDefinitionUnitRaw(requestParameters: CreateElementPropertySetPropertyDefinitionUnitRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertydefinitionPk === null || requestParameters.propertydefinitionPk === undefined) {
            throw new runtime.RequiredError('propertydefinitionPk','Required parameter requestParameters.propertydefinitionPk was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition/{propertydefinition_pk}/unit`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertydefinition_pk"}}`, encodeURIComponent(String(requestParameters.propertydefinitionPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UnitToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     * Create a Unit to a Definition Required scopes: ifc:write, model:write
     * Create a Unit to a Definition
     */
    async createElementPropertySetPropertyDefinitionUnit(requestParameters: CreateElementPropertySetPropertyDefinitionUnitRequest): Promise<Unit> {
        const response = await this.createElementPropertySetPropertyDefinitionUnitRaw(requestParameters);
        return await response.value();
    }

    /**
     * The IFC file will not be updated. The created layer will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Create a layer in the model
     */
    async createLayerRaw(requestParameters: CreateLayerRequest): Promise<runtime.ApiResponse<Layer>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createLayer.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createLayer.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createLayer.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createLayer.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/layer`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LayerToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LayerFromJSON(jsonValue));
    }

    /**
     * The IFC file will not be updated. The created layer will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Create a layer in the model
     */
    async createLayer(requestParameters: CreateLayerRequest): Promise<Layer> {
        const response = await this.createLayerRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create an empty 3D Model to be used in BIMData services Required scopes: ifc:write, model:write
     * Create an empty 3D Model
     */
    async createMetaBuildingRaw(requestParameters: CreateMetaBuildingRequest): Promise<runtime.ApiResponse<Model>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createMetaBuilding.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createMetaBuilding.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createMetaBuilding.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/create-metabuilding`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateBuildingToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
    }

    /**
     * Create an empty 3D Model to be used in BIMData services Required scopes: ifc:write, model:write
     * Create an empty 3D Model
     */
    async createMetaBuilding(requestParameters: CreateMetaBuildingRequest): Promise<Model> {
        const response = await this.createMetaBuildingRaw(requestParameters);
        return await response.value();
    }

    /**
     * Make a PDF or Image file a Model to be used in BIMData services. If a model already exists, this route does nothing and returns a 201 with the model Required scopes: ifc:write, model:write
     * Make a PDF or Image file a Model
     */
    async createModelRaw(requestParameters: CreateModelRequest): Promise<runtime.ApiResponse<Model>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createModel.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createModel.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createModel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/create-model`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateModelToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
    }

    /**
     * Make a PDF or Image file a Model to be used in BIMData services. If a model already exists, this route does nothing and returns a 201 with the model Required scopes: ifc:write, model:write
     * Make a PDF or Image file a Model
     */
    async createModel(requestParameters: CreateModelRequest): Promise<Model> {
        const response = await this.createModelRaw(requestParameters);
        return await response.value();
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Create a PropertyDefinition on the model
     */
    async createModelPropertyDefinitionRaw(requestParameters: CreateModelPropertyDefinitionRequest): Promise<runtime.ApiResponse<Array<PropertyDefinition>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createModelPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createModelPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createModelPropertyDefinition.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createModelPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertydefinition`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(PropertyDefinitionToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyDefinitionFromJSON));
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Create a PropertyDefinition on the model
     */
    async createModelPropertyDefinition(requestParameters: CreateModelPropertyDefinitionRequest): Promise<Array<PropertyDefinition>> {
        const response = await this.createModelPropertyDefinitionRaw(requestParameters);
        return await response.value();
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Create a Unit on a model
     */
    async createModelUnitRaw(requestParameters: CreateModelUnitRequest): Promise<runtime.ApiResponse<Array<Unit>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createModelUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createModelUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createModelUnit.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createModelUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/unit`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(UnitToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UnitFromJSON));
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Create a Unit on a model
     */
    async createModelUnit(requestParameters: CreateModelUnitRequest): Promise<Array<Unit>> {
        const response = await this.createModelUnitRaw(requestParameters);
        return await response.value();
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Create a PropertySet
     */
    async createPropertySetRaw(requestParameters: CreatePropertySetRequest): Promise<runtime.ApiResponse<Array<PropertySet>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createPropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createPropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createPropertySet.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createPropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(PropertySetToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertySetFromJSON));
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Create a PropertySet
     */
    async createPropertySet(requestParameters: CreatePropertySetRequest): Promise<Array<PropertySet>> {
        const response = await this.createPropertySetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create association between existing PropertySet and existing element Required scopes: ifc:write, model:write
     * Create association between PropertySet and element
     */
    async createPropertySetElementRelationsRaw(requestParameters: CreatePropertySetElementRelationsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createPropertySetElementRelations.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createPropertySetElementRelations.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createPropertySetElementRelations.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createPropertySetElementRelations.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset-element`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(ElementPropertySetRelationToJSON),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create association between existing PropertySet and existing element Required scopes: ifc:write, model:write
     * Create association between PropertySet and element
     */
    async createPropertySetElementRelations(requestParameters: CreatePropertySetElementRelationsRequest): Promise<void> {
        await this.createPropertySetElementRelationsRaw(requestParameters);
    }

    /**
     *          You can use the same optimized structure to post multiple elements, property_sets, properties, definitions and units at once.         For performance reasons, we do not check the validity of the json. If the json is malformed, an error 500 without more explaination may be returned instead of a 400.  Required scopes: ifc:write, model:write
     * Create elements in an optimized format
     */
    async createRawElementsRaw(requestParameters: CreateRawElementsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createRawElements.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createRawElements.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createRawElements.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createRawElements.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/raw`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RawElementsToJSON(requestParameters.data),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *          You can use the same optimized structure to post multiple elements, property_sets, properties, definitions and units at once.         For performance reasons, we do not check the validity of the json. If the json is malformed, an error 500 without more explaination may be returned instead of a 400.  Required scopes: ifc:write, model:write
     * Create elements in an optimized format
     */
    async createRawElements(requestParameters: CreateRawElementsRequest): Promise<void> {
        await this.createRawElementsRaw(requestParameters);
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Create a space in the model
     */
    async createSpaceRaw(requestParameters: CreateSpaceRequest): Promise<runtime.ApiResponse<Array<Space>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createSpace.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/space`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(SpaceToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SpaceFromJSON));
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Create a space in the model
     */
    async createSpace(requestParameters: CreateSpaceRequest): Promise<Array<Space>> {
        const response = await this.createSpaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a relation between a 2d model and a storey. The model type must be one of : (\'DWG\', \'DXF\', \'PDF\', \'JPEG\', \'PNG\') Required scopes: ifc:write, model:write
     * Create a relation between a 2d model and a storey
     */
    async createStoreyPlanRaw(requestParameters: CreateStoreyPlanRequest): Promise<runtime.ApiResponse<Storey>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createStoreyPlan.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createStoreyPlan.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createStoreyPlan.');
        }

        if (requestParameters.storeyPk === null || requestParameters.storeyPk === undefined) {
            throw new runtime.RequiredError('storeyPk','Required parameter requestParameters.storeyPk was null or undefined when calling createStoreyPlan.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createStoreyPlan.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{storey_pk}/plan/add`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"storey_pk"}}`, encodeURIComponent(String(requestParameters.storeyPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObject5ToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreyFromJSON(jsonValue));
    }

    /**
     * Create a relation between a 2d model and a storey. The model type must be one of : (\'DWG\', \'DXF\', \'PDF\', \'JPEG\', \'PNG\') Required scopes: ifc:write, model:write
     * Create a relation between a 2d model and a storey
     */
    async createStoreyPlan(requestParameters: CreateStoreyPlanRequest): Promise<Storey> {
        const response = await this.createStoreyPlanRaw(requestParameters);
        return await response.value();
    }

    /**
     * The IFC file will not be updated. The created system will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Create a system in the model
     */
    async createSystemRaw(requestParameters: CreateSystemRequest): Promise<runtime.ApiResponse<System>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createSystem.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createSystem.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createSystem.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createSystem.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/system`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SystemToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SystemFromJSON(jsonValue));
    }

    /**
     * The IFC file will not be updated. The created system will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Create a system in the model
     */
    async createSystem(requestParameters: CreateSystemRequest): Promise<System> {
        const response = await this.createSystemRaw(requestParameters);
        return await response.value();
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  The IFC file will not be updated. The created zone will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Create a zone in the model
     */
    async createZoneRaw(requestParameters: CreateZoneRequest): Promise<runtime.ApiResponse<Array<Zone>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createZone.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createZone.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createZone.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createZone.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(ZoneToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ZoneFromJSON));
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  The IFC file will not be updated. The created zone will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Create a zone in the model
     */
    async createZone(requestParameters: CreateZoneRequest): Promise<Array<Zone>> {
        const response = await this.createZoneRaw(requestParameters);
        return await response.value();
    }

    /**
     * The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Create a space in a zone
     */
    async createZoneSpaceRaw(requestParameters: CreateZoneSpaceRequest): Promise<runtime.ApiResponse<ZoneSpace>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createZoneSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createZoneSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createZoneSpace.');
        }

        if (requestParameters.zonePk === null || requestParameters.zonePk === undefined) {
            throw new runtime.RequiredError('zonePk','Required parameter requestParameters.zonePk was null or undefined when calling createZoneSpace.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling createZoneSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{zone_pk}/space`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"zone_pk"}}`, encodeURIComponent(String(requestParameters.zonePk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ZoneSpaceToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ZoneSpaceFromJSON(jsonValue));
    }

    /**
     * The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Create a space in a zone
     */
    async createZoneSpace(requestParameters: CreateZoneSpaceRequest): Promise<ZoneSpace> {
        const response = await this.createZoneSpaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * Deleting a token will revoke it. Required scopes: ifc:token_manage, model:token_manage
     * Delete a token
     */
    async deleteAccessTokenRaw(requestParameters: DeleteAccessTokenRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteAccessToken.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteAccessToken.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling deleteAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/access_token/{token}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deleting a token will revoke it. Required scopes: ifc:token_manage, model:token_manage
     * Delete a token
     */
    async deleteAccessToken(requestParameters: DeleteAccessTokenRequest): Promise<void> {
        await this.deleteAccessTokenRaw(requestParameters);
    }

    /**
     * The IFC file will not be updated. The remaining elements are available in API and will be available when exporting an IFC file Required scopes: ifc:write, model:write
     * Delete an element of a model
     */
    async deleteElementRaw(requestParameters: DeleteElementRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteElement.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling deleteElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The IFC file will not be updated. The remaining elements are available in API and will be available when exporting an IFC file Required scopes: ifc:write, model:write
     * Delete an element of a model
     */
    async deleteElement(requestParameters: DeleteElementRequest): Promise<void> {
        await this.deleteElementRaw(requestParameters);
    }

    /**
     * The IFC file will not be updated. The remaining layers are available in API and will be available when exporting an IFC file Required scopes: ifc:write, model:write
     * Delete a layer of a model
     */
    async deleteLayerRaw(requestParameters: DeleteLayerRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteLayer.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteLayer.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteLayer.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteLayer.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/layer/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The IFC file will not be updated. The remaining layers are available in API and will be available when exporting an IFC file Required scopes: ifc:write, model:write
     * Delete a layer of a model
     */
    async deleteLayer(requestParameters: DeleteLayerRequest): Promise<void> {
        await this.deleteLayerRaw(requestParameters);
    }

    /**
     * It will also delete the related document Required scopes: ifc:write, model:write
     * Delete a model
     */
    async deleteModelRaw(requestParameters: DeleteModelRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteModel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteModel.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteModel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * It will also delete the related document Required scopes: ifc:write, model:write
     * Delete a model
     */
    async deleteModel(requestParameters: DeleteModelRequest): Promise<void> {
        await this.deleteModelRaw(requestParameters);
    }

    /**
     * Delete a Property of a model Required scopes: ifc:write, model:write
     * Delete a Property of a model
     */
    async deleteModelPropertyRaw(requestParameters: DeleteModelPropertyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteModelProperty.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteModelProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteModelProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteModelProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a Property of a model Required scopes: ifc:write, model:write
     * Delete a Property of a model
     */
    async deleteModelProperty(requestParameters: DeleteModelPropertyRequest): Promise<void> {
        await this.deleteModelPropertyRaw(requestParameters);
    }

    /**
     * Delete a PropertyDefinitions of a model Required scopes: ifc:write, model:write
     * Delete a PropertyDefinitions of a model
     */
    async deleteModelPropertyDefinitionRaw(requestParameters: DeleteModelPropertyDefinitionRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteModelPropertyDefinition.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteModelPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteModelPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteModelPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertydefinition/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a PropertyDefinitions of a model Required scopes: ifc:write, model:write
     * Delete a PropertyDefinitions of a model
     */
    async deleteModelPropertyDefinition(requestParameters: DeleteModelPropertyDefinitionRequest): Promise<void> {
        await this.deleteModelPropertyDefinitionRaw(requestParameters);
    }

    /**
     * Delete a Unit of a model Required scopes: ifc:write, model:write
     * Delete a Unit of a model
     */
    async deleteModelUnitRaw(requestParameters: DeleteModelUnitRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteModelUnit.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteModelUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteModelUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteModelUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/unit/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a Unit of a model Required scopes: ifc:write, model:write
     * Delete a Unit of a model
     */
    async deleteModelUnit(requestParameters: DeleteModelUnitRequest): Promise<void> {
        await this.deleteModelUnitRaw(requestParameters);
    }

    /**
     * Delete the Model without deleting the related document Required scopes: ifc:write, model:write
     * Delete the Model without deleting the related document
     */
    async deleteModelWithoutDocRaw(requestParameters: DeleteModelWithoutDocRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteModelWithoutDoc.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteModelWithoutDoc.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteModelWithoutDoc.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}/delete-model`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the Model without deleting the related document Required scopes: ifc:write, model:write
     * Delete the Model without deleting the related document
     */
    async deleteModelWithoutDoc(requestParameters: DeleteModelWithoutDocRequest): Promise<void> {
        await this.deleteModelWithoutDocRaw(requestParameters);
    }

    /**
     * Delete a PropertySet of a model Required scopes: ifc:write, model:write
     * Delete a PropertySet of a model
     */
    async deletePropertySetRaw(requestParameters: DeletePropertySetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deletePropertySet.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deletePropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deletePropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deletePropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a PropertySet of a model Required scopes: ifc:write, model:write
     * Delete a PropertySet of a model
     */
    async deletePropertySet(requestParameters: DeletePropertySetRequest): Promise<void> {
        await this.deletePropertySetRaw(requestParameters);
    }

    /**
     * It will not delete related zones. The IFC file will not be updated. The remaining spaces are available in API and will be available when exporting an IFC file Required scopes: ifc:write, model:write
     * Delete a space
     */
    async deleteSpaceRaw(requestParameters: DeleteSpaceRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteSpace.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/space/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * It will not delete related zones. The IFC file will not be updated. The remaining spaces are available in API and will be available when exporting an IFC file Required scopes: ifc:write, model:write
     * Delete a space
     */
    async deleteSpace(requestParameters: DeleteSpaceRequest): Promise<void> {
        await this.deleteSpaceRaw(requestParameters);
    }

    /**
     * Delete a storey of a model Required scopes: ifc:write, model:write
     * Delete a storey of a model
     */
    async deleteStoreyRaw(requestParameters: DeleteStoreyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteStorey.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteStorey.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteStorey.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteStorey.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a storey of a model Required scopes: ifc:write, model:write
     * Delete a storey of a model
     */
    async deleteStorey(requestParameters: DeleteStoreyRequest): Promise<void> {
        await this.deleteStoreyRaw(requestParameters);
    }

    /**
     * Delete the relation between a 2d model and a storey Required scopes: ifc:write, model:write
     * Delete the relation between a 2d model and a storey
     */
    async deleteStoreyPlanRaw(requestParameters: DeleteStoreyPlanRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteStoreyPlan.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteStoreyPlan.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteStoreyPlan.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteStoreyPlan.');
        }

        if (requestParameters.storeyPk === null || requestParameters.storeyPk === undefined) {
            throw new runtime.RequiredError('storeyPk','Required parameter requestParameters.storeyPk was null or undefined when calling deleteStoreyPlan.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{storey_pk}/plan/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"storey_pk"}}`, encodeURIComponent(String(requestParameters.storeyPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the relation between a 2d model and a storey Required scopes: ifc:write, model:write
     * Delete the relation between a 2d model and a storey
     */
    async deleteStoreyPlan(requestParameters: DeleteStoreyPlanRequest): Promise<void> {
        await this.deleteStoreyPlanRaw(requestParameters);
    }

    /**
     * The IFC file will not be updated. The remaining systems are available in API and will be available when exporting an IFC file Required scopes: ifc:write, model:write
     * Delete a system of a model
     */
    async deleteSystemRaw(requestParameters: DeleteSystemRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteSystem.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteSystem.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteSystem.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling deleteSystem.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/system/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The IFC file will not be updated. The remaining systems are available in API and will be available when exporting an IFC file Required scopes: ifc:write, model:write
     * Delete a system of a model
     */
    async deleteSystem(requestParameters: DeleteSystemRequest): Promise<void> {
        await this.deleteSystemRaw(requestParameters);
    }

    /**
     * The IFC file will not be updated. The remaining zones are available in API and will be available when exporting an IFC file Required scopes: ifc:write, model:write
     * Delete a zone of a model
     */
    async deleteZoneRaw(requestParameters: DeleteZoneRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteZone.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteZone.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteZone.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteZone.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The IFC file will not be updated. The remaining zones are available in API and will be available when exporting an IFC file Required scopes: ifc:write, model:write
     * Delete a zone of a model
     */
    async deleteZone(requestParameters: DeleteZoneRequest): Promise<void> {
        await this.deleteZoneRaw(requestParameters);
    }

    /**
     * The IFC file will not be updated. The remaining spaces are available in API and will be available when exporting an IFC file Required scopes: ifc:write, model:write
     * Delete a space of a zone
     */
    async deleteZoneSpaceRaw(requestParameters: DeleteZoneSpaceRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteZoneSpace.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteZoneSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteZoneSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteZoneSpace.');
        }

        if (requestParameters.zonePk === null || requestParameters.zonePk === undefined) {
            throw new runtime.RequiredError('zonePk','Required parameter requestParameters.zonePk was null or undefined when calling deleteZoneSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{zone_pk}/space/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"zone_pk"}}`, encodeURIComponent(String(requestParameters.zonePk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The IFC file will not be updated. The remaining spaces are available in API and will be available when exporting an IFC file Required scopes: ifc:write, model:write
     * Delete a space of a zone
     */
    async deleteZoneSpace(requestParameters: DeleteZoneSpaceRequest): Promise<void> {
        await this.deleteZoneSpaceRaw(requestParameters);
    }

    /**
     * Only works for IFC files. Export IFC as requested in parameters. When the export is finished, a new IFC file with will be created in the same folder than the original IFC. You can query the folder or subscribe to the new document webhook to retrieve the result Required scopes: ifc:write, model:write
     * Export IFC
     */
    async exportIfcRaw(requestParameters: ExportIfcRequest): Promise<runtime.ApiResponse<IfcExport>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling exportIfc.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling exportIfc.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling exportIfc.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling exportIfc.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}/export`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IfcExportToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IfcExportFromJSON(jsonValue));
    }

    /**
     * Only works for IFC files. Export IFC as requested in parameters. When the export is finished, a new IFC file with will be created in the same folder than the original IFC. You can query the folder or subscribe to the new document webhook to retrieve the result Required scopes: ifc:write, model:write
     * Export IFC
     */
    async exportIfc(requestParameters: ExportIfcRequest): Promise<IfcExport> {
        const response = await this.exportIfcRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update all fields of an element. The IFC file will not be updated. The created element will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update all fields of an element
     */
    async fullUpdateElementRaw(requestParameters: FullUpdateElementRequest): Promise<runtime.ApiResponse<Element>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling fullUpdateElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling fullUpdateElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling fullUpdateElement.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling fullUpdateElement.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ElementToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ElementFromJSON(jsonValue));
    }

    /**
     * Update all fields of an element. The IFC file will not be updated. The created element will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update all fields of an element
     */
    async fullUpdateElement(requestParameters: FullUpdateElementRequest): Promise<Element> {
        const response = await this.fullUpdateElementRaw(requestParameters);
        return await response.value();
    }

    /**
     *          This route allows you to create storeys, modify them, delete them and organize them by order.         If the optional field \"id\" is present, the storey will be modified. Otherwise, a new storey will be created.         If an \"id\" present in the api is not present in the list passed in parameter, the corresponding storey will be deleted.         A storey with \"is_site=True\" will be stored without order. There can be only one storey with \"is_site=True\"\"  Required scopes: ifc:write, model:write
     * Update all fields of all storeys
     */
    async fullUpdateStoreysRaw(requestParameters: FullUpdateStoreysRequest): Promise<runtime.ApiResponse<Array<Storey>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling fullUpdateStoreys.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling fullUpdateStoreys.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling fullUpdateStoreys.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling fullUpdateStoreys.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/full_update`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data.map(StoreyRequestToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StoreyFromJSON));
    }

    /**
     *          This route allows you to create storeys, modify them, delete them and organize them by order.         If the optional field \"id\" is present, the storey will be modified. Otherwise, a new storey will be created.         If an \"id\" present in the api is not present in the list passed in parameter, the corresponding storey will be deleted.         A storey with \"is_site=True\" will be stored without order. There can be only one storey with \"is_site=True\"\"  Required scopes: ifc:write, model:write
     * Update all fields of all storeys
     */
    async fullUpdateStoreys(requestParameters: FullUpdateStoreysRequest): Promise<Array<Storey>> {
        const response = await this.fullUpdateStoreysRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve one token created for this model Required scopes: ifc:token_manage, model:token_manage
     * Retrieve one token created for this model
     */
    async getAccessTokenRaw(requestParameters: GetAccessTokenRequest): Promise<runtime.ApiResponse<IfcAccessToken>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getAccessToken.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getAccessToken.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling getAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/access_token/{token}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IfcAccessTokenFromJSON(jsonValue));
    }

    /**
     * Retrieve one token created for this model Required scopes: ifc:token_manage, model:token_manage
     * Retrieve one token created for this model
     */
    async getAccessToken(requestParameters: GetAccessTokenRequest): Promise<IfcAccessToken> {
        const response = await this.getAccessTokenRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all tokens created for this model Required scopes: ifc:token_manage, model:token_manage
     * Retrieve all tokens created for this model
     */
    async getAccessTokensRaw(requestParameters: GetAccessTokensRequest): Promise<runtime.ApiResponse<Array<IfcAccessToken>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getAccessTokens.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getAccessTokens.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getAccessTokens.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/access_token`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(IfcAccessTokenFromJSON));
    }

    /**
     * Retrieve all tokens created for this model Required scopes: ifc:token_manage, model:token_manage
     * Retrieve all tokens created for this model
     */
    async getAccessTokens(requestParameters: GetAccessTokensRequest): Promise<Array<IfcAccessToken>> {
        const response = await this.getAccessTokensRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all classifications of an element Required scopes: ifc:read, model:read
     * Retrieve all classifications of an element
     */
    async getClassificationsOfElementRaw(requestParameters: GetClassificationsOfElementRequest): Promise<runtime.ApiResponse<Array<Classification>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getClassificationsOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getClassificationsOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getClassificationsOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getClassificationsOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/classification`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClassificationFromJSON));
    }

    /**
     * Retrieve all classifications of an element Required scopes: ifc:read, model:read
     * Retrieve all classifications of an element
     */
    async getClassificationsOfElement(requestParameters: GetClassificationsOfElementRequest): Promise<Array<Classification>> {
        const response = await this.getClassificationsOfElementRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all documents of an element Required scopes: ifc:read, model:read
     * Retrieve all documents of an element
     */
    async getDocumentsOfElementRaw(requestParameters: GetDocumentsOfElementRequest): Promise<runtime.ApiResponse<Array<Document>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getDocumentsOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getDocumentsOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getDocumentsOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getDocumentsOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/documents`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DocumentFromJSON));
    }

    /**
     * Retrieve all documents of an element Required scopes: ifc:read, model:read
     * Retrieve all documents of an element
     */
    async getDocumentsOfElement(requestParameters: GetDocumentsOfElementRequest): Promise<Array<Document>> {
        const response = await this.getDocumentsOfElementRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve an element of a model Required scopes: ifc:read, model:read
     * Retrieve an element of a model
     */
    async getElementRaw(requestParameters: GetElementRequest): Promise<runtime.ApiResponse<Element>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElement.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ElementFromJSON(jsonValue));
    }

    /**
     * Retrieve an element of a model Required scopes: ifc:read, model:read
     * Retrieve an element of a model
     */
    async getElement(requestParameters: GetElementRequest): Promise<Element> {
        const response = await this.getElementRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all documents linked to any element with the list of uuids Required scopes: ifc:read, model:read
     * Retrieve all documents linked to any element
     */
    async getElementLinkedDocumentsRaw(requestParameters: GetElementLinkedDocumentsRequest): Promise<runtime.ApiResponse<Array<DocumentWithElementList>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementLinkedDocuments.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementLinkedDocuments.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementLinkedDocuments.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.classification !== undefined) {
            queryParameters['classification'] = requestParameters.classification;
        }

        if (requestParameters.classificationNotation !== undefined) {
            queryParameters['classification__notation'] = requestParameters.classificationNotation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/documents`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DocumentWithElementListFromJSON));
    }

    /**
     * Retrieve all documents linked to any element with the list of uuids Required scopes: ifc:read, model:read
     * Retrieve all documents linked to any element
     */
    async getElementLinkedDocuments(requestParameters: GetElementLinkedDocumentsRequest): Promise<Array<DocumentWithElementList>> {
        const response = await this.getElementLinkedDocumentsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a PropertySet of an element Required scopes: ifc:read, model:read
     * Retrieve a PropertySet of an element
     */
    async getElementPropertySetRaw(requestParameters: GetElementPropertySetRequest): Promise<runtime.ApiResponse<PropertySet>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySet.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySet.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getElementPropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertySetFromJSON(jsonValue));
    }

    /**
     * Retrieve a PropertySet of an element Required scopes: ifc:read, model:read
     * Retrieve a PropertySet of an element
     */
    async getElementPropertySet(requestParameters: GetElementPropertySetRequest): Promise<PropertySet> {
        const response = await this.getElementPropertySetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all Properties of a PropertySet Required scopes: ifc:read, model:read
     * Retrieve all Properties of a PropertySet
     */
    async getElementPropertySetPropertiesRaw(requestParameters: GetElementPropertySetPropertiesRequest): Promise<runtime.ApiResponse<Array<Property>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySetProperties.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySetProperties.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySetProperties.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySetProperties.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling getElementPropertySetProperties.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyFromJSON));
    }

    /**
     * Retrieve all Properties of a PropertySet Required scopes: ifc:read, model:read
     * Retrieve all Properties of a PropertySet
     */
    async getElementPropertySetProperties(requestParameters: GetElementPropertySetPropertiesRequest): Promise<Array<Property>> {
        const response = await this.getElementPropertySetPropertiesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a Property of a PropertySet Required scopes: ifc:read, model:read
     * Retrieve a Property of a PropertySet
     */
    async getElementPropertySetPropertyRaw(requestParameters: GetElementPropertySetPropertyRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySetProperty.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySetProperty.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getElementPropertySetProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySetProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySetProperty.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling getElementPropertySetProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * Retrieve a Property of a PropertySet Required scopes: ifc:read, model:read
     * Retrieve a Property of a PropertySet
     */
    async getElementPropertySetProperty(requestParameters: GetElementPropertySetPropertyRequest): Promise<Property> {
        const response = await this.getElementPropertySetPropertyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a Definition of a Property Required scopes: ifc:read, model:read
     * Retrieve a Definition of a Property
     */
    async getElementPropertySetPropertyDefinitionRaw(requestParameters: GetElementPropertySetPropertyDefinitionRequest): Promise<runtime.ApiResponse<PropertyDefinition>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyDefinitionFromJSON(jsonValue));
    }

    /**
     * Retrieve a Definition of a Property Required scopes: ifc:read, model:read
     * Retrieve a Definition of a Property
     */
    async getElementPropertySetPropertyDefinition(requestParameters: GetElementPropertySetPropertyDefinitionRequest): Promise<PropertyDefinition> {
        const response = await this.getElementPropertySetPropertyDefinitionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a Unit of a Definition Required scopes: ifc:read, model:read
     * Retrieve a Unit of a Definition
     */
    async getElementPropertySetPropertyDefinitionUnitRaw(requestParameters: GetElementPropertySetPropertyDefinitionUnitRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertydefinitionPk === null || requestParameters.propertydefinitionPk === undefined) {
            throw new runtime.RequiredError('propertydefinitionPk','Required parameter requestParameters.propertydefinitionPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition/{propertydefinition_pk}/unit/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertydefinition_pk"}}`, encodeURIComponent(String(requestParameters.propertydefinitionPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     * Retrieve a Unit of a Definition Required scopes: ifc:read, model:read
     * Retrieve a Unit of a Definition
     */
    async getElementPropertySetPropertyDefinitionUnit(requestParameters: GetElementPropertySetPropertyDefinitionUnitRequest): Promise<Unit> {
        const response = await this.getElementPropertySetPropertyDefinitionUnitRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all Units of a Definition Required scopes: ifc:read, model:read
     * Retrieve all Units of a Definition
     */
    async getElementPropertySetPropertyDefinitionUnitsRaw(requestParameters: GetElementPropertySetPropertyDefinitionUnitsRequest): Promise<runtime.ApiResponse<Array<Unit>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        if (requestParameters.propertydefinitionPk === null || requestParameters.propertydefinitionPk === undefined) {
            throw new runtime.RequiredError('propertydefinitionPk','Required parameter requestParameters.propertydefinitionPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition/{propertydefinition_pk}/unit`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertydefinition_pk"}}`, encodeURIComponent(String(requestParameters.propertydefinitionPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UnitFromJSON));
    }

    /**
     * Retrieve all Units of a Definition Required scopes: ifc:read, model:read
     * Retrieve all Units of a Definition
     */
    async getElementPropertySetPropertyDefinitionUnits(requestParameters: GetElementPropertySetPropertyDefinitionUnitsRequest): Promise<Array<Unit>> {
        const response = await this.getElementPropertySetPropertyDefinitionUnitsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all Definitions of a PropertySet Required scopes: ifc:read, model:read
     * Retrieve all Definitions of a PropertySet
     */
    async getElementPropertySetPropertyDefinitionsRaw(requestParameters: GetElementPropertySetPropertyDefinitionsRequest): Promise<runtime.ApiResponse<Array<PropertyDefinition>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySetPropertyDefinitions.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySetPropertyDefinitions.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySetPropertyDefinitions.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySetPropertyDefinitions.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling getElementPropertySetPropertyDefinitions.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling getElementPropertySetPropertyDefinitions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyDefinitionFromJSON));
    }

    /**
     * Retrieve all Definitions of a PropertySet Required scopes: ifc:read, model:read
     * Retrieve all Definitions of a PropertySet
     */
    async getElementPropertySetPropertyDefinitions(requestParameters: GetElementPropertySetPropertyDefinitionsRequest): Promise<Array<PropertyDefinition>> {
        const response = await this.getElementPropertySetPropertyDefinitionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all PropertySets of an element Required scopes: ifc:read, model:read
     * Retrieve all PropertySets of an element
     */
    async getElementPropertySetsRaw(requestParameters: GetElementPropertySetsRequest): Promise<runtime.ApiResponse<Array<PropertySet>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySets.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySets.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySets.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySets.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertySetFromJSON));
    }

    /**
     * Retrieve all PropertySets of an element Required scopes: ifc:read, model:read
     * Retrieve all PropertySets of an element
     */
    async getElementPropertySets(requestParameters: GetElementPropertySetsRequest): Promise<Array<PropertySet>> {
        const response = await this.getElementPropertySetsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all elements of a model. If not filtered, the json may be very large. To efficently retrieve all elements and their data, see getRawElements Required scopes: ifc:read, model:read
     * Retrieve all elements of a model
     */
    async getElementsRaw(requestParameters: GetElementsRequest): Promise<runtime.ApiResponse<Array<Element>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElements.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElements.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElements.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.classification !== undefined) {
            queryParameters['classification'] = requestParameters.classification;
        }

        if (requestParameters.classificationNotation !== undefined) {
            queryParameters['classification__notation'] = requestParameters.classificationNotation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ElementFromJSON));
    }

    /**
     * Retrieve all elements of a model. If not filtered, the json may be very large. To efficently retrieve all elements and their data, see getRawElements Required scopes: ifc:read, model:read
     * Retrieve all elements of a model
     */
    async getElements(requestParameters: GetElementsRequest): Promise<Array<Element>> {
        const response = await this.getElementsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all elements with the classification Required scopes: ifc:read, model:read
     * Retrieve all elements with the classification
     */
    async getElementsFromClassificationRaw(requestParameters: GetElementsFromClassificationRequest): Promise<runtime.ApiResponse<Array<Element>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementsFromClassification.');
        }

        if (requestParameters.modelClassificationPk === null || requestParameters.modelClassificationPk === undefined) {
            throw new runtime.RequiredError('modelClassificationPk','Required parameter requestParameters.modelClassificationPk was null or undefined when calling getElementsFromClassification.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementsFromClassification.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementsFromClassification.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification/{model_classification_pk}/element`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_classification_pk"}}`, encodeURIComponent(String(requestParameters.modelClassificationPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ElementFromJSON));
    }

    /**
     * Retrieve all elements with the classification Required scopes: ifc:read, model:read
     * Retrieve all elements with the classification
     */
    async getElementsFromClassification(requestParameters: GetElementsFromClassificationRequest): Promise<Array<Element>> {
        const response = await this.getElementsFromClassificationRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a layer of a model Required scopes: ifc:read, model:read
     * Retrieve a layer of a model
     */
    async getLayerRaw(requestParameters: GetLayerRequest): Promise<runtime.ApiResponse<Layer>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getLayer.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getLayer.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getLayer.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getLayer.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/layer/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LayerFromJSON(jsonValue));
    }

    /**
     * Retrieve a layer of a model Required scopes: ifc:read, model:read
     * Retrieve a layer of a model
     */
    async getLayer(requestParameters: GetLayerRequest): Promise<Layer> {
        const response = await this.getLayerRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all layers of a model. Required scopes: ifc:read, model:read
     * Retrieve all layers of a model
     */
    async getLayersRaw(requestParameters: GetLayersRequest): Promise<runtime.ApiResponse<Array<Layer>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getLayers.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getLayers.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getLayers.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/layer`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LayerFromJSON));
    }

    /**
     * Retrieve all layers of a model. Required scopes: ifc:read, model:read
     * Retrieve all layers of a model
     */
    async getLayers(requestParameters: GetLayersRequest): Promise<Array<Layer>> {
        const response = await this.getLayersRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a material of a model Required scopes: ifc:read, model:read
     * Retrieve a material of a model
     */
    async getMaterialRaw(requestParameters: GetMaterialRequest): Promise<runtime.ApiResponse<Material>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getMaterial.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getMaterial.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getMaterial.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getMaterial.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getMaterial.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/material/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MaterialFromJSON(jsonValue));
    }

    /**
     * Retrieve a material of a model Required scopes: ifc:read, model:read
     * Retrieve a material of a model
     */
    async getMaterial(requestParameters: GetMaterialRequest): Promise<Material> {
        const response = await this.getMaterialRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all materials of a model. Required scopes: ifc:read, model:read
     * Retrieve all materials of a model
     */
    async getMaterialsRaw(requestParameters: GetMaterialsRequest): Promise<runtime.ApiResponse<Array<Material>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getMaterials.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getMaterials.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getMaterials.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getMaterials.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/material`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MaterialFromJSON));
    }

    /**
     * Retrieve all materials of a model. Required scopes: ifc:read, model:read
     * Retrieve all materials of a model
     */
    async getMaterials(requestParameters: GetMaterialsRequest): Promise<Array<Material>> {
        const response = await this.getMaterialsRaw(requestParameters);
        return await response.value();
    }

    /**
     *  Required scopes: ifc:read, model:read
     * Retrieve one model
     */
    async getModelRaw(requestParameters: GetModelRequest): Promise<runtime.ApiResponse<Model>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getModel.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
    }

    /**
     *  Required scopes: ifc:read, model:read
     * Retrieve one model
     */
    async getModel(requestParameters: GetModelRequest): Promise<Model> {
        const response = await this.getModelRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all classifications in a model Required scopes: ifc:read, model:read
     * Retrieve all classifications in a model
     */
    async getModelClassificationsRaw(requestParameters: GetModelClassificationsRequest): Promise<runtime.ApiResponse<Array<Classification>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelClassifications.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelClassifications.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelClassifications.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClassificationFromJSON));
    }

    /**
     * Retrieve all classifications in a model Required scopes: ifc:read, model:read
     * Retrieve all classifications in a model
     */
    async getModelClassifications(requestParameters: GetModelClassificationsRequest): Promise<Array<Classification>> {
        const response = await this.getModelClassificationsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a material of a model Required scopes: ifc:read, model:read
     * Retrieve a material of a model
     */
    async getModelMaterialRaw(requestParameters: GetModelMaterialRequest): Promise<runtime.ApiResponse<Material>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelMaterial.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getModelMaterial.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelMaterial.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelMaterial.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/material/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MaterialFromJSON(jsonValue));
    }

    /**
     * Retrieve a material of a model Required scopes: ifc:read, model:read
     * Retrieve a material of a model
     */
    async getModelMaterial(requestParameters: GetModelMaterialRequest): Promise<Material> {
        const response = await this.getModelMaterialRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all materials of a model. Required scopes: ifc:read, model:read
     * Retrieve all materials of a model
     */
    async getModelMaterialsRaw(requestParameters: GetModelMaterialsRequest): Promise<runtime.ApiResponse<Array<Material>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelMaterials.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelMaterials.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelMaterials.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/material`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MaterialFromJSON));
    }

    /**
     * Retrieve all materials of a model. Required scopes: ifc:read, model:read
     * Retrieve all materials of a model
     */
    async getModelMaterials(requestParameters: GetModelMaterialsRequest): Promise<Array<Material>> {
        const response = await this.getModelMaterialsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all PropertySets of a model Required scopes: ifc:read, model:read
     * Retrieve all Properties of a model
     */
    async getModelPropertiesRaw(requestParameters: GetModelPropertiesRequest): Promise<runtime.ApiResponse<Array<Property>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelProperties.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelProperties.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelProperties.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyFromJSON));
    }

    /**
     * Retrieve all PropertySets of a model Required scopes: ifc:read, model:read
     * Retrieve all Properties of a model
     */
    async getModelProperties(requestParameters: GetModelPropertiesRequest): Promise<Array<Property>> {
        const response = await this.getModelPropertiesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a Property of a model Required scopes: ifc:read, model:read
     * Retrieve a Property of a model
     */
    async getModelPropertyRaw(requestParameters: GetModelPropertyRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelProperty.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getModelProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * Retrieve a Property of a model Required scopes: ifc:read, model:read
     * Retrieve a Property of a model
     */
    async getModelProperty(requestParameters: GetModelPropertyRequest): Promise<Property> {
        const response = await this.getModelPropertyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a PropertyDefinition of a model Required scopes: ifc:read, model:read
     * Retrieve a PropertyDefinition of a model
     */
    async getModelPropertyDefinitionRaw(requestParameters: GetModelPropertyDefinitionRequest): Promise<runtime.ApiResponse<PropertyDefinition>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelPropertyDefinition.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getModelPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertydefinition/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyDefinitionFromJSON(jsonValue));
    }

    /**
     * Retrieve a PropertyDefinition of a model Required scopes: ifc:read, model:read
     * Retrieve a PropertyDefinition of a model
     */
    async getModelPropertyDefinition(requestParameters: GetModelPropertyDefinitionRequest): Promise<PropertyDefinition> {
        const response = await this.getModelPropertyDefinitionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all PropertyDefinitions of a model Required scopes: ifc:read, model:read
     * Retrieve all PropertyDefinitions of a model
     */
    async getModelPropertyDefinitionsRaw(requestParameters: GetModelPropertyDefinitionsRequest): Promise<runtime.ApiResponse<Array<PropertyDefinition>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelPropertyDefinitions.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelPropertyDefinitions.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelPropertyDefinitions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertydefinition`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyDefinitionFromJSON));
    }

    /**
     * Retrieve all PropertyDefinitions of a model Required scopes: ifc:read, model:read
     * Retrieve all PropertyDefinitions of a model
     */
    async getModelPropertyDefinitions(requestParameters: GetModelPropertyDefinitionsRequest): Promise<Array<PropertyDefinition>> {
        const response = await this.getModelPropertyDefinitionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a Unit of a model Required scopes: ifc:read, model:read
     * Retrieve a Unit of a model
     */
    async getModelUnitRaw(requestParameters: GetModelUnitRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelUnit.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getModelUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/unit/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     * Retrieve a Unit of a model Required scopes: ifc:read, model:read
     * Retrieve a Unit of a model
     */
    async getModelUnit(requestParameters: GetModelUnitRequest): Promise<Unit> {
        const response = await this.getModelUnitRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all Units of a model Required scopes: ifc:read, model:read
     * Retrieve all Units of a model
     */
    async getModelUnitsRaw(requestParameters: GetModelUnitsRequest): Promise<runtime.ApiResponse<Array<Unit>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelUnits.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelUnits.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelUnits.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/unit`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UnitFromJSON));
    }

    /**
     * Retrieve all Units of a model Required scopes: ifc:read, model:read
     * Retrieve all Units of a model
     */
    async getModelUnits(requestParameters: GetModelUnitsRequest): Promise<Array<Unit>> {
        const response = await this.getModelUnitsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all models. The field `type` allows you to discriminate which kind of model it is. Required scopes: ifc:read, model:read
     * Retrieve all models
     */
    async getModelsRaw(requestParameters: GetModelsRequest): Promise<runtime.ApiResponse<Array<Model>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModels.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModels.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.source !== undefined) {
            queryParameters['source'] = requestParameters.source;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ModelFromJSON));
    }

    /**
     * Retrieve all models. The field `type` allows you to discriminate which kind of model it is. Required scopes: ifc:read, model:read
     * Retrieve all models
     */
    async getModels(requestParameters: GetModelsRequest): Promise<Array<Model>> {
        const response = await this.getModelsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve the postioning of the plan in the storey Required scopes: ifc:read, model:read
     * Retrieve the postioning of the plan in the storey
     */
    async getPlanPositioningRaw(requestParameters: GetPlanPositioningRequest): Promise<runtime.ApiResponse<PositioningPlan>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getPlanPositioning.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getPlanPositioning.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getPlanPositioning.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getPlanPositioning.');
        }

        if (requestParameters.storeyPk === null || requestParameters.storeyPk === undefined) {
            throw new runtime.RequiredError('storeyPk','Required parameter requestParameters.storeyPk was null or undefined when calling getPlanPositioning.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{storey_pk}/plan/{id}/positioning`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"storey_pk"}}`, encodeURIComponent(String(requestParameters.storeyPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PositioningPlanFromJSON(jsonValue));
    }

    /**
     * Retrieve the postioning of the plan in the storey Required scopes: ifc:read, model:read
     * Retrieve the postioning of the plan in the storey
     */
    async getPlanPositioning(requestParameters: GetPlanPositioningRequest): Promise<PositioningPlan> {
        const response = await this.getPlanPositioningRaw(requestParameters);
        return await response.value();
    }

    /**
     *  Required scopes: ifc:read, model:read
     * Retrieve a processor handler
     */
    async getProcessorHandlerRaw(requestParameters: GetProcessorHandlerRequest): Promise<runtime.ApiResponse<ProcessorHandler>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProcessorHandler.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getProcessorHandler.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getProcessorHandler.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getProcessorHandler.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/processorhandler/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessorHandlerFromJSON(jsonValue));
    }

    /**
     *  Required scopes: ifc:read, model:read
     * Retrieve a processor handler
     */
    async getProcessorHandler(requestParameters: GetProcessorHandlerRequest): Promise<ProcessorHandler> {
        const response = await this.getProcessorHandlerRaw(requestParameters);
        return await response.value();
    }

    /**
     *  Required scopes: ifc:read, model:read
     * Get all processor handlers
     */
    async getProcessorHandlersRaw(requestParameters: GetProcessorHandlersRequest): Promise<runtime.ApiResponse<Array<ProcessorHandler>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProcessorHandlers.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getProcessorHandlers.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getProcessorHandlers.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/processorhandler`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProcessorHandlerFromJSON));
    }

    /**
     *  Required scopes: ifc:read, model:read
     * Get all processor handlers
     */
    async getProcessorHandlers(requestParameters: GetProcessorHandlersRequest): Promise<Array<ProcessorHandler>> {
        const response = await this.getProcessorHandlersRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a PropertySet of a model Required scopes: ifc:read, model:read
     * Retrieve a PropertySet of a model
     */
    async getPropertySetRaw(requestParameters: GetPropertySetRequest): Promise<runtime.ApiResponse<PropertySet>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getPropertySet.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getPropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getPropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getPropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertySetFromJSON(jsonValue));
    }

    /**
     * Retrieve a PropertySet of a model Required scopes: ifc:read, model:read
     * Retrieve a PropertySet of a model
     */
    async getPropertySet(requestParameters: GetPropertySetRequest): Promise<PropertySet> {
        const response = await this.getPropertySetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all PropertySets of a model Required scopes: ifc:read, model:read
     * Retrieve all PropertySets of a model
     */
    async getPropertySetsRaw(requestParameters: GetPropertySetsRequest): Promise<runtime.ApiResponse<Array<PropertySet>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getPropertySets.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getPropertySets.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getPropertySets.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertySetFromJSON));
    }

    /**
     * Retrieve all PropertySets of a model Required scopes: ifc:read, model:read
     * Retrieve all PropertySets of a model
     */
    async getPropertySets(requestParameters: GetPropertySetsRequest): Promise<Array<PropertySet>> {
        const response = await this.getPropertySetsRaw(requestParameters);
        return await response.value();
    }

    /**
     *          Returns elements, property_sets, properties, definitions and units in a JSON optimized structure  Required scopes: ifc:read, model:read
     * Retrieve all elements in a optimized format
     */
    async getRawElementsRaw(requestParameters: GetRawElementsRequest): Promise<runtime.ApiResponse<RawElements>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getRawElements.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getRawElements.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getRawElements.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.classification !== undefined) {
            queryParameters['classification'] = requestParameters.classification;
        }

        if (requestParameters.classificationNotation !== undefined) {
            queryParameters['classification__notation'] = requestParameters.classificationNotation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/raw`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RawElementsFromJSON(jsonValue));
    }

    /**
     *          Returns elements, property_sets, properties, definitions and units in a JSON optimized structure  Required scopes: ifc:read, model:read
     * Retrieve all elements in a optimized format
     */
    async getRawElements(requestParameters: GetRawElementsRequest): Promise<RawElements> {
        const response = await this.getRawElementsRaw(requestParameters);
        return await response.value();
    }

    /**
     *          Retrieve an element of a model with a simple value representation         Format response :             {                 :element_uuid: {                     \"attributes\": {                         :property_name: value,                         :property_name: value                     },                     :property_set_name: {                         :property_name: value,                         :property_name: value                     }                 }             }  Required scopes: ifc:read, model:read
     * Retrieve an element of a model with a simple value representation
     */
    async getSimpleElementRaw(requestParameters: GetSimpleElementRequest): Promise<runtime.ApiResponse<SimpleElement>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getSimpleElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getSimpleElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getSimpleElement.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getSimpleElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{uuid}/simple`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SimpleElementFromJSON(jsonValue));
    }

    /**
     *          Retrieve an element of a model with a simple value representation         Format response :             {                 :element_uuid: {                     \"attributes\": {                         :property_name: value,                         :property_name: value                     },                     :property_set_name: {                         :property_name: value,                         :property_name: value                     }                 }             }  Required scopes: ifc:read, model:read
     * Retrieve an element of a model with a simple value representation
     */
    async getSimpleElement(requestParameters: GetSimpleElementRequest): Promise<SimpleElement> {
        const response = await this.getSimpleElementRaw(requestParameters);
        return await response.value();
    }

    /**
     *          Retrieve all elements of a model with a simple value representation         Format response :             {                 :element_uuid: {                     \"attributes\": {                         :property_name: value,                         :property_name: value                     },                     :property_set_name: {                         :property_name: value,                         :property_name: value                     }                 }             }  Required scopes: ifc:read, model:read
     * Retrieve all elements of a model with a simple value representation
     */
    async getSimpleElementsRaw(requestParameters: GetSimpleElementsRequest): Promise<runtime.ApiResponse<SimpleElement>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getSimpleElements.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getSimpleElements.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getSimpleElements.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.classification !== undefined) {
            queryParameters['classification'] = requestParameters.classification;
        }

        if (requestParameters.classificationNotation !== undefined) {
            queryParameters['classification__notation'] = requestParameters.classificationNotation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/simple`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SimpleElementFromJSON(jsonValue));
    }

    /**
     *          Retrieve all elements of a model with a simple value representation         Format response :             {                 :element_uuid: {                     \"attributes\": {                         :property_name: value,                         :property_name: value                     },                     :property_set_name: {                         :property_name: value,                         :property_name: value                     }                 }             }  Required scopes: ifc:read, model:read
     * Retrieve all elements of a model with a simple value representation
     */
    async getSimpleElements(requestParameters: GetSimpleElementsRequest): Promise<SimpleElement> {
        const response = await this.getSimpleElementsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve one space of the model Required scopes: ifc:read, model:read
     * Retrieve one space of the model
     */
    async getSpaceRaw(requestParameters: GetSpaceRequest): Promise<runtime.ApiResponse<Space>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getSpace.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/space/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SpaceFromJSON(jsonValue));
    }

    /**
     * Retrieve one space of the model Required scopes: ifc:read, model:read
     * Retrieve one space of the model
     */
    async getSpace(requestParameters: GetSpaceRequest): Promise<Space> {
        const response = await this.getSpaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all spaces of the model Required scopes: ifc:read, model:read
     * Retrieve all spaces of the model
     */
    async getSpacesRaw(requestParameters: GetSpacesRequest): Promise<runtime.ApiResponse<Array<Space>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getSpaces.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getSpaces.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getSpaces.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/space`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SpaceFromJSON));
    }

    /**
     * Retrieve all spaces of the model Required scopes: ifc:read, model:read
     * Retrieve all spaces of the model
     */
    async getSpaces(requestParameters: GetSpacesRequest): Promise<Array<Space>> {
        const response = await this.getSpacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a storey of a model Required scopes: ifc:read, model:read
     * Retrieve a storey of a model
     */
    async getStoreyRaw(requestParameters: GetStoreyRequest): Promise<runtime.ApiResponse<Storey>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getStorey.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getStorey.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getStorey.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getStorey.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreyFromJSON(jsonValue));
    }

    /**
     * Retrieve a storey of a model Required scopes: ifc:read, model:read
     * Retrieve a storey of a model
     */
    async getStorey(requestParameters: GetStoreyRequest): Promise<Storey> {
        const response = await this.getStoreyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all storeys of a model. Required scopes: ifc:read, model:read
     * Retrieve all storeys of a model
     */
    async getStoreysRaw(requestParameters: GetStoreysRequest): Promise<runtime.ApiResponse<Array<Storey>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getStoreys.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getStoreys.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getStoreys.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StoreyFromJSON));
    }

    /**
     * Retrieve all storeys of a model. Required scopes: ifc:read, model:read
     * Retrieve all storeys of a model
     */
    async getStoreys(requestParameters: GetStoreysRequest): Promise<Array<Storey>> {
        const response = await this.getStoreysRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve a system of a model Required scopes: ifc:read, model:read
     * Retrieve a system of a model
     */
    async getSystemRaw(requestParameters: GetSystemRequest): Promise<runtime.ApiResponse<System>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getSystem.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getSystem.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getSystem.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getSystem.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/system/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SystemFromJSON(jsonValue));
    }

    /**
     * Retrieve a system of a model Required scopes: ifc:read, model:read
     * Retrieve a system of a model
     */
    async getSystem(requestParameters: GetSystemRequest): Promise<System> {
        const response = await this.getSystemRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all systems of a model. Required scopes: ifc:read, model:read
     * Retrieve all systems of a model
     */
    async getSystemsRaw(requestParameters: GetSystemsRequest): Promise<runtime.ApiResponse<Array<System>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getSystems.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getSystems.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getSystems.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/system`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SystemFromJSON));
    }

    /**
     * Retrieve all systems of a model. Required scopes: ifc:read, model:read
     * Retrieve all systems of a model
     */
    async getSystems(requestParameters: GetSystemsRequest): Promise<Array<System>> {
        const response = await this.getSystemsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve one zone of a model Required scopes: ifc:read, model:read
     * Retrieve one zone of a model
     */
    async getZoneRaw(requestParameters: GetZoneRequest): Promise<runtime.ApiResponse<Zone>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getZone.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getZone.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getZone.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getZone.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ZoneFromJSON(jsonValue));
    }

    /**
     * Retrieve one zone of a model Required scopes: ifc:read, model:read
     * Retrieve one zone of a model
     */
    async getZone(requestParameters: GetZoneRequest): Promise<Zone> {
        const response = await this.getZoneRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve one space of a zone Required scopes: ifc:read, model:read
     * Retrieve one space of a zone
     */
    async getZoneSpaceRaw(requestParameters: GetZoneSpaceRequest): Promise<runtime.ApiResponse<ZoneSpace>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getZoneSpace.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getZoneSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getZoneSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getZoneSpace.');
        }

        if (requestParameters.zonePk === null || requestParameters.zonePk === undefined) {
            throw new runtime.RequiredError('zonePk','Required parameter requestParameters.zonePk was null or undefined when calling getZoneSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{zone_pk}/space/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"zone_pk"}}`, encodeURIComponent(String(requestParameters.zonePk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ZoneSpaceFromJSON(jsonValue));
    }

    /**
     * Retrieve one space of a zone Required scopes: ifc:read, model:read
     * Retrieve one space of a zone
     */
    async getZoneSpace(requestParameters: GetZoneSpaceRequest): Promise<ZoneSpace> {
        const response = await this.getZoneSpaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve all spaces of a zone Required scopes: ifc:read, model:read
     * Retrieve all spaces of a zone
     */
    async getZoneSpacesRaw(requestParameters: GetZoneSpacesRequest): Promise<runtime.ApiResponse<Array<ZoneSpace>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getZoneSpaces.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getZoneSpaces.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getZoneSpaces.');
        }

        if (requestParameters.zonePk === null || requestParameters.zonePk === undefined) {
            throw new runtime.RequiredError('zonePk','Required parameter requestParameters.zonePk was null or undefined when calling getZoneSpaces.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{zone_pk}/space`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"zone_pk"}}`, encodeURIComponent(String(requestParameters.zonePk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ZoneSpaceFromJSON));
    }

    /**
     * Retrieve all spaces of a zone Required scopes: ifc:read, model:read
     * Retrieve all spaces of a zone
     */
    async getZoneSpaces(requestParameters: GetZoneSpacesRequest): Promise<Array<ZoneSpace>> {
        const response = await this.getZoneSpacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve parent zones of a model. Children zones we\'ll be in the \'zones\' field Required scopes: ifc:read, model:read
     * Retrieve zones of a model
     */
    async getZonesRaw(requestParameters: GetZonesRequest): Promise<runtime.ApiResponse<Array<Zone>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getZones.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getZones.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getZones.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.color !== undefined) {
            queryParameters['color'] = requestParameters.color;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ZoneFromJSON));
    }

    /**
     * Retrieve parent zones of a model. Children zones we\'ll be in the \'zones\' field Required scopes: ifc:read, model:read
     * Retrieve zones of a model
     */
    async getZones(requestParameters: GetZonesRequest): Promise<Array<Zone>> {
        const response = await this.getZonesRaw(requestParameters);
        return await response.value();
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Link one or many documents to an element
     */
    async linkDocumentsOfElementRaw(requestParameters: LinkDocumentsOfElementRequest): Promise<runtime.ApiResponse<Array<Document>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling linkDocumentsOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling linkDocumentsOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling linkDocumentsOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling linkDocumentsOfElement.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling linkDocumentsOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/documents`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DocumentFromJSON));
    }

    /**
     *          Bulk create available.         You can either post an object or a list of objects.         Is you post a list, the response will be a list (in the same order) of created objects or of errors if any         If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  Required scopes: ifc:write, model:write
     * Link one or many documents to an element
     */
    async linkDocumentsOfElement(requestParameters: LinkDocumentsOfElementRequest): Promise<Array<Document>> {
        const response = await this.linkDocumentsOfElementRaw(requestParameters);
        return await response.value();
    }

    /**
     * List all associations between classifications and elements Required scopes: ifc:read, model:read
     * List all associations between classifications and elements
     */
    async listClassificationElementRelationsRaw(requestParameters: ListClassificationElementRelationsRequest): Promise<runtime.ApiResponse<Array<ElementClassificationRelation>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling listClassificationElementRelations.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling listClassificationElementRelations.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling listClassificationElementRelations.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification-element`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ElementClassificationRelationFromJSON));
    }

    /**
     * List all associations between classifications and elements Required scopes: ifc:read, model:read
     * List all associations between classifications and elements
     */
    async listClassificationElementRelations(requestParameters: ListClassificationElementRelationsRequest): Promise<Array<ElementClassificationRelation>> {
        const response = await this.listClassificationElementRelationsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Only works for IFC files. Merge IFC files. The merged IFC file will be put in the same folder that the first IFC of the list Required scopes: ifc:write, model:write
     * Merge IFC files
     */
    async mergeIfcsRaw(requestParameters: MergeIfcsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling mergeIfcs.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling mergeIfcs.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling mergeIfcs.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/merge`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IfcMergeToJSON(requestParameters.data),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Only works for IFC files. Merge IFC files. The merged IFC file will be put in the same folder that the first IFC of the list Required scopes: ifc:write, model:write
     * Merge IFC files
     */
    async mergeIfcs(requestParameters: MergeIfcsRequest): Promise<void> {
        await this.mergeIfcsRaw(requestParameters);
    }

    /**
     * Only works for IFC files. Optimize the IFC. A new optimized IFC file will be put in the same folder that the original IFC Required scopes: ifc:write, model:write
     * Optimize the IFC
     */
    async optimizeIfcRaw(requestParameters: OptimizeIfcRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling optimizeIfc.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling optimizeIfc.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling optimizeIfc.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling optimizeIfc.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}/optimize`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IfcOptimizeToJSON(requestParameters.data),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Only works for IFC files. Optimize the IFC. A new optimized IFC file will be put in the same folder that the original IFC Required scopes: ifc:write, model:write
     * Optimize the IFC
     */
    async optimizeIfc(requestParameters: OptimizeIfcRequest): Promise<void> {
        await this.optimizeIfcRaw(requestParameters);
    }

    /**
     * Remove all property sets from element. Property Sets will not be deleted, just detached from element Required scopes: ifc:write, model:write
     * Remove all property sets from element
     */
    async removeAllElementPropertySetRaw(requestParameters: RemoveAllElementPropertySetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeAllElementPropertySet.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeAllElementPropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeAllElementPropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeAllElementPropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/all`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove all property sets from element. Property Sets will not be deleted, just detached from element Required scopes: ifc:write, model:write
     * Remove all property sets from element
     */
    async removeAllElementPropertySet(requestParameters: RemoveAllElementPropertySetRequest): Promise<void> {
        await this.removeAllElementPropertySetRaw(requestParameters);
    }

    /**
     * The classification will not be deleted Required scopes: ifc:write, model:write
     * Remove a classification from an element
     */
    async removeClassificationOfElementRaw(requestParameters: RemoveClassificationOfElementRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeClassificationOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeClassificationOfElement.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeClassificationOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeClassificationOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeClassificationOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/classification/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The classification will not be deleted Required scopes: ifc:write, model:write
     * Remove a classification from an element
     */
    async removeClassificationOfElement(requestParameters: RemoveClassificationOfElementRequest): Promise<void> {
        await this.removeClassificationOfElementRaw(requestParameters);
    }

    /**
     * The document will not be deleted Required scopes: ifc:write, model:write
     * Remove a documents from an element
     */
    async removeDocumentOfElementRaw(requestParameters: RemoveDocumentOfElementRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeDocumentOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeDocumentOfElement.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeDocumentOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeDocumentOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeDocumentOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/documents/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The document will not be deleted Required scopes: ifc:write, model:write
     * Remove a documents from an element
     */
    async removeDocumentOfElement(requestParameters: RemoveDocumentOfElementRequest): Promise<void> {
        await this.removeDocumentOfElementRaw(requestParameters);
    }

    /**
     * Delete the relation between the element and the property set. Does not delete any object Required scopes: ifc:write, model:write
     * Remove a PropertySet from an element
     */
    async removeElementPropertySetRaw(requestParameters: RemoveElementPropertySetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeElementPropertySet.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeElementPropertySet.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeElementPropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeElementPropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeElementPropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the relation between the element and the property set. Does not delete any object Required scopes: ifc:write, model:write
     * Remove a PropertySet from an element
     */
    async removeElementPropertySet(requestParameters: RemoveElementPropertySetRequest): Promise<void> {
        await this.removeElementPropertySetRaw(requestParameters);
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Remove a property from a PropertySet
     */
    async removeElementPropertySetPropertyRaw(requestParameters: RemoveElementPropertySetPropertyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeElementPropertySetProperty.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeElementPropertySetProperty.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeElementPropertySetProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeElementPropertySetProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeElementPropertySetProperty.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling removeElementPropertySetProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Remove a property from a PropertySet
     */
    async removeElementPropertySetProperty(requestParameters: RemoveElementPropertySetPropertyRequest): Promise<void> {
        await this.removeElementPropertySetPropertyRaw(requestParameters);
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Remove a Definition from a Property
     */
    async removeElementPropertySetPropertyDefinitionRaw(requestParameters: RemoveElementPropertySetPropertyDefinitionRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Remove a Definition from a Property
     */
    async removeElementPropertySetPropertyDefinition(requestParameters: RemoveElementPropertySetPropertyDefinitionRequest): Promise<void> {
        await this.removeElementPropertySetPropertyDefinitionRaw(requestParameters);
    }

    /**
     * Remove a Unit from a Definition Required scopes: ifc:write, model:write
     * Remove a Unit from a Definition
     */
    async removeElementPropertySetPropertyDefinitionUnitRaw(requestParameters: RemoveElementPropertySetPropertyDefinitionUnitRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertydefinitionPk === null || requestParameters.propertydefinitionPk === undefined) {
            throw new runtime.RequiredError('propertydefinitionPk','Required parameter requestParameters.propertydefinitionPk was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition/{propertydefinition_pk}/unit/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertydefinition_pk"}}`, encodeURIComponent(String(requestParameters.propertydefinitionPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a Unit from a Definition Required scopes: ifc:write, model:write
     * Remove a Unit from a Definition
     */
    async removeElementPropertySetPropertyDefinitionUnit(requestParameters: RemoveElementPropertySetPropertyDefinitionUnitRequest): Promise<void> {
        await this.removeElementPropertySetPropertyDefinitionUnitRaw(requestParameters);
    }

    /**
     * Remove the classification from all elements. No element nor classification will be deleted Required scopes: ifc:write, model:write
     * Remove the classification from all elements
     */
    async removeElementsFromClassificationRaw(requestParameters: RemoveElementsFromClassificationRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeElementsFromClassification.');
        }

        if (requestParameters.modelClassificationPk === null || requestParameters.modelClassificationPk === undefined) {
            throw new runtime.RequiredError('modelClassificationPk','Required parameter requestParameters.modelClassificationPk was null or undefined when calling removeElementsFromClassification.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeElementsFromClassification.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeElementsFromClassification.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling removeElementsFromClassification.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification/{model_classification_pk}/element/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_classification_pk"}}`, encodeURIComponent(String(requestParameters.modelClassificationPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove the classification from all elements. No element nor classification will be deleted Required scopes: ifc:write, model:write
     * Remove the classification from all elements
     */
    async removeElementsFromClassification(requestParameters: RemoveElementsFromClassificationRequest): Promise<void> {
        await this.removeElementsFromClassificationRaw(requestParameters);
    }

    /**
     * Reprocess the model. All data that are not in the original model files will be lost Required scopes: ifc:write, model:write
     * Reprocess Model file
     */
    async reprocessModelRaw(requestParameters: ReprocessModelRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling reprocessModel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling reprocessModel.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling reprocessModel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}/reprocess`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Reprocess the model. All data that are not in the original model files will be lost Required scopes: ifc:write, model:write
     * Reprocess Model file
     */
    async reprocessModel(requestParameters: ReprocessModelRequest): Promise<void> {
        await this.reprocessModelRaw(requestParameters);
    }

    /**
     * You can update the expiration date or the read_only field Required scopes: ifc:token_manage, model:token_manage
     * Update some fields of a token
     */
    async updateAccessTokenRaw(requestParameters: UpdateAccessTokenRequest): Promise<runtime.ApiResponse<IfcAccessToken>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateAccessToken.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateAccessToken.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling updateAccessToken.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/access_token/{token}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: IfcAccessTokenToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IfcAccessTokenFromJSON(jsonValue));
    }

    /**
     * You can update the expiration date or the read_only field Required scopes: ifc:token_manage, model:token_manage
     * Update some fields of a token
     */
    async updateAccessToken(requestParameters: UpdateAccessTokenRequest): Promise<IfcAccessToken> {
        const response = await this.updateAccessTokenRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of an element. The IFC file will not be updated. The created element will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update some fields of an element
     */
    async updateElementRaw(requestParameters: UpdateElementRequest): Promise<runtime.ApiResponse<Element>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateElement.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateElement.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ElementToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ElementFromJSON(jsonValue));
    }

    /**
     * Update some fields of an element. The IFC file will not be updated. The created element will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update some fields of an element
     */
    async updateElement(requestParameters: UpdateElementRequest): Promise<Element> {
        const response = await this.updateElementRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update a property value from an element. If the element is the only one to have this property, the property will be update in place. If many elements share this property, a new property will be created to replace the property for this element. Keeping the property for all other elements. If you want to update the property of all elements, see updateIfcProperty Required scopes: ifc:write, model:write
     * Update a property from an element
     */
    async updateElementPropertySetPropertyRaw(requestParameters: UpdateElementPropertySetPropertyRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateElementPropertySetProperty.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling updateElementPropertySetProperty.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateElementPropertySetProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateElementPropertySetProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateElementPropertySetProperty.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling updateElementPropertySetProperty.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateElementPropertySetProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * Update a property value from an element. If the element is the only one to have this property, the property will be update in place. If many elements share this property, a new property will be created to replace the property for this element. Keeping the property for all other elements. If you want to update the property of all elements, see updateIfcProperty Required scopes: ifc:write, model:write
     * Update a property from an element
     */
    async updateElementPropertySetProperty(requestParameters: UpdateElementPropertySetPropertyRequest): Promise<Property> {
        const response = await this.updateElementPropertySetPropertyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a layer. The IFC file will not be updated. The created layer will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update some fields of a layer
     */
    async updateLayerRaw(requestParameters: UpdateLayerRequest): Promise<runtime.ApiResponse<Layer>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateLayer.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateLayer.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateLayer.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateLayer.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateLayer.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/layer/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: LayerToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LayerFromJSON(jsonValue));
    }

    /**
     * Update some fields of a layer. The IFC file will not be updated. The created layer will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update some fields of a layer
     */
    async updateLayer(requestParameters: UpdateLayerRequest): Promise<Layer> {
        const response = await this.updateLayerRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a model Required scopes: ifc:write, model:write
     * Update some fields of a model
     */
    async updateModelRaw(requestParameters: UpdateModelRequest): Promise<runtime.ApiResponse<Model>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateModel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateModel.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateModel.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateModel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ModelToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
    }

    /**
     * Update some fields of a model Required scopes: ifc:write, model:write
     * Update some fields of a model
     */
    async updateModel(requestParameters: UpdateModelRequest): Promise<Model> {
        const response = await this.updateModelRaw(requestParameters);
        return await response.value();
    }

    /**
     *          Patch model files (gltf, structure, svg, etc)  Required scopes: ifc:write, model:write
     * Update models file (gltf, svg, structure, etc)
     */
    async updateModelFilesRaw(requestParameters: UpdateModelFilesRequest): Promise<runtime.ApiResponse<ModelFiles>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateModelFiles.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateModelFiles.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateModelFiles.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.structureFile !== undefined) {
            formParams.append('structure_file', requestParameters.structureFile as any);
        }

        if (requestParameters.systemsFile !== undefined) {
            formParams.append('systems_file', requestParameters.systemsFile as any);
        }

        if (requestParameters.mapFile !== undefined) {
            formParams.append('map_file', requestParameters.mapFile as any);
        }

        if (requestParameters.gltfFile !== undefined) {
            formParams.append('gltf_file', requestParameters.gltfFile as any);
        }

        if (requestParameters.gltfWithOpeningsFile !== undefined) {
            formParams.append('gltf_with_openings_file', requestParameters.gltfWithOpeningsFile as any);
        }

        if (requestParameters.bvhTreeFile !== undefined) {
            formParams.append('bvh_tree_file', requestParameters.bvhTreeFile as any);
        }

        if (requestParameters.viewer360File !== undefined) {
            formParams.append('viewer_360_file', requestParameters.viewer360File as any);
        }

        if (requestParameters.xktFile !== undefined) {
            formParams.append('xkt_file', requestParameters.xktFile as any);
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}/files`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelFilesFromJSON(jsonValue));
    }

    /**
     *          Patch model files (gltf, structure, svg, etc)  Required scopes: ifc:write, model:write
     * Update models file (gltf, svg, structure, etc)
     */
    async updateModelFiles(requestParameters: UpdateModelFilesRequest): Promise<ModelFiles> {
        const response = await this.updateModelFilesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a Property Required scopes: ifc:write, model:write
     * Update some fields of a Property
     */
    async updateModelPropertyRaw(requestParameters: UpdateModelPropertyRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateModelProperty.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateModelProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateModelProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateModelProperty.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateModelProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * Update some fields of a Property Required scopes: ifc:write, model:write
     * Update some fields of a Property
     */
    async updateModelProperty(requestParameters: UpdateModelPropertyRequest): Promise<Property> {
        const response = await this.updateModelPropertyRaw(requestParameters);
        return await response.value();
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Update some fields of many PropertyDefinitions of a model
     */
    async updateModelPropertyDefinitionRaw(requestParameters: UpdateModelPropertyDefinitionRequest): Promise<runtime.ApiResponse<PropertyDefinition>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateModelPropertyDefinition.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateModelPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateModelPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateModelPropertyDefinition.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateModelPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertydefinition/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyDefinitionToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyDefinitionFromJSON(jsonValue));
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Update some fields of many PropertyDefinitions of a model
     */
    async updateModelPropertyDefinition(requestParameters: UpdateModelPropertyDefinitionRequest): Promise<PropertyDefinition> {
        const response = await this.updateModelPropertyDefinitionRaw(requestParameters);
        return await response.value();
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Update some fields of a Unit of a model
     */
    async updateModelUnitRaw(requestParameters: UpdateModelUnitRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateModelUnit.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateModelUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateModelUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateModelUnit.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateModelUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/unit/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UnitToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Update some fields of a Unit of a model
     */
    async updateModelUnit(requestParameters: UpdateModelUnitRequest): Promise<Unit> {
        const response = await this.updateModelUnitRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update the postioning of the plan in the storey Required scopes: ifc:write, model:write
     * Update the postioning of the plan in the storey
     */
    async updatePlanPositioningRaw(requestParameters: UpdatePlanPositioningRequest): Promise<runtime.ApiResponse<PositioningPlan>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updatePlanPositioning.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updatePlanPositioning.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updatePlanPositioning.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updatePlanPositioning.');
        }

        if (requestParameters.storeyPk === null || requestParameters.storeyPk === undefined) {
            throw new runtime.RequiredError('storeyPk','Required parameter requestParameters.storeyPk was null or undefined when calling updatePlanPositioning.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updatePlanPositioning.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{storey_pk}/plan/{id}/positioning`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"storey_pk"}}`, encodeURIComponent(String(requestParameters.storeyPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PositioningPlanToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PositioningPlanFromJSON(jsonValue));
    }

    /**
     * Update the postioning of the plan in the storey Required scopes: ifc:write, model:write
     * Update the postioning of the plan in the storey
     */
    async updatePlanPositioning(requestParameters: UpdatePlanPositioningRequest): Promise<PositioningPlan> {
        const response = await this.updatePlanPositioningRaw(requestParameters);
        return await response.value();
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Update the status of a processor handler
     */
    async updateProcessorHandlerRaw(requestParameters: UpdateProcessorHandlerRequest): Promise<runtime.ApiResponse<ProcessorHandler>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateProcessorHandler.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateProcessorHandler.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateProcessorHandler.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateProcessorHandler.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateProcessorHandler.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/processorhandler/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ProcessorHandlerToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessorHandlerFromJSON(jsonValue));
    }

    /**
     *  Required scopes: ifc:write, model:write
     * Update the status of a processor handler
     */
    async updateProcessorHandler(requestParameters: UpdateProcessorHandlerRequest): Promise<ProcessorHandler> {
        const response = await this.updateProcessorHandlerRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a PropertySet Required scopes: ifc:write, model:write
     * Update some fields of a PropertySet
     */
    async updatePropertySetRaw(requestParameters: UpdatePropertySetRequest): Promise<runtime.ApiResponse<PropertySet>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updatePropertySet.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updatePropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updatePropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updatePropertySet.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updatePropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PropertySetToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertySetFromJSON(jsonValue));
    }

    /**
     * Update some fields of a PropertySet Required scopes: ifc:write, model:write
     * Update some fields of a PropertySet
     */
    async updatePropertySet(requestParameters: UpdatePropertySetRequest): Promise<PropertySet> {
        const response = await this.updatePropertySetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a space. The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update some fields of a space
     */
    async updateSpaceRaw(requestParameters: UpdateSpaceRequest): Promise<runtime.ApiResponse<Space>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateSpace.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateSpace.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/space/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SpaceToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SpaceFromJSON(jsonValue));
    }

    /**
     * Update some fields of a space. The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update some fields of a space
     */
    async updateSpace(requestParameters: UpdateSpaceRequest): Promise<Space> {
        const response = await this.updateSpaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a storey Required scopes: ifc:write, model:write
     * Update some fields of a storey
     */
    async updateStoreyRaw(requestParameters: UpdateStoreyRequest): Promise<runtime.ApiResponse<Storey>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateStorey.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateStorey.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateStorey.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateStorey.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateStorey.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: StoreyToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreyFromJSON(jsonValue));
    }

    /**
     * Update some fields of a storey Required scopes: ifc:write, model:write
     * Update some fields of a storey
     */
    async updateStorey(requestParameters: UpdateStoreyRequest): Promise<Storey> {
        const response = await this.updateStoreyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a system. The IFC file will not be updated. The created system will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update some fields of a system
     */
    async updateSystemRaw(requestParameters: UpdateSystemRequest): Promise<runtime.ApiResponse<System>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateSystem.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateSystem.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateSystem.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateSystem.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateSystem.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/system/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SystemToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SystemFromJSON(jsonValue));
    }

    /**
     * Update some fields of a system. The IFC file will not be updated. The created system will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update some fields of a system
     */
    async updateSystem(requestParameters: UpdateSystemRequest): Promise<System> {
        const response = await this.updateSystemRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a zone. The IFC file will not be updated. The created zone will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update some fields of a zone
     */
    async updateZoneRaw(requestParameters: UpdateZoneRequest): Promise<runtime.ApiResponse<Zone>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateZone.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateZone.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateZone.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateZone.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateZone.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ZoneToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ZoneFromJSON(jsonValue));
    }

    /**
     * Update some fields of a zone. The IFC file will not be updated. The created zone will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update some fields of a zone
     */
    async updateZone(requestParameters: UpdateZoneRequest): Promise<Zone> {
        const response = await this.updateZoneRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update some fields of a space. The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update some fields of a space
     */
    async updateZoneSpaceRaw(requestParameters: UpdateZoneSpaceRequest): Promise<runtime.ApiResponse<ZoneSpace>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateZoneSpace.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateZoneSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateZoneSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateZoneSpace.');
        }

        if (requestParameters.zonePk === null || requestParameters.zonePk === undefined) {
            throw new runtime.RequiredError('zonePk','Required parameter requestParameters.zonePk was null or undefined when calling updateZoneSpace.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling updateZoneSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("bimdata_connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("client_credentials", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{zone_pk}/space/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"zone_pk"}}`, encodeURIComponent(String(requestParameters.zonePk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ZoneSpaceToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ZoneSpaceFromJSON(jsonValue));
    }

    /**
     * Update some fields of a space. The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file Required scopes: ifc:write, model:write
     * Update some fields of a space
     */
    async updateZoneSpace(requestParameters: UpdateZoneSpaceRequest): Promise<ZoneSpace> {
        const response = await this.updateZoneSpaceRaw(requestParameters);
        return await response.value();
    }

}
