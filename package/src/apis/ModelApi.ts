/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1 (v1)
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Building,
    BuildingFromJSON,
    BuildingToJSON,
    Classification,
    ClassificationFromJSON,
    ClassificationToJSON,
    ClassificationRequest,
    ClassificationRequestFromJSON,
    ClassificationRequestToJSON,
    CreateBuildingByNameRequest,
    CreateBuildingByNameRequestFromJSON,
    CreateBuildingByNameRequestToJSON,
    CreateModelRequest,
    CreateModelRequestFromJSON,
    CreateModelRequestToJSON,
    Document,
    DocumentFromJSON,
    DocumentToJSON,
    DocumentWithElementList,
    DocumentWithElementListFromJSON,
    DocumentWithElementListToJSON,
    Element,
    ElementFromJSON,
    ElementToJSON,
    ElementClassificationRelation,
    ElementClassificationRelationFromJSON,
    ElementClassificationRelationToJSON,
    ElementClassificationRelationRequest,
    ElementClassificationRelationRequestFromJSON,
    ElementClassificationRelationRequestToJSON,
    ElementPropertySetRelationRequest,
    ElementPropertySetRelationRequestFromJSON,
    ElementPropertySetRelationRequestToJSON,
    ElementRequest,
    ElementRequestFromJSON,
    ElementRequestToJSON,
    IfcAccessToken,
    IfcAccessTokenFromJSON,
    IfcAccessTokenToJSON,
    IfcAccessTokenRequest,
    IfcAccessTokenRequestFromJSON,
    IfcAccessTokenRequestToJSON,
    IfcExport,
    IfcExportFromJSON,
    IfcExportToJSON,
    IfcExportRequest,
    IfcExportRequestFromJSON,
    IfcExportRequestToJSON,
    IfcMergeRequest,
    IfcMergeRequestFromJSON,
    IfcMergeRequestToJSON,
    IfcOptimizeRequest,
    IfcOptimizeRequestFromJSON,
    IfcOptimizeRequestToJSON,
    Layer,
    LayerFromJSON,
    LayerToJSON,
    LayerRequest,
    LayerRequestFromJSON,
    LayerRequestToJSON,
    Material,
    MaterialFromJSON,
    MaterialToJSON,
    Model,
    ModelFromJSON,
    ModelToJSON,
    ModelErrors,
    ModelErrorsFromJSON,
    ModelErrorsToJSON,
    ModelErrorsRequest,
    ModelErrorsRequestFromJSON,
    ModelErrorsRequestToJSON,
    ModelFiles,
    ModelFilesFromJSON,
    ModelFilesToJSON,
    PatchedElementRequest,
    PatchedElementRequestFromJSON,
    PatchedElementRequestToJSON,
    PatchedIfcAccessTokenRequest,
    PatchedIfcAccessTokenRequestFromJSON,
    PatchedIfcAccessTokenRequestToJSON,
    PatchedLayerRequest,
    PatchedLayerRequestFromJSON,
    PatchedLayerRequestToJSON,
    PatchedModelRequest,
    PatchedModelRequestFromJSON,
    PatchedModelRequestToJSON,
    PatchedPositioningPlanRequest,
    PatchedPositioningPlanRequestFromJSON,
    PatchedPositioningPlanRequestToJSON,
    PatchedProcessorHandlerRequest,
    PatchedProcessorHandlerRequestFromJSON,
    PatchedProcessorHandlerRequestToJSON,
    PatchedPropertyDefinitionRequest,
    PatchedPropertyDefinitionRequestFromJSON,
    PatchedPropertyDefinitionRequestToJSON,
    PatchedPropertyRequest,
    PatchedPropertyRequestFromJSON,
    PatchedPropertyRequestToJSON,
    PatchedPropertySetRequest,
    PatchedPropertySetRequestFromJSON,
    PatchedPropertySetRequestToJSON,
    PatchedSpaceRequest,
    PatchedSpaceRequestFromJSON,
    PatchedSpaceRequestToJSON,
    PatchedSystemRequest,
    PatchedSystemRequestFromJSON,
    PatchedSystemRequestToJSON,
    PatchedUnitRequest,
    PatchedUnitRequestFromJSON,
    PatchedUnitRequestToJSON,
    PatchedZoneRequest,
    PatchedZoneRequestFromJSON,
    PatchedZoneRequestToJSON,
    PatchedZoneSpaceRequest,
    PatchedZoneSpaceRequestFromJSON,
    PatchedZoneSpaceRequestToJSON,
    PositioningPlan,
    PositioningPlanFromJSON,
    PositioningPlanToJSON,
    ProcessorHandler,
    ProcessorHandlerFromJSON,
    ProcessorHandlerToJSON,
    Property,
    PropertyFromJSON,
    PropertyToJSON,
    PropertyDefinition,
    PropertyDefinitionFromJSON,
    PropertyDefinitionToJSON,
    PropertyDefinitionRequest,
    PropertyDefinitionRequestFromJSON,
    PropertyDefinitionRequestToJSON,
    PropertyRequest,
    PropertyRequestFromJSON,
    PropertyRequestToJSON,
    PropertySet,
    PropertySetFromJSON,
    PropertySetToJSON,
    PropertySetRequest,
    PropertySetRequestFromJSON,
    PropertySetRequestToJSON,
    RawElements,
    RawElementsFromJSON,
    RawElementsToJSON,
    RawElementsRequest,
    RawElementsRequestFromJSON,
    RawElementsRequestToJSON,
    SimpleElement,
    SimpleElementFromJSON,
    SimpleElementToJSON,
    Space,
    SpaceFromJSON,
    SpaceToJSON,
    SpaceRequest,
    SpaceRequestFromJSON,
    SpaceRequestToJSON,
    Storey,
    StoreyFromJSON,
    StoreyToJSON,
    System,
    SystemFromJSON,
    SystemToJSON,
    SystemRequest,
    SystemRequestFromJSON,
    SystemRequestToJSON,
    Unit,
    UnitFromJSON,
    UnitToJSON,
    UnitRequest,
    UnitRequestFromJSON,
    UnitRequestToJSON,
    Zone,
    ZoneFromJSON,
    ZoneToJSON,
    ZoneRequest,
    ZoneRequestFromJSON,
    ZoneRequestToJSON,
    ZoneSpace,
    ZoneSpaceFromJSON,
    ZoneSpaceToJSON,
    ZoneSpaceRequest,
    ZoneSpaceRequestFromJSON,
    ZoneSpaceRequestToJSON,
} from '../models';

export interface AddModelErrorsRequest {
    cloudPk: number;
    id: number;
    projectPk: number;
    modelErrorsRequest?: ModelErrorsRequest;
}

export interface BulkDeleteModelClassificationsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface BulkDeleteModelPropertiesRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface BulkDeleteModelPropertyDefinitionsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface BulkDeleteModelUnitsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface BulkDeletePropertySetRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface BulkFullUpdateElementsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    elementRequest: Array<ElementRequest>;
    classification?: string;
    classificationNotation?: string;
    type?: string;
}

export interface BulkFullUpdateModelPropertyRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    propertyRequest: Array<PropertyRequest>;
}

export interface BulkRemoveClassificationsOfElementRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
}

export interface BulkRemoveDocumentsOfElementRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
}

export interface BulkRemoveElementsFromClassificationRequest {
    cloudPk: number;
    modelClassificationPk: number;
    modelPk: number;
    projectPk: number;
}

export interface BulkUpdateElementsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    elementRequest: Array<ElementRequest>;
    classification?: string;
    classificationNotation?: string;
    type?: string;
}

export interface BulkUpdateModelPropertyRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    propertyRequest: Array<PropertyRequest>;
}

export interface CreateAccessTokenRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    ifcAccessTokenRequest?: IfcAccessTokenRequest;
}

export interface CreateBuildingRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface CreateBuildingPlanRequest {
    buildingUuid: string;
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface CreateClassificationElementRelationsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    elementClassificationRelationRequest: Array<ElementClassificationRelationRequest>;
}

export interface CreateClassificationsOfElementRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
    classificationRequest: Array<ClassificationRequest>;
}

export interface CreateElementRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    elementRequest: Array<ElementRequest>;
    classification?: string;
    classificationNotation?: string;
    type?: string;
}

export interface CreateElementPropertySetRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
    propertySetRequest?: PropertySetRequest;
}

export interface CreateElementPropertySetPropertyRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
    propertysetPk: number;
    propertyRequest: PropertyRequest;
}

export interface CreateElementPropertySetPropertyDefinitionRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
    propertyPk: number;
    propertysetPk: number;
    propertyDefinitionRequest?: PropertyDefinitionRequest;
}

export interface CreateElementPropertySetPropertyDefinitionUnitRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
    propertyPk: number;
    propertydefinitionPk: number;
    propertysetPk: number;
    unitRequest: UnitRequest;
}

export interface CreateLayerRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    layerRequest: LayerRequest;
}

export interface CreateMetaBuildingRequest {
    cloudPk: number;
    projectPk: number;
    createBuildingByNameRequest: CreateBuildingByNameRequest;
}

export interface CreateModelOperationRequest {
    cloudPk: number;
    projectPk: number;
    createModelRequest: CreateModelRequest;
}

export interface CreateModelPropertyDefinitionRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    propertyDefinitionRequest: Array<PropertyDefinitionRequest>;
}

export interface CreateModelUnitRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    unitRequest: Array<UnitRequest>;
}

export interface CreatePropertySetRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    propertySetRequest: Array<PropertySetRequest>;
}

export interface CreatePropertySetElementRelationsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    elementPropertySetRelationRequest: Array<ElementPropertySetRelationRequest>;
}

export interface CreateRawElementsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    rawElementsRequest: RawElementsRequest;
}

export interface CreateSpaceRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    spaceRequest: Array<SpaceRequest>;
}

export interface CreateStoreyRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface CreateStoreyPlanRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    storeyUuid: string;
}

export interface CreateSystemRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    systemRequest: SystemRequest;
}

export interface CreateZoneRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    zoneRequest: Array<ZoneRequest>;
    color?: string;
}

export interface CreateZoneSpaceRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    zonePk: number;
    zoneSpaceRequest: ZoneSpaceRequest;
}

export interface DeleteAccessTokenRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    token: string;
}

export interface DeleteBuildingRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
}

export interface DeleteBuildingPlanRequest {
    buildingUuid: string;
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface DeleteElementRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
}

export interface DeleteLayerRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface DeleteModelRequest {
    cloudPk: number;
    id: number;
    projectPk: number;
}

export interface DeleteModelPropertyRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface DeleteModelPropertyDefinitionRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface DeleteModelUnitRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface DeleteModelWithoutDocRequest {
    cloudPk: number;
    id: number;
    projectPk: number;
}

export interface DeletePropertySetRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface DeleteSpaceRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface DeleteStoreyRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
}

export interface DeleteStoreyPlanRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    storeyUuid: string;
}

export interface DeleteSystemRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
}

export interface DeleteZoneRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface DeleteZoneSpaceRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    zonePk: number;
}

export interface ExportIfcRequest {
    cloudPk: number;
    id: number;
    projectPk: number;
    ifcExportRequest: IfcExportRequest;
}

export interface FullUpdateElementRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
    elementRequest: ElementRequest;
}

export interface GetAccessTokenRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    token: string;
}

export interface GetAccessTokensRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetBuildingRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
}

export interface GetBuildingPlanPositioningRequest {
    buildingUuid: string;
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface GetBuildingsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetClassificationsOfElementRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
}

export interface GetDocumentsOfElementRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
}

export interface GetElementRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
}

export interface GetElementLinkedDocumentsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    classification?: string;
    classificationNotation?: string;
    type?: string;
}

export interface GetElementPropertySetRequest {
    cloudPk: number;
    elementUuid: string;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface GetElementPropertySetPropertiesRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
    propertysetPk: number;
}

export interface GetElementPropertySetPropertyRequest {
    cloudPk: number;
    elementUuid: string;
    id: number;
    modelPk: number;
    projectPk: number;
    propertysetPk: number;
}

export interface GetElementPropertySetPropertyDefinitionRequest {
    cloudPk: number;
    elementUuid: string;
    id: number;
    modelPk: number;
    projectPk: number;
    propertyPk: number;
    propertysetPk: number;
}

export interface GetElementPropertySetPropertyDefinitionUnitRequest {
    cloudPk: number;
    elementUuid: string;
    id: number;
    modelPk: number;
    projectPk: number;
    propertyPk: number;
    propertydefinitionPk: number;
    propertysetPk: number;
}

export interface GetElementPropertySetPropertyDefinitionUnitsRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
    propertyPk: number;
    propertydefinitionPk: number;
    propertysetPk: number;
}

export interface GetElementPropertySetPropertyDefinitionsRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
    propertyPk: number;
    propertysetPk: number;
}

export interface GetElementPropertySetsRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
}

export interface GetElementsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    classification?: string;
    classificationNotation?: string;
    type?: string;
}

export interface GetElementsFromClassificationRequest {
    cloudPk: number;
    modelClassificationPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetLayerRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface GetLayersRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetMaterialRequest {
    cloudPk: number;
    elementUuid: string;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface GetMaterialsRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
}

export interface GetModelRequest {
    cloudPk: number;
    id: number;
    projectPk: number;
}

export interface GetModelClassificationsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetModelMaterialRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface GetModelMaterialsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetModelPropertiesRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetModelPropertyRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface GetModelPropertyDefinitionRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface GetModelPropertyDefinitionsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetModelUnitRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface GetModelUnitsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetModelsRequest {
    cloudPk: number;
    projectPk: number;
    source?: GetModelsSourceEnum;
    status?: Array<GetModelsStatusEnum>;
    type?: Array<GetModelsTypeEnum>;
}

export interface GetProcessorHandlerRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface GetProcessorHandlersRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetPropertySetRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface GetPropertySetsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetRawElementsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetSimpleElementRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
}

export interface GetSimpleElementsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetSpaceRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface GetSpacesRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetStoreyRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
}

export interface GetStoreyPlanPositioningRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    storeyUuid: string;
}

export interface GetStoreysRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetSystemRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
}

export interface GetSystemsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface GetZoneRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface GetZoneSpaceRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    zonePk: number;
}

export interface GetZoneSpacesRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    zonePk: number;
}

export interface GetZonesRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    color?: string;
}

export interface LinkDocumentsOfElementRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
}

export interface ListClassificationElementRelationsRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
}

export interface MergeIfcsRequest {
    cloudPk: number;
    projectPk: number;
    ifcMergeRequest: IfcMergeRequest;
}

export interface OptimizeIfcRequest {
    cloudPk: number;
    id: number;
    projectPk: number;
    ifcOptimizeRequest?: IfcOptimizeRequest;
}

export interface RemoveAllElementPropertySetRequest {
    cloudPk: number;
    elementUuid: string;
    modelPk: number;
    projectPk: number;
}

export interface RemoveClassificationOfElementRequest {
    cloudPk: number;
    elementUuid: string;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface RemoveDocumentOfElementRequest {
    cloudPk: number;
    elementUuid: string;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface RemoveElementPropertySetRequest {
    cloudPk: number;
    elementUuid: string;
    id: number;
    modelPk: number;
    projectPk: number;
}

export interface RemoveElementPropertySetPropertyRequest {
    cloudPk: number;
    elementUuid: string;
    id: number;
    modelPk: number;
    projectPk: number;
    propertysetPk: number;
}

export interface RemoveElementPropertySetPropertyDefinitionRequest {
    cloudPk: number;
    elementUuid: string;
    id: number;
    modelPk: number;
    projectPk: number;
    propertyPk: number;
    propertysetPk: number;
}

export interface RemoveElementPropertySetPropertyDefinitionUnitRequest {
    cloudPk: number;
    elementUuid: string;
    id: number;
    modelPk: number;
    projectPk: number;
    propertyPk: number;
    propertydefinitionPk: number;
    propertysetPk: number;
}

export interface RemoveElementsFromClassificationRequest {
    cloudPk: number;
    modelClassificationPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
}

export interface ReprocessModelRequest {
    cloudPk: number;
    id: number;
    projectPk: number;
}

export interface UpdateAccessTokenRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    token: string;
    patchedIfcAccessTokenRequest?: PatchedIfcAccessTokenRequest;
}

export interface UpdateBuildingRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
}

export interface UpdateBuildingPlanPositioningRequest {
    buildingUuid: string;
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    patchedPositioningPlanRequest?: PatchedPositioningPlanRequest;
}

export interface UpdateElementRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
    patchedElementRequest?: PatchedElementRequest;
}

export interface UpdateElementPropertySetPropertyRequest {
    cloudPk: number;
    elementUuid: string;
    id: number;
    modelPk: number;
    projectPk: number;
    propertysetPk: number;
    patchedPropertyRequest?: PatchedPropertyRequest;
}

export interface UpdateLayerRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    patchedLayerRequest?: PatchedLayerRequest;
}

export interface UpdateModelRequest {
    cloudPk: number;
    id: number;
    projectPk: number;
    patchedModelRequest?: PatchedModelRequest;
}

export interface UpdateModelFilesRequest {
    cloudPk: number;
    id: number;
    projectPk: number;
    structureFile?: Blob | null;
    systemsFile?: Blob | null;
    mapFile?: Blob | null;
    gltfFile?: Blob | null;
    gltfWithOpeningsFile?: Blob | null;
    bvhTreeFile?: Blob | null;
    viewer360File?: Blob | null;
    xktFile?: Blob | null;
}

export interface UpdateModelPropertyRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    patchedPropertyRequest?: PatchedPropertyRequest;
}

export interface UpdateModelPropertyDefinitionRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    patchedPropertyDefinitionRequest?: PatchedPropertyDefinitionRequest;
}

export interface UpdateModelUnitRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    patchedUnitRequest?: PatchedUnitRequest;
}

export interface UpdateOrderBuildingPlanRequest {
    buildingUuid: string;
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    requestBody: Array<number>;
}

export interface UpdateOrderStoreyPlanRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    storeyUuid: string;
    requestBody: Array<number>;
}

export interface UpdateOrderStoreysRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    requestBody: Array<string>;
}

export interface UpdateProcessorHandlerRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    patchedProcessorHandlerRequest?: PatchedProcessorHandlerRequest;
}

export interface UpdatePropertySetRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    patchedPropertySetRequest?: PatchedPropertySetRequest;
}

export interface UpdateSpaceRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    patchedSpaceRequest?: PatchedSpaceRequest;
}

export interface UpdateStoreyRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
}

export interface UpdateStoreyPlanPositioningRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    storeyUuid: string;
    patchedPositioningPlanRequest?: PatchedPositioningPlanRequest;
}

export interface UpdateSystemRequest {
    cloudPk: number;
    modelPk: number;
    projectPk: number;
    uuid: string;
    patchedSystemRequest?: PatchedSystemRequest;
}

export interface UpdateZoneRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    patchedZoneRequest?: PatchedZoneRequest;
}

export interface UpdateZoneSpaceRequest {
    cloudPk: number;
    id: number;
    modelPk: number;
    projectPk: number;
    zonePk: number;
    patchedZoneSpaceRequest?: PatchedZoneSpaceRequest;
}

/**
 * 
 */
export class ModelApi extends runtime.BaseAPI {

    /**
     * Model errors are warnings and errors during model process. They alert about missing elements or malformed files  Required scopes: ifc:write, model:write
     * Add errors to model
     */
    async addModelErrorsRaw(requestParameters: AddModelErrorsRequest): Promise<runtime.ApiResponse<ModelErrors>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling addModelErrors.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling addModelErrors.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling addModelErrors.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}/errors`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModelErrorsRequestToJSON(requestParameters.modelErrorsRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelErrorsFromJSON(jsonValue));
    }

    /**
     * Model errors are warnings and errors during model process. They alert about missing elements or malformed files  Required scopes: ifc:write, model:write
     * Add errors to model
     */
    async addModelErrors(cloudPk: number, id: number, projectPk: number, modelErrorsRequest?: ModelErrorsRequest): Promise<ModelErrors> {
        const response = await this.addModelErrorsRaw({ cloudPk: cloudPk, id: id, projectPk: projectPk, modelErrorsRequest: modelErrorsRequest });
        return await response.value();
    }

    /**
     * Delete relation between filtered classifications (eg. /classifications?name=untec) and all mode\'s elements. No classification will be deleted on this endpoint, only the relation between model\'s elements and their classification.  Required scopes: ifc:write, model:write
     * Remove all classifications from model\'s elements
     */
    async bulkDeleteModelClassificationsRaw(requestParameters: BulkDeleteModelClassificationsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkDeleteModelClassifications.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkDeleteModelClassifications.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkDeleteModelClassifications.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification/list_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete relation between filtered classifications (eg. /classifications?name=untec) and all mode\'s elements. No classification will be deleted on this endpoint, only the relation between model\'s elements and their classification.  Required scopes: ifc:write, model:write
     * Remove all classifications from model\'s elements
     */
    async bulkDeleteModelClassifications(cloudPk: number, modelPk: number, projectPk: number): Promise<void> {
        await this.bulkDeleteModelClassificationsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Delete many Property of a model
     */
    async bulkDeleteModelPropertiesRaw(requestParameters: BulkDeleteModelPropertiesRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkDeleteModelProperties.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkDeleteModelProperties.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkDeleteModelProperties.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Delete many Property of a model
     */
    async bulkDeleteModelProperties(cloudPk: number, modelPk: number, projectPk: number): Promise<void> {
        await this.bulkDeleteModelPropertiesRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Delete many PropertyDefinitions of a model
     */
    async bulkDeleteModelPropertyDefinitionsRaw(requestParameters: BulkDeleteModelPropertyDefinitionsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkDeleteModelPropertyDefinitions.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkDeleteModelPropertyDefinitions.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkDeleteModelPropertyDefinitions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertydefinition/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Delete many PropertyDefinitions of a model
     */
    async bulkDeleteModelPropertyDefinitions(cloudPk: number, modelPk: number, projectPk: number): Promise<void> {
        await this.bulkDeleteModelPropertyDefinitionsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Delete many Units of a model
     */
    async bulkDeleteModelUnitsRaw(requestParameters: BulkDeleteModelUnitsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkDeleteModelUnits.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkDeleteModelUnits.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkDeleteModelUnits.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/unit/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Delete many Units of a model
     */
    async bulkDeleteModelUnits(cloudPk: number, modelPk: number, projectPk: number): Promise<void> {
        await this.bulkDeleteModelUnitsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Delete many PropertySet of a model
     */
    async bulkDeletePropertySetRaw(requestParameters: BulkDeletePropertySetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkDeletePropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkDeletePropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkDeletePropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Delete many PropertySet of a model
     */
    async bulkDeletePropertySet(cloudPk: number, modelPk: number, projectPk: number): Promise<void> {
        await this.bulkDeletePropertySetRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     *  Bulk update. Similar to update, but the body should be a list of objects to patch or put The response will be a list (in the same order) of updated objects or of errors if any If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Update many elements at once (only changing fields may be defined)
     */
    async bulkFullUpdateElementsRaw(requestParameters: BulkFullUpdateElementsRequest): Promise<runtime.ApiResponse<Array<Element>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkFullUpdateElements.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkFullUpdateElements.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkFullUpdateElements.');
        }

        if (requestParameters.elementRequest === null || requestParameters.elementRequest === undefined) {
            throw new runtime.RequiredError('elementRequest','Required parameter requestParameters.elementRequest was null or undefined when calling bulkFullUpdateElements.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.classification !== undefined) {
            queryParameters['classification'] = requestParameters.classification;
        }

        if (requestParameters.classificationNotation !== undefined) {
            queryParameters['classification__notation'] = requestParameters.classificationNotation;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/bulk_update`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.elementRequest.map(ElementRequestToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ElementFromJSON));
    }

    /**
     *  Bulk update. Similar to update, but the body should be a list of objects to patch or put The response will be a list (in the same order) of updated objects or of errors if any If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Update many elements at once (only changing fields may be defined)
     */
    async bulkFullUpdateElements(cloudPk: number, modelPk: number, projectPk: number, elementRequest: Array<ElementRequest>, classification?: string, classificationNotation?: string, type?: string): Promise<Array<Element>> {
        const response = await this.bulkFullUpdateElementsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, elementRequest: elementRequest, classification: classification, classificationNotation: classificationNotation, type: type });
        return await response.value();
    }

    /**
     *  Bulk update. Similar to update, but the body should be a list of objects to patch or put The response will be a list (in the same order) of updated objects or of errors if any If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Update some fields of many properties of a model
     */
    async bulkFullUpdateModelPropertyRaw(requestParameters: BulkFullUpdateModelPropertyRequest): Promise<runtime.ApiResponse<Array<Property>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkFullUpdateModelProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkFullUpdateModelProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkFullUpdateModelProperty.');
        }

        if (requestParameters.propertyRequest === null || requestParameters.propertyRequest === undefined) {
            throw new runtime.RequiredError('propertyRequest','Required parameter requestParameters.propertyRequest was null or undefined when calling bulkFullUpdateModelProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property/bulk_update`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.propertyRequest.map(PropertyRequestToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyFromJSON));
    }

    /**
     *  Bulk update. Similar to update, but the body should be a list of objects to patch or put The response will be a list (in the same order) of updated objects or of errors if any If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Update some fields of many properties of a model
     */
    async bulkFullUpdateModelProperty(cloudPk: number, modelPk: number, projectPk: number, propertyRequest: Array<PropertyRequest>): Promise<Array<Property>> {
        const response = await this.bulkFullUpdateModelPropertyRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, propertyRequest: propertyRequest });
        return await response.value();
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Remove many classifications from an element
     */
    async bulkRemoveClassificationsOfElementRaw(requestParameters: BulkRemoveClassificationsOfElementRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkRemoveClassificationsOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling bulkRemoveClassificationsOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkRemoveClassificationsOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkRemoveClassificationsOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/classification/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Remove many classifications from an element
     */
    async bulkRemoveClassificationsOfElement(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number): Promise<void> {
        await this.bulkRemoveClassificationsOfElementRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Remove many documents from an element
     */
    async bulkRemoveDocumentsOfElementRaw(requestParameters: BulkRemoveDocumentsOfElementRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkRemoveDocumentsOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling bulkRemoveDocumentsOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkRemoveDocumentsOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkRemoveDocumentsOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/documents/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Remove many documents from an element
     */
    async bulkRemoveDocumentsOfElement(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number): Promise<void> {
        await this.bulkRemoveDocumentsOfElementRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Remove the classifications from all elements
     */
    async bulkRemoveElementsFromClassificationRaw(requestParameters: BulkRemoveElementsFromClassificationRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkRemoveElementsFromClassification.');
        }

        if (requestParameters.modelClassificationPk === null || requestParameters.modelClassificationPk === undefined) {
            throw new runtime.RequiredError('modelClassificationPk','Required parameter requestParameters.modelClassificationPk was null or undefined when calling bulkRemoveElementsFromClassification.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkRemoveElementsFromClassification.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkRemoveElementsFromClassification.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification/{model_classification_pk}/element/bulk_destroy`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_classification_pk"}}`, encodeURIComponent(String(requestParameters.modelClassificationPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Bulk delete. You must send a list of ids in the body. These ids (or relations with these ids in case of many-to-many relation deletion) will be deleted   Required scopes: ifc:write, model:write
     * Remove the classifications from all elements
     */
    async bulkRemoveElementsFromClassification(cloudPk: number, modelClassificationPk: number, modelPk: number, projectPk: number): Promise<void> {
        await this.bulkRemoveElementsFromClassificationRaw({ cloudPk: cloudPk, modelClassificationPk: modelClassificationPk, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     *  Bulk update. Similar to update, but the body should be a list of objects to patch or put The response will be a list (in the same order) of updated objects or of errors if any If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Update many elements at once (all field must be defined)
     */
    async bulkUpdateElementsRaw(requestParameters: BulkUpdateElementsRequest): Promise<runtime.ApiResponse<Array<Element>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkUpdateElements.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkUpdateElements.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkUpdateElements.');
        }

        if (requestParameters.elementRequest === null || requestParameters.elementRequest === undefined) {
            throw new runtime.RequiredError('elementRequest','Required parameter requestParameters.elementRequest was null or undefined when calling bulkUpdateElements.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.classification !== undefined) {
            queryParameters['classification'] = requestParameters.classification;
        }

        if (requestParameters.classificationNotation !== undefined) {
            queryParameters['classification__notation'] = requestParameters.classificationNotation;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/bulk_update`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.elementRequest.map(ElementRequestToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ElementFromJSON));
    }

    /**
     *  Bulk update. Similar to update, but the body should be a list of objects to patch or put The response will be a list (in the same order) of updated objects or of errors if any If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Update many elements at once (all field must be defined)
     */
    async bulkUpdateElements(cloudPk: number, modelPk: number, projectPk: number, elementRequest: Array<ElementRequest>, classification?: string, classificationNotation?: string, type?: string): Promise<Array<Element>> {
        const response = await this.bulkUpdateElementsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, elementRequest: elementRequest, classification: classification, classificationNotation: classificationNotation, type: type });
        return await response.value();
    }

    /**
     *  Bulk update. Similar to update, but the body should be a list of objects to patch or put The response will be a list (in the same order) of updated objects or of errors if any If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors 
     * Update all fields of many properties of a model
     */
    async bulkUpdateModelPropertyRaw(requestParameters: BulkUpdateModelPropertyRequest): Promise<runtime.ApiResponse<Array<Property>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling bulkUpdateModelProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling bulkUpdateModelProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling bulkUpdateModelProperty.');
        }

        if (requestParameters.propertyRequest === null || requestParameters.propertyRequest === undefined) {
            throw new runtime.RequiredError('propertyRequest','Required parameter requestParameters.propertyRequest was null or undefined when calling bulkUpdateModelProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property/bulk_update`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.propertyRequest.map(PropertyRequestToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyFromJSON));
    }

    /**
     *  Bulk update. Similar to update, but the body should be a list of objects to patch or put The response will be a list (in the same order) of updated objects or of errors if any If at least one update succeeded, the status code will be 200. If every update failed, the status code we\'ll be 400 with the list of errors 
     * Update all fields of many properties of a model
     */
    async bulkUpdateModelProperty(cloudPk: number, modelPk: number, projectPk: number, propertyRequest: Array<PropertyRequest>): Promise<Array<Property>> {
        const response = await this.bulkUpdateModelPropertyRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, propertyRequest: propertyRequest });
        return await response.value();
    }

    /**
     * Tokens are read_only by default and are valid 1 day  Required scopes: ifc:token_manage, model:token_manage
     * Create a token for this model
     */
    async createAccessTokenRaw(requestParameters: CreateAccessTokenRequest): Promise<runtime.ApiResponse<IfcAccessToken>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createAccessToken.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/access_token`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IfcAccessTokenRequestToJSON(requestParameters.ifcAccessTokenRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IfcAccessTokenFromJSON(jsonValue));
    }

    /**
     * Tokens are read_only by default and are valid 1 day  Required scopes: ifc:token_manage, model:token_manage
     * Create a token for this model
     */
    async createAccessToken(cloudPk: number, modelPk: number, projectPk: number, ifcAccessTokenRequest?: IfcAccessTokenRequest): Promise<IfcAccessToken> {
        const response = await this.createAccessTokenRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, ifcAccessTokenRequest: ifcAccessTokenRequest });
        return await response.value();
    }

    /**
     * Create a building of a model.  Required scopes: ifc:write, model:write
     * Create a building of a model
     */
    async createBuildingRaw(requestParameters: CreateBuildingRequest): Promise<runtime.ApiResponse<Building>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createBuilding.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createBuilding.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createBuilding.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/building`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BuildingFromJSON(jsonValue));
    }

    /**
     * Create a building of a model.  Required scopes: ifc:write, model:write
     * Create a building of a model
     */
    async createBuilding(cloudPk: number, modelPk: number, projectPk: number): Promise<Building> {
        const response = await this.createBuildingRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Create a relation between a 2d model and a building. The model type must be one of : (\'DWG\', \'DXF\', \'PDF\', \'JPEG\', \'PNG\')  Required scopes: ifc:write, model:write
     * Create a relation between a 2d model and a building
     */
    async createBuildingPlanRaw(requestParameters: CreateBuildingPlanRequest): Promise<runtime.ApiResponse<Building>> {
        if (requestParameters.buildingUuid === null || requestParameters.buildingUuid === undefined) {
            throw new runtime.RequiredError('buildingUuid','Required parameter requestParameters.buildingUuid was null or undefined when calling createBuildingPlan.');
        }

        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createBuildingPlan.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createBuildingPlan.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createBuildingPlan.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/building/{building_uuid}/plan/add`.replace(`{${"building_uuid"}}`, encodeURIComponent(String(requestParameters.buildingUuid))).replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BuildingFromJSON(jsonValue));
    }

    /**
     * Create a relation between a 2d model and a building. The model type must be one of : (\'DWG\', \'DXF\', \'PDF\', \'JPEG\', \'PNG\')  Required scopes: ifc:write, model:write
     * Create a relation between a 2d model and a building
     */
    async createBuildingPlan(buildingUuid: string, cloudPk: number, modelPk: number, projectPk: number): Promise<Building> {
        const response = await this.createBuildingPlanRaw({ buildingUuid: buildingUuid, cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Create association between existing classification and existing element  Required scopes: ifc:write, model:write
     * Create association between existing classification and existing element
     */
    async createClassificationElementRelationsRaw(requestParameters: CreateClassificationElementRelationsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createClassificationElementRelations.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createClassificationElementRelations.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createClassificationElementRelations.');
        }

        if (requestParameters.elementClassificationRelationRequest === null || requestParameters.elementClassificationRelationRequest === undefined) {
            throw new runtime.RequiredError('elementClassificationRelationRequest','Required parameter requestParameters.elementClassificationRelationRequest was null or undefined when calling createClassificationElementRelations.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification-element`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.elementClassificationRelationRequest.map(ElementClassificationRelationRequestToJSON),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create association between existing classification and existing element  Required scopes: ifc:write, model:write
     * Create association between existing classification and existing element
     */
    async createClassificationElementRelations(cloudPk: number, modelPk: number, projectPk: number, elementClassificationRelationRequest: Array<ElementClassificationRelationRequest>): Promise<void> {
        await this.createClassificationElementRelationsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, elementClassificationRelationRequest: elementClassificationRelationRequest });
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors If classification created already exists, it will just be added to item\'s classifications and will not be duplicated  Required scopes: ifc:write, model:write
     * Create one or many classifications to an element
     */
    async createClassificationsOfElementRaw(requestParameters: CreateClassificationsOfElementRequest): Promise<runtime.ApiResponse<Array<Classification>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createClassificationsOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling createClassificationsOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createClassificationsOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createClassificationsOfElement.');
        }

        if (requestParameters.classificationRequest === null || requestParameters.classificationRequest === undefined) {
            throw new runtime.RequiredError('classificationRequest','Required parameter requestParameters.classificationRequest was null or undefined when calling createClassificationsOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/classification`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.classificationRequest.map(ClassificationRequestToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClassificationFromJSON));
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors If classification created already exists, it will just be added to item\'s classifications and will not be duplicated  Required scopes: ifc:write, model:write
     * Create one or many classifications to an element
     */
    async createClassificationsOfElement(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number, classificationRequest: Array<ClassificationRequest>): Promise<Array<Classification>> {
        const response = await this.createClassificationsOfElementRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk, classificationRequest: classificationRequest });
        return await response.value();
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  The IFC file will not be updated. The created element will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Create an element in the model
     */
    async createElementRaw(requestParameters: CreateElementRequest): Promise<runtime.ApiResponse<Array<Element>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createElement.');
        }

        if (requestParameters.elementRequest === null || requestParameters.elementRequest === undefined) {
            throw new runtime.RequiredError('elementRequest','Required parameter requestParameters.elementRequest was null or undefined when calling createElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.classification !== undefined) {
            queryParameters['classification'] = requestParameters.classification;
        }

        if (requestParameters.classificationNotation !== undefined) {
            queryParameters['classification__notation'] = requestParameters.classificationNotation;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.elementRequest.map(ElementRequestToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ElementFromJSON));
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  The IFC file will not be updated. The created element will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Create an element in the model
     */
    async createElement(cloudPk: number, modelPk: number, projectPk: number, elementRequest: Array<ElementRequest>, classification?: string, classificationNotation?: string, type?: string): Promise<Array<Element>> {
        const response = await this.createElementRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, elementRequest: elementRequest, classification: classification, classificationNotation: classificationNotation, type: type });
        return await response.value();
    }

    /**
     * Create a PropertySets that will be automatically linked to the element  Required scopes: ifc:write, model:write
     * Create a PropertySets to an element
     */
    async createElementPropertySetRaw(requestParameters: CreateElementPropertySetRequest): Promise<runtime.ApiResponse<PropertySet>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createElementPropertySet.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling createElementPropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createElementPropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createElementPropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PropertySetRequestToJSON(requestParameters.propertySetRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertySetFromJSON(jsonValue));
    }

    /**
     * Create a PropertySets that will be automatically linked to the element  Required scopes: ifc:write, model:write
     * Create a PropertySets to an element
     */
    async createElementPropertySet(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number, propertySetRequest?: PropertySetRequest): Promise<PropertySet> {
        const response = await this.createElementPropertySetRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk, propertySetRequest: propertySetRequest });
        return await response.value();
    }

    /**
     * Create a property to a PropertySet  Required scopes: ifc:write, model:write
     * Create a property to a PropertySet
     */
    async createElementPropertySetPropertyRaw(requestParameters: CreateElementPropertySetPropertyRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createElementPropertySetProperty.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling createElementPropertySetProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createElementPropertySetProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createElementPropertySetProperty.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling createElementPropertySetProperty.');
        }

        if (requestParameters.propertyRequest === null || requestParameters.propertyRequest === undefined) {
            throw new runtime.RequiredError('propertyRequest','Required parameter requestParameters.propertyRequest was null or undefined when calling createElementPropertySetProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyRequestToJSON(requestParameters.propertyRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * Create a property to a PropertySet  Required scopes: ifc:write, model:write
     * Create a property to a PropertySet
     */
    async createElementPropertySetProperty(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number, propertysetPk: number, propertyRequest: PropertyRequest): Promise<Property> {
        const response = await this.createElementPropertySetPropertyRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk, propertysetPk: propertysetPk, propertyRequest: propertyRequest });
        return await response.value();
    }

    /**
     * Create a Definition to a Property  Required scopes: ifc:write, model:write
     * Create a Definition to a Property
     */
    async createElementPropertySetPropertyDefinitionRaw(requestParameters: CreateElementPropertySetPropertyDefinitionRequest): Promise<runtime.ApiResponse<PropertyDefinition>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling createElementPropertySetPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyDefinitionRequestToJSON(requestParameters.propertyDefinitionRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyDefinitionFromJSON(jsonValue));
    }

    /**
     * Create a Definition to a Property  Required scopes: ifc:write, model:write
     * Create a Definition to a Property
     */
    async createElementPropertySetPropertyDefinition(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number, propertyPk: number, propertysetPk: number, propertyDefinitionRequest?: PropertyDefinitionRequest): Promise<PropertyDefinition> {
        const response = await this.createElementPropertySetPropertyDefinitionRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk, propertyPk: propertyPk, propertysetPk: propertysetPk, propertyDefinitionRequest: propertyDefinitionRequest });
        return await response.value();
    }

    /**
     * Create a Unit to a Definition  Required scopes: ifc:write, model:write
     * Create a Unit to a Definition
     */
    async createElementPropertySetPropertyDefinitionUnitRaw(requestParameters: CreateElementPropertySetPropertyDefinitionUnitRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertydefinitionPk === null || requestParameters.propertydefinitionPk === undefined) {
            throw new runtime.RequiredError('propertydefinitionPk','Required parameter requestParameters.propertydefinitionPk was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.unitRequest === null || requestParameters.unitRequest === undefined) {
            throw new runtime.RequiredError('unitRequest','Required parameter requestParameters.unitRequest was null or undefined when calling createElementPropertySetPropertyDefinitionUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition/{propertydefinition_pk}/unit`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertydefinition_pk"}}`, encodeURIComponent(String(requestParameters.propertydefinitionPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UnitRequestToJSON(requestParameters.unitRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     * Create a Unit to a Definition  Required scopes: ifc:write, model:write
     * Create a Unit to a Definition
     */
    async createElementPropertySetPropertyDefinitionUnit(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number, propertyPk: number, propertydefinitionPk: number, propertysetPk: number, unitRequest: UnitRequest): Promise<Unit> {
        const response = await this.createElementPropertySetPropertyDefinitionUnitRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk, propertyPk: propertyPk, propertydefinitionPk: propertydefinitionPk, propertysetPk: propertysetPk, unitRequest: unitRequest });
        return await response.value();
    }

    /**
     * The IFC file will not be updated. The created layer will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Create a layer in the model
     */
    async createLayerRaw(requestParameters: CreateLayerRequest): Promise<runtime.ApiResponse<Layer>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createLayer.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createLayer.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createLayer.');
        }

        if (requestParameters.layerRequest === null || requestParameters.layerRequest === undefined) {
            throw new runtime.RequiredError('layerRequest','Required parameter requestParameters.layerRequest was null or undefined when calling createLayer.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/layer`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LayerRequestToJSON(requestParameters.layerRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LayerFromJSON(jsonValue));
    }

    /**
     * The IFC file will not be updated. The created layer will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Create a layer in the model
     */
    async createLayer(cloudPk: number, modelPk: number, projectPk: number, layerRequest: LayerRequest): Promise<Layer> {
        const response = await this.createLayerRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, layerRequest: layerRequest });
        return await response.value();
    }

    /**
     * Create an empty 3D Model to be used in BIMData services  Required scopes: ifc:write, model:write
     * Create an empty 3D Model
     */
    async createMetaBuildingRaw(requestParameters: CreateMetaBuildingRequest): Promise<runtime.ApiResponse<Model>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createMetaBuilding.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createMetaBuilding.');
        }

        if (requestParameters.createBuildingByNameRequest === null || requestParameters.createBuildingByNameRequest === undefined) {
            throw new runtime.RequiredError('createBuildingByNameRequest','Required parameter requestParameters.createBuildingByNameRequest was null or undefined when calling createMetaBuilding.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/create-metabuilding`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateBuildingByNameRequestToJSON(requestParameters.createBuildingByNameRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
    }

    /**
     * Create an empty 3D Model to be used in BIMData services  Required scopes: ifc:write, model:write
     * Create an empty 3D Model
     */
    async createMetaBuilding(cloudPk: number, projectPk: number, createBuildingByNameRequest: CreateBuildingByNameRequest): Promise<Model> {
        const response = await this.createMetaBuildingRaw({ cloudPk: cloudPk, projectPk: projectPk, createBuildingByNameRequest: createBuildingByNameRequest });
        return await response.value();
    }

    /**
     * Make a PDF or Image file a Model to be used in BIMData services. If a model already exists, this route does nothing and returns a 201 with the model  Required scopes: ifc:write, model:write
     * Make a PDF or Image file a Model
     */
    async createModelRaw(requestParameters: CreateModelOperationRequest): Promise<runtime.ApiResponse<Model>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createModel.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createModel.');
        }

        if (requestParameters.createModelRequest === null || requestParameters.createModelRequest === undefined) {
            throw new runtime.RequiredError('createModelRequest','Required parameter requestParameters.createModelRequest was null or undefined when calling createModel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/create-model`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateModelRequestToJSON(requestParameters.createModelRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
    }

    /**
     * Make a PDF or Image file a Model to be used in BIMData services. If a model already exists, this route does nothing and returns a 201 with the model  Required scopes: ifc:write, model:write
     * Make a PDF or Image file a Model
     */
    async createModel(cloudPk: number, projectPk: number, createModelRequest: CreateModelRequest): Promise<Model> {
        const response = await this.createModelRaw({ cloudPk: cloudPk, projectPk: projectPk, createModelRequest: createModelRequest });
        return await response.value();
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Create a PropertyDefinition on the model
     */
    async createModelPropertyDefinitionRaw(requestParameters: CreateModelPropertyDefinitionRequest): Promise<runtime.ApiResponse<Array<PropertyDefinition>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createModelPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createModelPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createModelPropertyDefinition.');
        }

        if (requestParameters.propertyDefinitionRequest === null || requestParameters.propertyDefinitionRequest === undefined) {
            throw new runtime.RequiredError('propertyDefinitionRequest','Required parameter requestParameters.propertyDefinitionRequest was null or undefined when calling createModelPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertydefinition`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.propertyDefinitionRequest.map(PropertyDefinitionRequestToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyDefinitionFromJSON));
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Create a PropertyDefinition on the model
     */
    async createModelPropertyDefinition(cloudPk: number, modelPk: number, projectPk: number, propertyDefinitionRequest: Array<PropertyDefinitionRequest>): Promise<Array<PropertyDefinition>> {
        const response = await this.createModelPropertyDefinitionRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, propertyDefinitionRequest: propertyDefinitionRequest });
        return await response.value();
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Create a Unit on a model
     */
    async createModelUnitRaw(requestParameters: CreateModelUnitRequest): Promise<runtime.ApiResponse<Array<Unit>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createModelUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createModelUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createModelUnit.');
        }

        if (requestParameters.unitRequest === null || requestParameters.unitRequest === undefined) {
            throw new runtime.RequiredError('unitRequest','Required parameter requestParameters.unitRequest was null or undefined when calling createModelUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/unit`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.unitRequest.map(UnitRequestToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UnitFromJSON));
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Create a Unit on a model
     */
    async createModelUnit(cloudPk: number, modelPk: number, projectPk: number, unitRequest: Array<UnitRequest>): Promise<Array<Unit>> {
        const response = await this.createModelUnitRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, unitRequest: unitRequest });
        return await response.value();
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Create one or many PropertySet
     */
    async createPropertySetRaw(requestParameters: CreatePropertySetRequest): Promise<runtime.ApiResponse<Array<PropertySet>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createPropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createPropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createPropertySet.');
        }

        if (requestParameters.propertySetRequest === null || requestParameters.propertySetRequest === undefined) {
            throw new runtime.RequiredError('propertySetRequest','Required parameter requestParameters.propertySetRequest was null or undefined when calling createPropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.propertySetRequest.map(PropertySetRequestToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertySetFromJSON));
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Create one or many PropertySet
     */
    async createPropertySet(cloudPk: number, modelPk: number, projectPk: number, propertySetRequest: Array<PropertySetRequest>): Promise<Array<PropertySet>> {
        const response = await this.createPropertySetRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, propertySetRequest: propertySetRequest });
        return await response.value();
    }

    /**
     * Create association between PropertySet and element  Required scopes: ifc:write, model:write
     * Create association between PropertySet and element
     */
    async createPropertySetElementRelationsRaw(requestParameters: CreatePropertySetElementRelationsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createPropertySetElementRelations.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createPropertySetElementRelations.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createPropertySetElementRelations.');
        }

        if (requestParameters.elementPropertySetRelationRequest === null || requestParameters.elementPropertySetRelationRequest === undefined) {
            throw new runtime.RequiredError('elementPropertySetRelationRequest','Required parameter requestParameters.elementPropertySetRelationRequest was null or undefined when calling createPropertySetElementRelations.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset-element`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.elementPropertySetRelationRequest.map(ElementPropertySetRelationRequestToJSON),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create association between PropertySet and element  Required scopes: ifc:write, model:write
     * Create association between PropertySet and element
     */
    async createPropertySetElementRelations(cloudPk: number, modelPk: number, projectPk: number, elementPropertySetRelationRequest: Array<ElementPropertySetRelationRequest>): Promise<void> {
        await this.createPropertySetElementRelationsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, elementPropertySetRelationRequest: elementPropertySetRelationRequest });
    }

    /**
     * Create many elements in an optimized format to reduce JSON size and avoid redudancy. The IFC file will not be updated. The created elements will be accessible over the API and when exporting an IFC file. You can use the same optimized structure to post multiple elements, property_sets, properties, definitions and units at once. For performance reasons, we do not check the validity of the json. If the json is malformed, an error 500 without more explaination may be returned instead of a 400.  Required scopes: ifc:write, model:write
     * Create elements in an optimized format
     */
    async createRawElementsRaw(requestParameters: CreateRawElementsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createRawElements.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createRawElements.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createRawElements.');
        }

        if (requestParameters.rawElementsRequest === null || requestParameters.rawElementsRequest === undefined) {
            throw new runtime.RequiredError('rawElementsRequest','Required parameter requestParameters.rawElementsRequest was null or undefined when calling createRawElements.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/raw`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RawElementsRequestToJSON(requestParameters.rawElementsRequest),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create many elements in an optimized format to reduce JSON size and avoid redudancy. The IFC file will not be updated. The created elements will be accessible over the API and when exporting an IFC file. You can use the same optimized structure to post multiple elements, property_sets, properties, definitions and units at once. For performance reasons, we do not check the validity of the json. If the json is malformed, an error 500 without more explaination may be returned instead of a 400.  Required scopes: ifc:write, model:write
     * Create elements in an optimized format
     */
    async createRawElements(cloudPk: number, modelPk: number, projectPk: number, rawElementsRequest: RawElementsRequest): Promise<void> {
        await this.createRawElementsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, rawElementsRequest: rawElementsRequest });
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Create a space in the model
     */
    async createSpaceRaw(requestParameters: CreateSpaceRequest): Promise<runtime.ApiResponse<Array<Space>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createSpace.');
        }

        if (requestParameters.spaceRequest === null || requestParameters.spaceRequest === undefined) {
            throw new runtime.RequiredError('spaceRequest','Required parameter requestParameters.spaceRequest was null or undefined when calling createSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/space`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.spaceRequest.map(SpaceRequestToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SpaceFromJSON));
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Create a space in the model
     */
    async createSpace(cloudPk: number, modelPk: number, projectPk: number, spaceRequest: Array<SpaceRequest>): Promise<Array<Space>> {
        const response = await this.createSpaceRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, spaceRequest: spaceRequest });
        return await response.value();
    }

    /**
     * Create a storey of a model.  Required scopes: ifc:write, model:write
     * Create a storey of a model
     */
    async createStoreyRaw(requestParameters: CreateStoreyRequest): Promise<runtime.ApiResponse<Storey>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createStorey.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createStorey.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createStorey.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreyFromJSON(jsonValue));
    }

    /**
     * Create a storey of a model.  Required scopes: ifc:write, model:write
     * Create a storey of a model
     */
    async createStorey(cloudPk: number, modelPk: number, projectPk: number): Promise<Storey> {
        const response = await this.createStoreyRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Create a relation between a 2d model and a storey. The model type must be one of : (\'DWG\', \'DXF\', \'PDF\', \'JPEG\', \'PNG\')  Required scopes: ifc:write, model:write
     * Create a relation between a 2d model and a storey
     */
    async createStoreyPlanRaw(requestParameters: CreateStoreyPlanRequest): Promise<runtime.ApiResponse<Storey>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createStoreyPlan.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createStoreyPlan.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createStoreyPlan.');
        }

        if (requestParameters.storeyUuid === null || requestParameters.storeyUuid === undefined) {
            throw new runtime.RequiredError('storeyUuid','Required parameter requestParameters.storeyUuid was null or undefined when calling createStoreyPlan.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{storey_uuid}/plan/add`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"storey_uuid"}}`, encodeURIComponent(String(requestParameters.storeyUuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreyFromJSON(jsonValue));
    }

    /**
     * Create a relation between a 2d model and a storey. The model type must be one of : (\'DWG\', \'DXF\', \'PDF\', \'JPEG\', \'PNG\')  Required scopes: ifc:write, model:write
     * Create a relation between a 2d model and a storey
     */
    async createStoreyPlan(cloudPk: number, modelPk: number, projectPk: number, storeyUuid: string): Promise<Storey> {
        const response = await this.createStoreyPlanRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, storeyUuid: storeyUuid });
        return await response.value();
    }

    /**
     * The IFC file will not be updated. The created system will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Create a system in the model
     */
    async createSystemRaw(requestParameters: CreateSystemRequest): Promise<runtime.ApiResponse<System>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createSystem.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createSystem.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createSystem.');
        }

        if (requestParameters.systemRequest === null || requestParameters.systemRequest === undefined) {
            throw new runtime.RequiredError('systemRequest','Required parameter requestParameters.systemRequest was null or undefined when calling createSystem.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/system`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SystemRequestToJSON(requestParameters.systemRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SystemFromJSON(jsonValue));
    }

    /**
     * The IFC file will not be updated. The created system will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Create a system in the model
     */
    async createSystem(cloudPk: number, modelPk: number, projectPk: number, systemRequest: SystemRequest): Promise<System> {
        const response = await this.createSystemRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, systemRequest: systemRequest });
        return await response.value();
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  The IFC file will not be updated. The created zone will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Create a zone in the model
     */
    async createZoneRaw(requestParameters: CreateZoneRequest): Promise<runtime.ApiResponse<Array<Zone>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createZone.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createZone.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createZone.');
        }

        if (requestParameters.zoneRequest === null || requestParameters.zoneRequest === undefined) {
            throw new runtime.RequiredError('zoneRequest','Required parameter requestParameters.zoneRequest was null or undefined when calling createZone.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.color !== undefined) {
            queryParameters['color'] = requestParameters.color;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.zoneRequest.map(ZoneRequestToJSON),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ZoneFromJSON));
    }

    /**
     *  Bulk create available. You can either post an object or a list of objects. Is you post a list, the response will be a list (in the same order) of created objects or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors  The IFC file will not be updated. The created zone will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Create a zone in the model
     */
    async createZone(cloudPk: number, modelPk: number, projectPk: number, zoneRequest: Array<ZoneRequest>, color?: string): Promise<Array<Zone>> {
        const response = await this.createZoneRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, zoneRequest: zoneRequest, color: color });
        return await response.value();
    }

    /**
     * The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Create a space in a zone
     */
    async createZoneSpaceRaw(requestParameters: CreateZoneSpaceRequest): Promise<runtime.ApiResponse<ZoneSpace>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling createZoneSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling createZoneSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling createZoneSpace.');
        }

        if (requestParameters.zonePk === null || requestParameters.zonePk === undefined) {
            throw new runtime.RequiredError('zonePk','Required parameter requestParameters.zonePk was null or undefined when calling createZoneSpace.');
        }

        if (requestParameters.zoneSpaceRequest === null || requestParameters.zoneSpaceRequest === undefined) {
            throw new runtime.RequiredError('zoneSpaceRequest','Required parameter requestParameters.zoneSpaceRequest was null or undefined when calling createZoneSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{zone_pk}/space`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"zone_pk"}}`, encodeURIComponent(String(requestParameters.zonePk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ZoneSpaceRequestToJSON(requestParameters.zoneSpaceRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ZoneSpaceFromJSON(jsonValue));
    }

    /**
     * The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Create a space in a zone
     */
    async createZoneSpace(cloudPk: number, modelPk: number, projectPk: number, zonePk: number, zoneSpaceRequest: ZoneSpaceRequest): Promise<ZoneSpace> {
        const response = await this.createZoneSpaceRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, zonePk: zonePk, zoneSpaceRequest: zoneSpaceRequest });
        return await response.value();
    }

    /**
     * Deleting a token will revoke it.  Required scopes: ifc:token_manage, model:token_manage
     * Delete a token
     */
    async deleteAccessTokenRaw(requestParameters: DeleteAccessTokenRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteAccessToken.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteAccessToken.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling deleteAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/access_token/{token}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deleting a token will revoke it.  Required scopes: ifc:token_manage, model:token_manage
     * Delete a token
     */
    async deleteAccessToken(cloudPk: number, modelPk: number, projectPk: number, token: string): Promise<void> {
        await this.deleteAccessTokenRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, token: token });
    }

    /**
     * Delete a building of a model  Required scopes: ifc:write, model:write
     * Delete a building of a model
     */
    async deleteBuildingRaw(requestParameters: DeleteBuildingRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteBuilding.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteBuilding.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteBuilding.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling deleteBuilding.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/building/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a building of a model  Required scopes: ifc:write, model:write
     * Delete a building of a model
     */
    async deleteBuilding(cloudPk: number, modelPk: number, projectPk: number, uuid: string): Promise<void> {
        await this.deleteBuildingRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid });
    }

    /**
     * Delete the relation between a 2d model and a building  Required scopes: ifc:write, model:write
     * Delete the relation between a 2d model and a building
     */
    async deleteBuildingPlanRaw(requestParameters: DeleteBuildingPlanRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.buildingUuid === null || requestParameters.buildingUuid === undefined) {
            throw new runtime.RequiredError('buildingUuid','Required parameter requestParameters.buildingUuid was null or undefined when calling deleteBuildingPlan.');
        }

        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteBuildingPlan.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteBuildingPlan.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteBuildingPlan.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteBuildingPlan.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/building/{building_uuid}/plan/{id}`.replace(`{${"building_uuid"}}`, encodeURIComponent(String(requestParameters.buildingUuid))).replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the relation between a 2d model and a building  Required scopes: ifc:write, model:write
     * Delete the relation between a 2d model and a building
     */
    async deleteBuildingPlan(buildingUuid: string, cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<void> {
        await this.deleteBuildingPlanRaw({ buildingUuid: buildingUuid, cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     * The IFC file will not be updated. The remaining elements are available in API and will be available when exporting an IFC file  Required scopes: ifc:write, model:write
     * Delete an element of a model
     */
    async deleteElementRaw(requestParameters: DeleteElementRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteElement.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling deleteElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The IFC file will not be updated. The remaining elements are available in API and will be available when exporting an IFC file  Required scopes: ifc:write, model:write
     * Delete an element of a model
     */
    async deleteElement(cloudPk: number, modelPk: number, projectPk: number, uuid: string): Promise<void> {
        await this.deleteElementRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid });
    }

    /**
     * The IFC file will not be updated. The remaining layers are available in API and will be available when exporting an IFC file  Required scopes: ifc:write, model:write
     * Delete a layer of a model
     */
    async deleteLayerRaw(requestParameters: DeleteLayerRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteLayer.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteLayer.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteLayer.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteLayer.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/layer/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The IFC file will not be updated. The remaining layers are available in API and will be available when exporting an IFC file  Required scopes: ifc:write, model:write
     * Delete a layer of a model
     */
    async deleteLayer(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<void> {
        await this.deleteLayerRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     * It will also delete the related document  Required scopes: ifc:write, model:write
     * Delete a model
     */
    async deleteModelRaw(requestParameters: DeleteModelRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteModel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteModel.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteModel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * It will also delete the related document  Required scopes: ifc:write, model:write
     * Delete a model
     */
    async deleteModel(cloudPk: number, id: number, projectPk: number): Promise<void> {
        await this.deleteModelRaw({ cloudPk: cloudPk, id: id, projectPk: projectPk });
    }

    /**
     * Delete a Property of a model  Required scopes: ifc:write, model:write
     * Delete a Property of a model
     */
    async deleteModelPropertyRaw(requestParameters: DeleteModelPropertyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteModelProperty.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteModelProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteModelProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteModelProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a Property of a model  Required scopes: ifc:write, model:write
     * Delete a Property of a model
     */
    async deleteModelProperty(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<void> {
        await this.deleteModelPropertyRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     * Delete a PropertyDefinitions of a model  Required scopes: ifc:write, model:write
     * Delete a PropertyDefinitions of a model
     */
    async deleteModelPropertyDefinitionRaw(requestParameters: DeleteModelPropertyDefinitionRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteModelPropertyDefinition.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteModelPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteModelPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteModelPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertydefinition/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a PropertyDefinitions of a model  Required scopes: ifc:write, model:write
     * Delete a PropertyDefinitions of a model
     */
    async deleteModelPropertyDefinition(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<void> {
        await this.deleteModelPropertyDefinitionRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     * Delete a Unit of a model  Required scopes: ifc:write, model:write
     * Delete a Unit of a model
     */
    async deleteModelUnitRaw(requestParameters: DeleteModelUnitRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteModelUnit.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteModelUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteModelUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteModelUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/unit/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a Unit of a model  Required scopes: ifc:write, model:write
     * Delete a Unit of a model
     */
    async deleteModelUnit(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<void> {
        await this.deleteModelUnitRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     * Delete the Model without deleting the related document  Required scopes: ifc:write, model:write
     * Delete the Model without deleting the related document
     */
    async deleteModelWithoutDocRaw(requestParameters: DeleteModelWithoutDocRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteModelWithoutDoc.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteModelWithoutDoc.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteModelWithoutDoc.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}/delete-model`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the Model without deleting the related document  Required scopes: ifc:write, model:write
     * Delete the Model without deleting the related document
     */
    async deleteModelWithoutDoc(cloudPk: number, id: number, projectPk: number): Promise<void> {
        await this.deleteModelWithoutDocRaw({ cloudPk: cloudPk, id: id, projectPk: projectPk });
    }

    /**
     * Delete a PropertySet of a model  Required scopes: ifc:write, model:write
     * Delete a PropertySet of a model
     */
    async deletePropertySetRaw(requestParameters: DeletePropertySetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deletePropertySet.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deletePropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deletePropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deletePropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a PropertySet of a model  Required scopes: ifc:write, model:write
     * Delete a PropertySet of a model
     */
    async deletePropertySet(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<void> {
        await this.deletePropertySetRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     * It will not delete related zones. The IFC file will not be updated. The remaining spaces are available in API and will be available when exporting an IFC file  Required scopes: ifc:write, model:write
     * Delete a space
     */
    async deleteSpaceRaw(requestParameters: DeleteSpaceRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteSpace.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/space/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * It will not delete related zones. The IFC file will not be updated. The remaining spaces are available in API and will be available when exporting an IFC file  Required scopes: ifc:write, model:write
     * Delete a space
     */
    async deleteSpace(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<void> {
        await this.deleteSpaceRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     * Delete a storey of a model  Required scopes: ifc:write, model:write
     * Delete a storey of a model
     */
    async deleteStoreyRaw(requestParameters: DeleteStoreyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteStorey.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteStorey.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteStorey.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling deleteStorey.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a storey of a model  Required scopes: ifc:write, model:write
     * Delete a storey of a model
     */
    async deleteStorey(cloudPk: number, modelPk: number, projectPk: number, uuid: string): Promise<void> {
        await this.deleteStoreyRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid });
    }

    /**
     * Delete the relation between a 2d model and a storey  Required scopes: ifc:write, model:write
     * Delete the relation between a 2d model and a storey
     */
    async deleteStoreyPlanRaw(requestParameters: DeleteStoreyPlanRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteStoreyPlan.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteStoreyPlan.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteStoreyPlan.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteStoreyPlan.');
        }

        if (requestParameters.storeyUuid === null || requestParameters.storeyUuid === undefined) {
            throw new runtime.RequiredError('storeyUuid','Required parameter requestParameters.storeyUuid was null or undefined when calling deleteStoreyPlan.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{storey_uuid}/plan/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"storey_uuid"}}`, encodeURIComponent(String(requestParameters.storeyUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the relation between a 2d model and a storey  Required scopes: ifc:write, model:write
     * Delete the relation between a 2d model and a storey
     */
    async deleteStoreyPlan(cloudPk: number, id: number, modelPk: number, projectPk: number, storeyUuid: string): Promise<void> {
        await this.deleteStoreyPlanRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, storeyUuid: storeyUuid });
    }

    /**
     * The IFC file will not be updated. The remaining systems are available in API and will be available when exporting an IFC file  Required scopes: ifc:write, model:write
     * Delete a system of a model
     */
    async deleteSystemRaw(requestParameters: DeleteSystemRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteSystem.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteSystem.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteSystem.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling deleteSystem.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/system/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The IFC file will not be updated. The remaining systems are available in API and will be available when exporting an IFC file  Required scopes: ifc:write, model:write
     * Delete a system of a model
     */
    async deleteSystem(cloudPk: number, modelPk: number, projectPk: number, uuid: string): Promise<void> {
        await this.deleteSystemRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid });
    }

    /**
     * The IFC file will not be updated. The remaining zones are available in API and will be available when exporting an IFC file  Required scopes: ifc:write, model:write
     * Delete a zone of a model
     */
    async deleteZoneRaw(requestParameters: DeleteZoneRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteZone.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteZone.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteZone.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteZone.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The IFC file will not be updated. The remaining zones are available in API and will be available when exporting an IFC file  Required scopes: ifc:write, model:write
     * Delete a zone of a model
     */
    async deleteZone(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<void> {
        await this.deleteZoneRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     * The IFC file will not be updated. The remaining spaces are available in API and will be available when exporting an IFC file  Required scopes: ifc:write, model:write
     * Delete a space of a zone
     */
    async deleteZoneSpaceRaw(requestParameters: DeleteZoneSpaceRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling deleteZoneSpace.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteZoneSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling deleteZoneSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling deleteZoneSpace.');
        }

        if (requestParameters.zonePk === null || requestParameters.zonePk === undefined) {
            throw new runtime.RequiredError('zonePk','Required parameter requestParameters.zonePk was null or undefined when calling deleteZoneSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{zone_pk}/space/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"zone_pk"}}`, encodeURIComponent(String(requestParameters.zonePk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The IFC file will not be updated. The remaining spaces are available in API and will be available when exporting an IFC file  Required scopes: ifc:write, model:write
     * Delete a space of a zone
     */
    async deleteZoneSpace(cloudPk: number, id: number, modelPk: number, projectPk: number, zonePk: number): Promise<void> {
        await this.deleteZoneSpaceRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, zonePk: zonePk });
    }

    /**
     * Only works for IFC files. Export IFC as requested in parameters. When the export is finished, a new IFC file with will be created in the same folder than the original IFC. You can query the folder or subscribe to the new document webhook to retrieve the result  Required scopes: ifc:write, model:write
     * Export IFC
     */
    async exportIfcRaw(requestParameters: ExportIfcRequest): Promise<runtime.ApiResponse<IfcExport>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling exportIfc.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling exportIfc.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling exportIfc.');
        }

        if (requestParameters.ifcExportRequest === null || requestParameters.ifcExportRequest === undefined) {
            throw new runtime.RequiredError('ifcExportRequest','Required parameter requestParameters.ifcExportRequest was null or undefined when calling exportIfc.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}/export`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IfcExportRequestToJSON(requestParameters.ifcExportRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IfcExportFromJSON(jsonValue));
    }

    /**
     * Only works for IFC files. Export IFC as requested in parameters. When the export is finished, a new IFC file with will be created in the same folder than the original IFC. You can query the folder or subscribe to the new document webhook to retrieve the result  Required scopes: ifc:write, model:write
     * Export IFC
     */
    async exportIfc(cloudPk: number, id: number, projectPk: number, ifcExportRequest: IfcExportRequest): Promise<IfcExport> {
        const response = await this.exportIfcRaw({ cloudPk: cloudPk, id: id, projectPk: projectPk, ifcExportRequest: ifcExportRequest });
        return await response.value();
    }

    /**
     * Update all fields of an element. The IFC file will not be updated. The created element will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update all fields of an element
     */
    async fullUpdateElementRaw(requestParameters: FullUpdateElementRequest): Promise<runtime.ApiResponse<Element>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling fullUpdateElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling fullUpdateElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling fullUpdateElement.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling fullUpdateElement.');
        }

        if (requestParameters.elementRequest === null || requestParameters.elementRequest === undefined) {
            throw new runtime.RequiredError('elementRequest','Required parameter requestParameters.elementRequest was null or undefined when calling fullUpdateElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ElementRequestToJSON(requestParameters.elementRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ElementFromJSON(jsonValue));
    }

    /**
     * Update all fields of an element. The IFC file will not be updated. The created element will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update all fields of an element
     */
    async fullUpdateElement(cloudPk: number, modelPk: number, projectPk: number, uuid: string, elementRequest: ElementRequest): Promise<Element> {
        const response = await this.fullUpdateElementRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid, elementRequest: elementRequest });
        return await response.value();
    }

    /**
     * Retrieve one token created for this model  Required scopes: ifc:token_manage, model:token_manage
     * Retrieve one token created for this model
     */
    async getAccessTokenRaw(requestParameters: GetAccessTokenRequest): Promise<runtime.ApiResponse<IfcAccessToken>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getAccessToken.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getAccessToken.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling getAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/access_token/{token}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IfcAccessTokenFromJSON(jsonValue));
    }

    /**
     * Retrieve one token created for this model  Required scopes: ifc:token_manage, model:token_manage
     * Retrieve one token created for this model
     */
    async getAccessToken(cloudPk: number, modelPk: number, projectPk: number, token: string): Promise<IfcAccessToken> {
        const response = await this.getAccessTokenRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, token: token });
        return await response.value();
    }

    /**
     * Retrieve all tokens created for this model  Required scopes: ifc:token_manage, model:token_manage
     * Retrieve all tokens created for this model
     */
    async getAccessTokensRaw(requestParameters: GetAccessTokensRequest): Promise<runtime.ApiResponse<Array<IfcAccessToken>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getAccessTokens.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getAccessTokens.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getAccessTokens.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/access_token`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(IfcAccessTokenFromJSON));
    }

    /**
     * Retrieve all tokens created for this model  Required scopes: ifc:token_manage, model:token_manage
     * Retrieve all tokens created for this model
     */
    async getAccessTokens(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<IfcAccessToken>> {
        const response = await this.getAccessTokensRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve a building of a model  Required scopes: ifc:read, model:read
     * Retrieve a building of a model
     */
    async getBuildingRaw(requestParameters: GetBuildingRequest): Promise<runtime.ApiResponse<Building>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getBuilding.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getBuilding.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getBuilding.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getBuilding.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/building/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BuildingFromJSON(jsonValue));
    }

    /**
     * Retrieve a building of a model  Required scopes: ifc:read, model:read
     * Retrieve a building of a model
     */
    async getBuilding(cloudPk: number, modelPk: number, projectPk: number, uuid: string): Promise<Building> {
        const response = await this.getBuildingRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid });
        return await response.value();
    }

    /**
     * Retrieve the postioning of the plan in the building  Required scopes: ifc:read, model:read
     * Retrieve the postioning of the plan in the building
     */
    async getBuildingPlanPositioningRaw(requestParameters: GetBuildingPlanPositioningRequest): Promise<runtime.ApiResponse<PositioningPlan>> {
        if (requestParameters.buildingUuid === null || requestParameters.buildingUuid === undefined) {
            throw new runtime.RequiredError('buildingUuid','Required parameter requestParameters.buildingUuid was null or undefined when calling getBuildingPlanPositioning.');
        }

        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getBuildingPlanPositioning.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getBuildingPlanPositioning.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getBuildingPlanPositioning.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getBuildingPlanPositioning.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/building/{building_uuid}/plan/{id}/positioning`.replace(`{${"building_uuid"}}`, encodeURIComponent(String(requestParameters.buildingUuid))).replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PositioningPlanFromJSON(jsonValue));
    }

    /**
     * Retrieve the postioning of the plan in the building  Required scopes: ifc:read, model:read
     * Retrieve the postioning of the plan in the building
     */
    async getBuildingPlanPositioning(buildingUuid: string, cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<PositioningPlan> {
        const response = await this.getBuildingPlanPositioningRaw({ buildingUuid: buildingUuid, cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all buildings of a model.  Required scopes: ifc:read, model:read
     * Retrieve all buildings of a model
     */
    async getBuildingsRaw(requestParameters: GetBuildingsRequest): Promise<runtime.ApiResponse<Array<Building>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getBuildings.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getBuildings.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getBuildings.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/building`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BuildingFromJSON));
    }

    /**
     * Retrieve all buildings of a model.  Required scopes: ifc:read, model:read
     * Retrieve all buildings of a model
     */
    async getBuildings(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<Building>> {
        const response = await this.getBuildingsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all classifications of an element  Required scopes: ifc:read, model:read
     * Retrieve all classifications of an element
     */
    async getClassificationsOfElementRaw(requestParameters: GetClassificationsOfElementRequest): Promise<runtime.ApiResponse<Array<Classification>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getClassificationsOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getClassificationsOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getClassificationsOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getClassificationsOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/classification`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClassificationFromJSON));
    }

    /**
     * Retrieve all classifications of an element  Required scopes: ifc:read, model:read
     * Retrieve all classifications of an element
     */
    async getClassificationsOfElement(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number): Promise<Array<Classification>> {
        const response = await this.getClassificationsOfElementRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all documents of an element  Required scopes: ifc:read, model:read
     * Retrieve all documents of an element
     */
    async getDocumentsOfElementRaw(requestParameters: GetDocumentsOfElementRequest): Promise<runtime.ApiResponse<Array<Document>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getDocumentsOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getDocumentsOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getDocumentsOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getDocumentsOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/documents`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DocumentFromJSON));
    }

    /**
     * Retrieve all documents of an element  Required scopes: ifc:read, model:read
     * Retrieve all documents of an element
     */
    async getDocumentsOfElement(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number): Promise<Array<Document>> {
        const response = await this.getDocumentsOfElementRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve an element of a model  Required scopes: ifc:read, model:read
     * Retrieve an element of a model
     */
    async getElementRaw(requestParameters: GetElementRequest): Promise<runtime.ApiResponse<Element>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElement.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ElementFromJSON(jsonValue));
    }

    /**
     * Retrieve an element of a model  Required scopes: ifc:read, model:read
     * Retrieve an element of a model
     */
    async getElement(cloudPk: number, modelPk: number, projectPk: number, uuid: string): Promise<Element> {
        const response = await this.getElementRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid });
        return await response.value();
    }

    /**
     * Retrieve all documents linked to any element with the list of uuids  Required scopes: ifc:read, model:read
     * Retrieve all documents linked to any element
     */
    async getElementLinkedDocumentsRaw(requestParameters: GetElementLinkedDocumentsRequest): Promise<runtime.ApiResponse<Array<DocumentWithElementList>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementLinkedDocuments.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementLinkedDocuments.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementLinkedDocuments.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.classification !== undefined) {
            queryParameters['classification'] = requestParameters.classification;
        }

        if (requestParameters.classificationNotation !== undefined) {
            queryParameters['classification__notation'] = requestParameters.classificationNotation;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/documents`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DocumentWithElementListFromJSON));
    }

    /**
     * Retrieve all documents linked to any element with the list of uuids  Required scopes: ifc:read, model:read
     * Retrieve all documents linked to any element
     */
    async getElementLinkedDocuments(cloudPk: number, modelPk: number, projectPk: number, classification?: string, classificationNotation?: string, type?: string): Promise<Array<DocumentWithElementList>> {
        const response = await this.getElementLinkedDocumentsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, classification: classification, classificationNotation: classificationNotation, type: type });
        return await response.value();
    }

    /**
     * Retrieve a PropertySet of an element  Required scopes: ifc:read, model:read
     * Retrieve a PropertySet of an element
     */
    async getElementPropertySetRaw(requestParameters: GetElementPropertySetRequest): Promise<runtime.ApiResponse<PropertySet>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySet.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySet.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getElementPropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertySetFromJSON(jsonValue));
    }

    /**
     * Retrieve a PropertySet of an element  Required scopes: ifc:read, model:read
     * Retrieve a PropertySet of an element
     */
    async getElementPropertySet(cloudPk: number, elementUuid: string, id: number, modelPk: number, projectPk: number): Promise<PropertySet> {
        const response = await this.getElementPropertySetRaw({ cloudPk: cloudPk, elementUuid: elementUuid, id: id, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all Properties of a PropertySet  Required scopes: ifc:read, model:read
     * Retrieve all Properties of a PropertySet
     */
    async getElementPropertySetPropertiesRaw(requestParameters: GetElementPropertySetPropertiesRequest): Promise<runtime.ApiResponse<Array<Property>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySetProperties.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySetProperties.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySetProperties.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySetProperties.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling getElementPropertySetProperties.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyFromJSON));
    }

    /**
     * Retrieve all Properties of a PropertySet  Required scopes: ifc:read, model:read
     * Retrieve all Properties of a PropertySet
     */
    async getElementPropertySetProperties(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number, propertysetPk: number): Promise<Array<Property>> {
        const response = await this.getElementPropertySetPropertiesRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk, propertysetPk: propertysetPk });
        return await response.value();
    }

    /**
     * Retrieve a Property of a PropertySet  Required scopes: ifc:read, model:read
     * Retrieve a Property of a PropertySet
     */
    async getElementPropertySetPropertyRaw(requestParameters: GetElementPropertySetPropertyRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySetProperty.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySetProperty.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getElementPropertySetProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySetProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySetProperty.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling getElementPropertySetProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * Retrieve a Property of a PropertySet  Required scopes: ifc:read, model:read
     * Retrieve a Property of a PropertySet
     */
    async getElementPropertySetProperty(cloudPk: number, elementUuid: string, id: number, modelPk: number, projectPk: number, propertysetPk: number): Promise<Property> {
        const response = await this.getElementPropertySetPropertyRaw({ cloudPk: cloudPk, elementUuid: elementUuid, id: id, modelPk: modelPk, projectPk: projectPk, propertysetPk: propertysetPk });
        return await response.value();
    }

    /**
     * Retrieve a Definition of a Property  Required scopes: ifc:read, model:read
     * Retrieve a Definition of a Property
     */
    async getElementPropertySetPropertyDefinitionRaw(requestParameters: GetElementPropertySetPropertyDefinitionRequest): Promise<runtime.ApiResponse<PropertyDefinition>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling getElementPropertySetPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyDefinitionFromJSON(jsonValue));
    }

    /**
     * Retrieve a Definition of a Property  Required scopes: ifc:read, model:read
     * Retrieve a Definition of a Property
     */
    async getElementPropertySetPropertyDefinition(cloudPk: number, elementUuid: string, id: number, modelPk: number, projectPk: number, propertyPk: number, propertysetPk: number): Promise<PropertyDefinition> {
        const response = await this.getElementPropertySetPropertyDefinitionRaw({ cloudPk: cloudPk, elementUuid: elementUuid, id: id, modelPk: modelPk, projectPk: projectPk, propertyPk: propertyPk, propertysetPk: propertysetPk });
        return await response.value();
    }

    /**
     * Retrieve a Unit of a Definition  Required scopes: ifc:read, model:read
     * Retrieve a Unit of a Definition
     */
    async getElementPropertySetPropertyDefinitionUnitRaw(requestParameters: GetElementPropertySetPropertyDefinitionUnitRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertydefinitionPk === null || requestParameters.propertydefinitionPk === undefined) {
            throw new runtime.RequiredError('propertydefinitionPk','Required parameter requestParameters.propertydefinitionPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition/{propertydefinition_pk}/unit/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertydefinition_pk"}}`, encodeURIComponent(String(requestParameters.propertydefinitionPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     * Retrieve a Unit of a Definition  Required scopes: ifc:read, model:read
     * Retrieve a Unit of a Definition
     */
    async getElementPropertySetPropertyDefinitionUnit(cloudPk: number, elementUuid: string, id: number, modelPk: number, projectPk: number, propertyPk: number, propertydefinitionPk: number, propertysetPk: number): Promise<Unit> {
        const response = await this.getElementPropertySetPropertyDefinitionUnitRaw({ cloudPk: cloudPk, elementUuid: elementUuid, id: id, modelPk: modelPk, projectPk: projectPk, propertyPk: propertyPk, propertydefinitionPk: propertydefinitionPk, propertysetPk: propertysetPk });
        return await response.value();
    }

    /**
     * Retrieve all Units of a Definition  Required scopes: ifc:read, model:read
     * Retrieve all Units of a Definition
     */
    async getElementPropertySetPropertyDefinitionUnitsRaw(requestParameters: GetElementPropertySetPropertyDefinitionUnitsRequest): Promise<runtime.ApiResponse<Array<Unit>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        if (requestParameters.propertydefinitionPk === null || requestParameters.propertydefinitionPk === undefined) {
            throw new runtime.RequiredError('propertydefinitionPk','Required parameter requestParameters.propertydefinitionPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling getElementPropertySetPropertyDefinitionUnits.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition/{propertydefinition_pk}/unit`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertydefinition_pk"}}`, encodeURIComponent(String(requestParameters.propertydefinitionPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UnitFromJSON));
    }

    /**
     * Retrieve all Units of a Definition  Required scopes: ifc:read, model:read
     * Retrieve all Units of a Definition
     */
    async getElementPropertySetPropertyDefinitionUnits(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number, propertyPk: number, propertydefinitionPk: number, propertysetPk: number): Promise<Array<Unit>> {
        const response = await this.getElementPropertySetPropertyDefinitionUnitsRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk, propertyPk: propertyPk, propertydefinitionPk: propertydefinitionPk, propertysetPk: propertysetPk });
        return await response.value();
    }

    /**
     * Retrieve all Definitions of a PropertySet  Required scopes: ifc:read, model:read
     * Retrieve all Definitions of a PropertySet
     */
    async getElementPropertySetPropertyDefinitionsRaw(requestParameters: GetElementPropertySetPropertyDefinitionsRequest): Promise<runtime.ApiResponse<Array<PropertyDefinition>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySetPropertyDefinitions.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySetPropertyDefinitions.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySetPropertyDefinitions.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySetPropertyDefinitions.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling getElementPropertySetPropertyDefinitions.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling getElementPropertySetPropertyDefinitions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyDefinitionFromJSON));
    }

    /**
     * Retrieve all Definitions of a PropertySet  Required scopes: ifc:read, model:read
     * Retrieve all Definitions of a PropertySet
     */
    async getElementPropertySetPropertyDefinitions(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number, propertyPk: number, propertysetPk: number): Promise<Array<PropertyDefinition>> {
        const response = await this.getElementPropertySetPropertyDefinitionsRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk, propertyPk: propertyPk, propertysetPk: propertysetPk });
        return await response.value();
    }

    /**
     * Retrieve all PropertySets of an element  Required scopes: ifc:read, model:read
     * Retrieve all PropertySets of an element
     */
    async getElementPropertySetsRaw(requestParameters: GetElementPropertySetsRequest): Promise<runtime.ApiResponse<Array<PropertySet>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementPropertySets.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getElementPropertySets.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementPropertySets.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementPropertySets.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertySetFromJSON));
    }

    /**
     * Retrieve all PropertySets of an element  Required scopes: ifc:read, model:read
     * Retrieve all PropertySets of an element
     */
    async getElementPropertySets(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number): Promise<Array<PropertySet>> {
        const response = await this.getElementPropertySetsRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all elements of a model. If not filtered, the json may be very large. To efficently retrieve all elements and their data, see getRawElements  Required scopes: ifc:read, model:read
     * Retrieve all elements of a model
     */
    async getElementsRaw(requestParameters: GetElementsRequest): Promise<runtime.ApiResponse<Array<Element>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElements.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElements.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElements.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.classification !== undefined) {
            queryParameters['classification'] = requestParameters.classification;
        }

        if (requestParameters.classificationNotation !== undefined) {
            queryParameters['classification__notation'] = requestParameters.classificationNotation;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ElementFromJSON));
    }

    /**
     * Retrieve all elements of a model. If not filtered, the json may be very large. To efficently retrieve all elements and their data, see getRawElements  Required scopes: ifc:read, model:read
     * Retrieve all elements of a model
     */
    async getElements(cloudPk: number, modelPk: number, projectPk: number, classification?: string, classificationNotation?: string, type?: string): Promise<Array<Element>> {
        const response = await this.getElementsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, classification: classification, classificationNotation: classificationNotation, type: type });
        return await response.value();
    }

    /**
     * Retrieve all elements with the classification  Required scopes: ifc:read, model:read
     * Retrieve all elements with the classification
     */
    async getElementsFromClassificationRaw(requestParameters: GetElementsFromClassificationRequest): Promise<runtime.ApiResponse<Array<Element>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getElementsFromClassification.');
        }

        if (requestParameters.modelClassificationPk === null || requestParameters.modelClassificationPk === undefined) {
            throw new runtime.RequiredError('modelClassificationPk','Required parameter requestParameters.modelClassificationPk was null or undefined when calling getElementsFromClassification.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getElementsFromClassification.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getElementsFromClassification.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification/{model_classification_pk}/element`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_classification_pk"}}`, encodeURIComponent(String(requestParameters.modelClassificationPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ElementFromJSON));
    }

    /**
     * Retrieve all elements with the classification  Required scopes: ifc:read, model:read
     * Retrieve all elements with the classification
     */
    async getElementsFromClassification(cloudPk: number, modelClassificationPk: number, modelPk: number, projectPk: number): Promise<Array<Element>> {
        const response = await this.getElementsFromClassificationRaw({ cloudPk: cloudPk, modelClassificationPk: modelClassificationPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve a layer of a model  Required scopes: ifc:read, model:read
     * Retrieve a layer of a model
     */
    async getLayerRaw(requestParameters: GetLayerRequest): Promise<runtime.ApiResponse<Layer>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getLayer.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getLayer.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getLayer.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getLayer.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/layer/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LayerFromJSON(jsonValue));
    }

    /**
     * Retrieve a layer of a model  Required scopes: ifc:read, model:read
     * Retrieve a layer of a model
     */
    async getLayer(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<Layer> {
        const response = await this.getLayerRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all layers of a model.  Required scopes: ifc:read, model:read
     * Retrieve all layers of a model
     */
    async getLayersRaw(requestParameters: GetLayersRequest): Promise<runtime.ApiResponse<Array<Layer>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getLayers.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getLayers.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getLayers.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/layer`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LayerFromJSON));
    }

    /**
     * Retrieve all layers of a model.  Required scopes: ifc:read, model:read
     * Retrieve all layers of a model
     */
    async getLayers(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<Layer>> {
        const response = await this.getLayersRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve a material of a model  Required scopes: ifc:read, model:read
     * Retrieve a material of a model
     */
    async getMaterialRaw(requestParameters: GetMaterialRequest): Promise<runtime.ApiResponse<Material>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getMaterial.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getMaterial.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getMaterial.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getMaterial.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getMaterial.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/material/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MaterialFromJSON(jsonValue));
    }

    /**
     * Retrieve a material of a model  Required scopes: ifc:read, model:read
     * Retrieve a material of a model
     */
    async getMaterial(cloudPk: number, elementUuid: string, id: number, modelPk: number, projectPk: number): Promise<Material> {
        const response = await this.getMaterialRaw({ cloudPk: cloudPk, elementUuid: elementUuid, id: id, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all materials of a model.  Required scopes: ifc:read, model:read
     * Retrieve all materials of a model
     */
    async getMaterialsRaw(requestParameters: GetMaterialsRequest): Promise<runtime.ApiResponse<Array<Material>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getMaterials.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling getMaterials.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getMaterials.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getMaterials.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/material`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MaterialFromJSON));
    }

    /**
     * Retrieve all materials of a model.  Required scopes: ifc:read, model:read
     * Retrieve all materials of a model
     */
    async getMaterials(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number): Promise<Array<Material>> {
        const response = await this.getMaterialsRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve one model  Required scopes: ifc:read, model:read
     * Retrieve one model
     */
    async getModelRaw(requestParameters: GetModelRequest): Promise<runtime.ApiResponse<Model>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getModel.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
    }

    /**
     * Retrieve one model  Required scopes: ifc:read, model:read
     * Retrieve one model
     */
    async getModel(cloudPk: number, id: number, projectPk: number): Promise<Model> {
        const response = await this.getModelRaw({ cloudPk: cloudPk, id: id, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all classifications in a model  Required scopes: ifc:read, model:read
     * Retrieve all classifications in a model
     */
    async getModelClassificationsRaw(requestParameters: GetModelClassificationsRequest): Promise<runtime.ApiResponse<Array<Classification>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelClassifications.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelClassifications.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelClassifications.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClassificationFromJSON));
    }

    /**
     * Retrieve all classifications in a model  Required scopes: ifc:read, model:read
     * Retrieve all classifications in a model
     */
    async getModelClassifications(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<Classification>> {
        const response = await this.getModelClassificationsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve a material of a model  Required scopes: ifc:read, model:read
     * Retrieve a material of a model
     */
    async getModelMaterialRaw(requestParameters: GetModelMaterialRequest): Promise<runtime.ApiResponse<Material>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelMaterial.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getModelMaterial.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelMaterial.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelMaterial.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/material/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MaterialFromJSON(jsonValue));
    }

    /**
     * Retrieve a material of a model  Required scopes: ifc:read, model:read
     * Retrieve a material of a model
     */
    async getModelMaterial(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<Material> {
        const response = await this.getModelMaterialRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all materials of a model.  Required scopes: ifc:read, model:read
     * Retrieve all materials of a model
     */
    async getModelMaterialsRaw(requestParameters: GetModelMaterialsRequest): Promise<runtime.ApiResponse<Array<Material>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelMaterials.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelMaterials.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelMaterials.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/material`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MaterialFromJSON));
    }

    /**
     * Retrieve all materials of a model.  Required scopes: ifc:read, model:read
     * Retrieve all materials of a model
     */
    async getModelMaterials(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<Material>> {
        const response = await this.getModelMaterialsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all PropertySets of a model  Required scopes: ifc:read, model:read
     * Retrieve all Properties of a model
     */
    async getModelPropertiesRaw(requestParameters: GetModelPropertiesRequest): Promise<runtime.ApiResponse<Array<Property>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelProperties.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelProperties.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelProperties.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyFromJSON));
    }

    /**
     * Retrieve all PropertySets of a model  Required scopes: ifc:read, model:read
     * Retrieve all Properties of a model
     */
    async getModelProperties(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<Property>> {
        const response = await this.getModelPropertiesRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve a Property of a model  Required scopes: ifc:read, model:read
     * Retrieve a Property of a model
     */
    async getModelPropertyRaw(requestParameters: GetModelPropertyRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelProperty.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getModelProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * Retrieve a Property of a model  Required scopes: ifc:read, model:read
     * Retrieve a Property of a model
     */
    async getModelProperty(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<Property> {
        const response = await this.getModelPropertyRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve a PropertyDefinition of a model  Required scopes: ifc:read, model:read
     * Retrieve a PropertyDefinition of a model
     */
    async getModelPropertyDefinitionRaw(requestParameters: GetModelPropertyDefinitionRequest): Promise<runtime.ApiResponse<PropertyDefinition>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelPropertyDefinition.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getModelPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertydefinition/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyDefinitionFromJSON(jsonValue));
    }

    /**
     * Retrieve a PropertyDefinition of a model  Required scopes: ifc:read, model:read
     * Retrieve a PropertyDefinition of a model
     */
    async getModelPropertyDefinition(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<PropertyDefinition> {
        const response = await this.getModelPropertyDefinitionRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all PropertyDefinitions of a model  Required scopes: ifc:read, model:read
     * Retrieve all PropertyDefinitions of a model
     */
    async getModelPropertyDefinitionsRaw(requestParameters: GetModelPropertyDefinitionsRequest): Promise<runtime.ApiResponse<Array<PropertyDefinition>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelPropertyDefinitions.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelPropertyDefinitions.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelPropertyDefinitions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertydefinition`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyDefinitionFromJSON));
    }

    /**
     * Retrieve all PropertyDefinitions of a model  Required scopes: ifc:read, model:read
     * Retrieve all PropertyDefinitions of a model
     */
    async getModelPropertyDefinitions(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<PropertyDefinition>> {
        const response = await this.getModelPropertyDefinitionsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve a Unit of a model  Required scopes: ifc:read, model:read
     * Retrieve a Unit of a model
     */
    async getModelUnitRaw(requestParameters: GetModelUnitRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelUnit.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getModelUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/unit/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     * Retrieve a Unit of a model  Required scopes: ifc:read, model:read
     * Retrieve a Unit of a model
     */
    async getModelUnit(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<Unit> {
        const response = await this.getModelUnitRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all Units of a model  Required scopes: ifc:read, model:read
     * Retrieve all Units of a model
     */
    async getModelUnitsRaw(requestParameters: GetModelUnitsRequest): Promise<runtime.ApiResponse<Array<Unit>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModelUnits.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getModelUnits.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModelUnits.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/unit`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UnitFromJSON));
    }

    /**
     * Retrieve all Units of a model  Required scopes: ifc:read, model:read
     * Retrieve all Units of a model
     */
    async getModelUnits(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<Unit>> {
        const response = await this.getModelUnitsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all models. The field `type` allows you to discriminate which kind of model it is.  Required scopes: ifc:read, model:read
     * Retrieve all models
     */
    async getModelsRaw(requestParameters: GetModelsRequest): Promise<runtime.ApiResponse<Array<Model>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getModels.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getModels.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.source !== undefined) {
            queryParameters['source'] = requestParameters.source;
        }

        if (requestParameters.status) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.type) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ModelFromJSON));
    }

    /**
     * Retrieve all models. The field `type` allows you to discriminate which kind of model it is.  Required scopes: ifc:read, model:read
     * Retrieve all models
     */
    async getModels(cloudPk: number, projectPk: number, source?: GetModelsSourceEnum, status?: Array<GetModelsStatusEnum>, type?: Array<GetModelsTypeEnum>): Promise<Array<Model>> {
        const response = await this.getModelsRaw({ cloudPk: cloudPk, projectPk: projectPk, source: source, status: status, type: type });
        return await response.value();
    }

    /**
     * Retrieve a processor handler  Required scopes: ifc:read, model:read
     * Retrieve a processor handler
     */
    async getProcessorHandlerRaw(requestParameters: GetProcessorHandlerRequest): Promise<runtime.ApiResponse<ProcessorHandler>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProcessorHandler.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getProcessorHandler.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getProcessorHandler.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getProcessorHandler.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/processorhandler/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessorHandlerFromJSON(jsonValue));
    }

    /**
     * Retrieve a processor handler  Required scopes: ifc:read, model:read
     * Retrieve a processor handler
     */
    async getProcessorHandler(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<ProcessorHandler> {
        const response = await this.getProcessorHandlerRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Get all processor handlers  Required scopes: ifc:read, model:read
     * Get all processor handlers
     */
    async getProcessorHandlersRaw(requestParameters: GetProcessorHandlersRequest): Promise<runtime.ApiResponse<Array<ProcessorHandler>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getProcessorHandlers.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getProcessorHandlers.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getProcessorHandlers.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/processorhandler`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProcessorHandlerFromJSON));
    }

    /**
     * Get all processor handlers  Required scopes: ifc:read, model:read
     * Get all processor handlers
     */
    async getProcessorHandlers(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<ProcessorHandler>> {
        const response = await this.getProcessorHandlersRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve a PropertySet of a model  Required scopes: ifc:read, model:read
     * Retrieve a PropertySet of a model
     */
    async getPropertySetRaw(requestParameters: GetPropertySetRequest): Promise<runtime.ApiResponse<PropertySet>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getPropertySet.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getPropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getPropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getPropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertySetFromJSON(jsonValue));
    }

    /**
     * Retrieve a PropertySet of a model  Required scopes: ifc:read, model:read
     * Retrieve a PropertySet of a model
     */
    async getPropertySet(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<PropertySet> {
        const response = await this.getPropertySetRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all PropertySets of a model  Required scopes: ifc:read, model:read
     * Retrieve all PropertySets of a model
     */
    async getPropertySetsRaw(requestParameters: GetPropertySetsRequest): Promise<runtime.ApiResponse<Array<PropertySet>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getPropertySets.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getPropertySets.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getPropertySets.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertySetFromJSON));
    }

    /**
     * Retrieve all PropertySets of a model  Required scopes: ifc:read, model:read
     * Retrieve all PropertySets of a model
     */
    async getPropertySets(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<PropertySet>> {
        const response = await this.getPropertySetsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Instead of a nested representation, this route respond with a flat structure and indices pointing to related object. The IFC file will not be updated. The created elements will be accessible over the API and when exporting an IFC file. Returns elements, property_sets, properties, definitions and units in a JSON optimized structure  Required scopes: ifc:read, model:read
     * Retrieve all elements in a optimized format
     */
    async getRawElementsRaw(requestParameters: GetRawElementsRequest): Promise<runtime.ApiResponse<RawElements>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getRawElements.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getRawElements.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getRawElements.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/raw`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RawElementsFromJSON(jsonValue));
    }

    /**
     * Instead of a nested representation, this route respond with a flat structure and indices pointing to related object. The IFC file will not be updated. The created elements will be accessible over the API and when exporting an IFC file. Returns elements, property_sets, properties, definitions and units in a JSON optimized structure  Required scopes: ifc:read, model:read
     * Retrieve all elements in a optimized format
     */
    async getRawElements(cloudPk: number, modelPk: number, projectPk: number): Promise<RawElements> {
        const response = await this.getRawElementsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve an element of a model with a simple value representation  Required scopes: ifc:read, model:read
     * Retrieve an element of a model with a simple value representation
     */
    async getSimpleElementRaw(requestParameters: GetSimpleElementRequest): Promise<runtime.ApiResponse<SimpleElement>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getSimpleElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getSimpleElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getSimpleElement.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getSimpleElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{uuid}/simple`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SimpleElementFromJSON(jsonValue));
    }

    /**
     * Retrieve an element of a model with a simple value representation  Required scopes: ifc:read, model:read
     * Retrieve an element of a model with a simple value representation
     */
    async getSimpleElement(cloudPk: number, modelPk: number, projectPk: number, uuid: string): Promise<SimpleElement> {
        const response = await this.getSimpleElementRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid });
        return await response.value();
    }

    /**
     * Retrieve all elements of a model with a simple value representation  Required scopes: ifc:read, model:read
     * Retrieve all elements of a model with a simple value representation
     */
    async getSimpleElementsRaw(requestParameters: GetSimpleElementsRequest): Promise<runtime.ApiResponse<SimpleElement>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getSimpleElements.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getSimpleElements.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getSimpleElements.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/simple`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SimpleElementFromJSON(jsonValue));
    }

    /**
     * Retrieve all elements of a model with a simple value representation  Required scopes: ifc:read, model:read
     * Retrieve all elements of a model with a simple value representation
     */
    async getSimpleElements(cloudPk: number, modelPk: number, projectPk: number): Promise<SimpleElement> {
        const response = await this.getSimpleElementsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve one space of the model  Required scopes: ifc:read, model:read
     * Retrieve one space of the model
     */
    async getSpaceRaw(requestParameters: GetSpaceRequest): Promise<runtime.ApiResponse<Space>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getSpace.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/space/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SpaceFromJSON(jsonValue));
    }

    /**
     * Retrieve one space of the model  Required scopes: ifc:read, model:read
     * Retrieve one space of the model
     */
    async getSpace(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<Space> {
        const response = await this.getSpaceRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve all spaces of the model  Required scopes: ifc:read, model:read
     * Retrieve all spaces of the model
     */
    async getSpacesRaw(requestParameters: GetSpacesRequest): Promise<runtime.ApiResponse<Array<Space>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getSpaces.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getSpaces.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getSpaces.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/space`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SpaceFromJSON));
    }

    /**
     * Retrieve all spaces of the model  Required scopes: ifc:read, model:read
     * Retrieve all spaces of the model
     */
    async getSpaces(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<Space>> {
        const response = await this.getSpacesRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve a storey of a model  Required scopes: ifc:read, model:read
     * Retrieve a storey of a model
     */
    async getStoreyRaw(requestParameters: GetStoreyRequest): Promise<runtime.ApiResponse<Storey>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getStorey.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getStorey.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getStorey.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getStorey.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreyFromJSON(jsonValue));
    }

    /**
     * Retrieve a storey of a model  Required scopes: ifc:read, model:read
     * Retrieve a storey of a model
     */
    async getStorey(cloudPk: number, modelPk: number, projectPk: number, uuid: string): Promise<Storey> {
        const response = await this.getStoreyRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid });
        return await response.value();
    }

    /**
     * Retrieve the postioning of the plan in the storey  Required scopes: ifc:read, model:read
     * Retrieve the postioning of the plan in the storey
     */
    async getStoreyPlanPositioningRaw(requestParameters: GetStoreyPlanPositioningRequest): Promise<runtime.ApiResponse<PositioningPlan>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getStoreyPlanPositioning.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getStoreyPlanPositioning.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getStoreyPlanPositioning.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getStoreyPlanPositioning.');
        }

        if (requestParameters.storeyUuid === null || requestParameters.storeyUuid === undefined) {
            throw new runtime.RequiredError('storeyUuid','Required parameter requestParameters.storeyUuid was null or undefined when calling getStoreyPlanPositioning.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{storey_uuid}/plan/{id}/positioning`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"storey_uuid"}}`, encodeURIComponent(String(requestParameters.storeyUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PositioningPlanFromJSON(jsonValue));
    }

    /**
     * Retrieve the postioning of the plan in the storey  Required scopes: ifc:read, model:read
     * Retrieve the postioning of the plan in the storey
     */
    async getStoreyPlanPositioning(cloudPk: number, id: number, modelPk: number, projectPk: number, storeyUuid: string): Promise<PositioningPlan> {
        const response = await this.getStoreyPlanPositioningRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, storeyUuid: storeyUuid });
        return await response.value();
    }

    /**
     * Retrieve all storeys of a model.  Required scopes: ifc:read, model:read
     * Retrieve all storeys of a model
     */
    async getStoreysRaw(requestParameters: GetStoreysRequest): Promise<runtime.ApiResponse<Array<Storey>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getStoreys.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getStoreys.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getStoreys.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StoreyFromJSON));
    }

    /**
     * Retrieve all storeys of a model.  Required scopes: ifc:read, model:read
     * Retrieve all storeys of a model
     */
    async getStoreys(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<Storey>> {
        const response = await this.getStoreysRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve a system of a model  Required scopes: ifc:read, model:read
     * Retrieve a system of a model
     */
    async getSystemRaw(requestParameters: GetSystemRequest): Promise<runtime.ApiResponse<System>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getSystem.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getSystem.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getSystem.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getSystem.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/system/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SystemFromJSON(jsonValue));
    }

    /**
     * Retrieve a system of a model  Required scopes: ifc:read, model:read
     * Retrieve a system of a model
     */
    async getSystem(cloudPk: number, modelPk: number, projectPk: number, uuid: string): Promise<System> {
        const response = await this.getSystemRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid });
        return await response.value();
    }

    /**
     * Retrieve all systems of a model.  Required scopes: ifc:read, model:read
     * Retrieve all systems of a model
     */
    async getSystemsRaw(requestParameters: GetSystemsRequest): Promise<runtime.ApiResponse<Array<System>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getSystems.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getSystems.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getSystems.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/system`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SystemFromJSON));
    }

    /**
     * Retrieve all systems of a model.  Required scopes: ifc:read, model:read
     * Retrieve all systems of a model
     */
    async getSystems(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<System>> {
        const response = await this.getSystemsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve one zone of a model  Required scopes: ifc:read, model:read
     * Retrieve one zone of a model
     */
    async getZoneRaw(requestParameters: GetZoneRequest): Promise<runtime.ApiResponse<Zone>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getZone.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getZone.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getZone.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getZone.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ZoneFromJSON(jsonValue));
    }

    /**
     * Retrieve one zone of a model  Required scopes: ifc:read, model:read
     * Retrieve one zone of a model
     */
    async getZone(cloudPk: number, id: number, modelPk: number, projectPk: number): Promise<Zone> {
        const response = await this.getZoneRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Retrieve one space of a zone  Required scopes: ifc:read, model:read
     * Retrieve one space of a zone
     */
    async getZoneSpaceRaw(requestParameters: GetZoneSpaceRequest): Promise<runtime.ApiResponse<ZoneSpace>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getZoneSpace.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getZoneSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getZoneSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getZoneSpace.');
        }

        if (requestParameters.zonePk === null || requestParameters.zonePk === undefined) {
            throw new runtime.RequiredError('zonePk','Required parameter requestParameters.zonePk was null or undefined when calling getZoneSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{zone_pk}/space/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"zone_pk"}}`, encodeURIComponent(String(requestParameters.zonePk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ZoneSpaceFromJSON(jsonValue));
    }

    /**
     * Retrieve one space of a zone  Required scopes: ifc:read, model:read
     * Retrieve one space of a zone
     */
    async getZoneSpace(cloudPk: number, id: number, modelPk: number, projectPk: number, zonePk: number): Promise<ZoneSpace> {
        const response = await this.getZoneSpaceRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, zonePk: zonePk });
        return await response.value();
    }

    /**
     * Retrieve all spaces of a zone  Required scopes: ifc:read, model:read
     * Retrieve all spaces of a zone
     */
    async getZoneSpacesRaw(requestParameters: GetZoneSpacesRequest): Promise<runtime.ApiResponse<Array<ZoneSpace>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getZoneSpaces.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getZoneSpaces.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getZoneSpaces.');
        }

        if (requestParameters.zonePk === null || requestParameters.zonePk === undefined) {
            throw new runtime.RequiredError('zonePk','Required parameter requestParameters.zonePk was null or undefined when calling getZoneSpaces.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{zone_pk}/space`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"zone_pk"}}`, encodeURIComponent(String(requestParameters.zonePk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ZoneSpaceFromJSON));
    }

    /**
     * Retrieve all spaces of a zone  Required scopes: ifc:read, model:read
     * Retrieve all spaces of a zone
     */
    async getZoneSpaces(cloudPk: number, modelPk: number, projectPk: number, zonePk: number): Promise<Array<ZoneSpace>> {
        const response = await this.getZoneSpacesRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, zonePk: zonePk });
        return await response.value();
    }

    /**
     * Retrieve parent zones of a model. Children zones we\'ll be in the \'zones\' field  Required scopes: ifc:read, model:read
     * Retrieve zones of a model
     */
    async getZonesRaw(requestParameters: GetZonesRequest): Promise<runtime.ApiResponse<Array<Zone>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling getZones.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling getZones.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling getZones.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.color !== undefined) {
            queryParameters['color'] = requestParameters.color;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ZoneFromJSON));
    }

    /**
     * Retrieve parent zones of a model. Children zones we\'ll be in the \'zones\' field  Required scopes: ifc:read, model:read
     * Retrieve zones of a model
     */
    async getZones(cloudPk: number, modelPk: number, projectPk: number, color?: string): Promise<Array<Zone>> {
        const response = await this.getZonesRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, color: color });
        return await response.value();
    }

    /**
     *  Bulk relation create available. You can either post an id or a list of ids. Is you post a list, the response will be a list (in the same order) of created relation or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Link one or many documents to an element
     */
    async linkDocumentsOfElementRaw(requestParameters: LinkDocumentsOfElementRequest): Promise<runtime.ApiResponse<Array<Document>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling linkDocumentsOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling linkDocumentsOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling linkDocumentsOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling linkDocumentsOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/documents`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DocumentFromJSON));
    }

    /**
     *  Bulk relation create available. You can either post an id or a list of ids. Is you post a list, the response will be a list (in the same order) of created relation or of errors if any If at least one create succeeded, the status code will be 201. If every create failed, the status code we\'ll be 400 with the list of errors   Required scopes: ifc:write, model:write
     * Link one or many documents to an element
     */
    async linkDocumentsOfElement(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number): Promise<Array<Document>> {
        const response = await this.linkDocumentsOfElementRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * List all associations between classifications and elements  Required scopes: ifc:read, model:read
     * List all associations between classifications and elements
     */
    async listClassificationElementRelationsRaw(requestParameters: ListClassificationElementRelationsRequest): Promise<runtime.ApiResponse<Array<ElementClassificationRelation>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling listClassificationElementRelations.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling listClassificationElementRelations.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling listClassificationElementRelations.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification-element`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ElementClassificationRelationFromJSON));
    }

    /**
     * List all associations between classifications and elements  Required scopes: ifc:read, model:read
     * List all associations between classifications and elements
     */
    async listClassificationElementRelations(cloudPk: number, modelPk: number, projectPk: number): Promise<Array<ElementClassificationRelation>> {
        const response = await this.listClassificationElementRelationsRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk });
        return await response.value();
    }

    /**
     * Only works for IFC files. Merge IFC files. The merged IFC file will be put in the same folder that the first IFC of the list  Required scopes: ifc:write, model:write
     * Merge IFC files
     */
    async mergeIfcsRaw(requestParameters: MergeIfcsRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling mergeIfcs.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling mergeIfcs.');
        }

        if (requestParameters.ifcMergeRequest === null || requestParameters.ifcMergeRequest === undefined) {
            throw new runtime.RequiredError('ifcMergeRequest','Required parameter requestParameters.ifcMergeRequest was null or undefined when calling mergeIfcs.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/merge`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IfcMergeRequestToJSON(requestParameters.ifcMergeRequest),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Only works for IFC files. Merge IFC files. The merged IFC file will be put in the same folder that the first IFC of the list  Required scopes: ifc:write, model:write
     * Merge IFC files
     */
    async mergeIfcs(cloudPk: number, projectPk: number, ifcMergeRequest: IfcMergeRequest): Promise<void> {
        await this.mergeIfcsRaw({ cloudPk: cloudPk, projectPk: projectPk, ifcMergeRequest: ifcMergeRequest });
    }

    /**
     * Only works for IFC files. Optimize the IFC. A new optimized IFC file will be put in the same folder that the original IFC  Required scopes: ifc:write, model:write
     * Optimize the IFC
     */
    async optimizeIfcRaw(requestParameters: OptimizeIfcRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling optimizeIfc.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling optimizeIfc.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling optimizeIfc.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}/optimize`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IfcOptimizeRequestToJSON(requestParameters.ifcOptimizeRequest),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Only works for IFC files. Optimize the IFC. A new optimized IFC file will be put in the same folder that the original IFC  Required scopes: ifc:write, model:write
     * Optimize the IFC
     */
    async optimizeIfc(cloudPk: number, id: number, projectPk: number, ifcOptimizeRequest?: IfcOptimizeRequest): Promise<void> {
        await this.optimizeIfcRaw({ cloudPk: cloudPk, id: id, projectPk: projectPk, ifcOptimizeRequest: ifcOptimizeRequest });
    }

    /**
     * Remove all property sets from element. Property Sets will not be deleted, just detached from element  Required scopes: ifc:write, model:write
     * Remove all property sets from element
     */
    async removeAllElementPropertySetRaw(requestParameters: RemoveAllElementPropertySetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeAllElementPropertySet.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeAllElementPropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeAllElementPropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeAllElementPropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/all`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove all property sets from element. Property Sets will not be deleted, just detached from element  Required scopes: ifc:write, model:write
     * Remove all property sets from element
     */
    async removeAllElementPropertySet(cloudPk: number, elementUuid: string, modelPk: number, projectPk: number): Promise<void> {
        await this.removeAllElementPropertySetRaw({ cloudPk: cloudPk, elementUuid: elementUuid, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     * The classification will not be deleted  Required scopes: ifc:write, model:write
     * Remove a classification from an element
     */
    async removeClassificationOfElementRaw(requestParameters: RemoveClassificationOfElementRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeClassificationOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeClassificationOfElement.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeClassificationOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeClassificationOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeClassificationOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/classification/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The classification will not be deleted  Required scopes: ifc:write, model:write
     * Remove a classification from an element
     */
    async removeClassificationOfElement(cloudPk: number, elementUuid: string, id: number, modelPk: number, projectPk: number): Promise<void> {
        await this.removeClassificationOfElementRaw({ cloudPk: cloudPk, elementUuid: elementUuid, id: id, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     * The document will not be deleted  Required scopes: ifc:write, model:write
     * Remove a documents from an element
     */
    async removeDocumentOfElementRaw(requestParameters: RemoveDocumentOfElementRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeDocumentOfElement.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeDocumentOfElement.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeDocumentOfElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeDocumentOfElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeDocumentOfElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/documents/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The document will not be deleted  Required scopes: ifc:write, model:write
     * Remove a documents from an element
     */
    async removeDocumentOfElement(cloudPk: number, elementUuid: string, id: number, modelPk: number, projectPk: number): Promise<void> {
        await this.removeDocumentOfElementRaw({ cloudPk: cloudPk, elementUuid: elementUuid, id: id, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     * Delete the relation between the element and the property set. Does not delete any object  Required scopes: ifc:write, model:write
     * Remove a PropertySet from an element
     */
    async removeElementPropertySetRaw(requestParameters: RemoveElementPropertySetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeElementPropertySet.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeElementPropertySet.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeElementPropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeElementPropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeElementPropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the relation between the element and the property set. Does not delete any object  Required scopes: ifc:write, model:write
     * Remove a PropertySet from an element
     */
    async removeElementPropertySet(cloudPk: number, elementUuid: string, id: number, modelPk: number, projectPk: number): Promise<void> {
        await this.removeElementPropertySetRaw({ cloudPk: cloudPk, elementUuid: elementUuid, id: id, modelPk: modelPk, projectPk: projectPk });
    }

    /**
     * Remove a property from a PropertySet  Required scopes: ifc:write, model:write
     * Remove a property from a PropertySet
     */
    async removeElementPropertySetPropertyRaw(requestParameters: RemoveElementPropertySetPropertyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeElementPropertySetProperty.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeElementPropertySetProperty.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeElementPropertySetProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeElementPropertySetProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeElementPropertySetProperty.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling removeElementPropertySetProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a property from a PropertySet  Required scopes: ifc:write, model:write
     * Remove a property from a PropertySet
     */
    async removeElementPropertySetProperty(cloudPk: number, elementUuid: string, id: number, modelPk: number, projectPk: number, propertysetPk: number): Promise<void> {
        await this.removeElementPropertySetPropertyRaw({ cloudPk: cloudPk, elementUuid: elementUuid, id: id, modelPk: modelPk, projectPk: projectPk, propertysetPk: propertysetPk });
    }

    /**
     * Delete a Definition to a Property  Required scopes: ifc:write, model:write
     * Delete a Definition to a Property
     */
    async removeElementPropertySetPropertyDefinitionRaw(requestParameters: RemoveElementPropertySetPropertyDefinitionRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling removeElementPropertySetPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a Definition to a Property  Required scopes: ifc:write, model:write
     * Delete a Definition to a Property
     */
    async removeElementPropertySetPropertyDefinition(cloudPk: number, elementUuid: string, id: number, modelPk: number, projectPk: number, propertyPk: number, propertysetPk: number): Promise<void> {
        await this.removeElementPropertySetPropertyDefinitionRaw({ cloudPk: cloudPk, elementUuid: elementUuid, id: id, modelPk: modelPk, projectPk: projectPk, propertyPk: propertyPk, propertysetPk: propertysetPk });
    }

    /**
     * Remove a Unit from a Definition  Required scopes: ifc:write, model:write
     * Remove a Unit from a Definition
     */
    async removeElementPropertySetPropertyDefinitionUnitRaw(requestParameters: RemoveElementPropertySetPropertyDefinitionUnitRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertyPk === null || requestParameters.propertyPk === undefined) {
            throw new runtime.RequiredError('propertyPk','Required parameter requestParameters.propertyPk was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertydefinitionPk === null || requestParameters.propertydefinitionPk === undefined) {
            throw new runtime.RequiredError('propertydefinitionPk','Required parameter requestParameters.propertydefinitionPk was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling removeElementPropertySetPropertyDefinitionUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{property_pk}/propertydefinition/{propertydefinition_pk}/unit/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"property_pk"}}`, encodeURIComponent(String(requestParameters.propertyPk))).replace(`{${"propertydefinition_pk"}}`, encodeURIComponent(String(requestParameters.propertydefinitionPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a Unit from a Definition  Required scopes: ifc:write, model:write
     * Remove a Unit from a Definition
     */
    async removeElementPropertySetPropertyDefinitionUnit(cloudPk: number, elementUuid: string, id: number, modelPk: number, projectPk: number, propertyPk: number, propertydefinitionPk: number, propertysetPk: number): Promise<void> {
        await this.removeElementPropertySetPropertyDefinitionUnitRaw({ cloudPk: cloudPk, elementUuid: elementUuid, id: id, modelPk: modelPk, projectPk: projectPk, propertyPk: propertyPk, propertydefinitionPk: propertydefinitionPk, propertysetPk: propertysetPk });
    }

    /**
     * Remove the classification from all elements. No element nor classification will be deleted  Required scopes: ifc:write, model:write
     * Remove the classification from all elements
     */
    async removeElementsFromClassificationRaw(requestParameters: RemoveElementsFromClassificationRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling removeElementsFromClassification.');
        }

        if (requestParameters.modelClassificationPk === null || requestParameters.modelClassificationPk === undefined) {
            throw new runtime.RequiredError('modelClassificationPk','Required parameter requestParameters.modelClassificationPk was null or undefined when calling removeElementsFromClassification.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling removeElementsFromClassification.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling removeElementsFromClassification.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling removeElementsFromClassification.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/classification/{model_classification_pk}/element/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_classification_pk"}}`, encodeURIComponent(String(requestParameters.modelClassificationPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove the classification from all elements. No element nor classification will be deleted  Required scopes: ifc:write, model:write
     * Remove the classification from all elements
     */
    async removeElementsFromClassification(cloudPk: number, modelClassificationPk: number, modelPk: number, projectPk: number, uuid: string): Promise<void> {
        await this.removeElementsFromClassificationRaw({ cloudPk: cloudPk, modelClassificationPk: modelClassificationPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid });
    }

    /**
     * Reprocess the model. All data that are not in the original model files will be lost  Required scopes: ifc:write, model:write
     * Reprocess Model file
     */
    async reprocessModelRaw(requestParameters: ReprocessModelRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling reprocessModel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling reprocessModel.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling reprocessModel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}/reprocess`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Reprocess the model. All data that are not in the original model files will be lost  Required scopes: ifc:write, model:write
     * Reprocess Model file
     */
    async reprocessModel(cloudPk: number, id: number, projectPk: number): Promise<void> {
        await this.reprocessModelRaw({ cloudPk: cloudPk, id: id, projectPk: projectPk });
    }

    /**
     * You can update the expiration date or the read_only field  Required scopes: ifc:token_manage, model:token_manage
     * Update some fields of a token
     */
    async updateAccessTokenRaw(requestParameters: UpdateAccessTokenRequest): Promise<runtime.ApiResponse<IfcAccessToken>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateAccessToken.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateAccessToken.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateAccessToken.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling updateAccessToken.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/access_token/{token}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedIfcAccessTokenRequestToJSON(requestParameters.patchedIfcAccessTokenRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IfcAccessTokenFromJSON(jsonValue));
    }

    /**
     * You can update the expiration date or the read_only field  Required scopes: ifc:token_manage, model:token_manage
     * Update some fields of a token
     */
    async updateAccessToken(cloudPk: number, modelPk: number, projectPk: number, token: string, patchedIfcAccessTokenRequest?: PatchedIfcAccessTokenRequest): Promise<IfcAccessToken> {
        const response = await this.updateAccessTokenRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, token: token, patchedIfcAccessTokenRequest: patchedIfcAccessTokenRequest });
        return await response.value();
    }

    /**
     * Update some fields of a building  Required scopes: ifc:write, model:write
     * Update some fields of a building
     */
    async updateBuildingRaw(requestParameters: UpdateBuildingRequest): Promise<runtime.ApiResponse<Building>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateBuilding.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateBuilding.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateBuilding.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateBuilding.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/building/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BuildingFromJSON(jsonValue));
    }

    /**
     * Update some fields of a building  Required scopes: ifc:write, model:write
     * Update some fields of a building
     */
    async updateBuilding(cloudPk: number, modelPk: number, projectPk: number, uuid: string): Promise<Building> {
        const response = await this.updateBuildingRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid });
        return await response.value();
    }

    /**
     * Update the postioning of the plan in the building  Required scopes: ifc:write, model:write
     * Update the postioning of the plan in the building
     */
    async updateBuildingPlanPositioningRaw(requestParameters: UpdateBuildingPlanPositioningRequest): Promise<runtime.ApiResponse<PositioningPlan>> {
        if (requestParameters.buildingUuid === null || requestParameters.buildingUuid === undefined) {
            throw new runtime.RequiredError('buildingUuid','Required parameter requestParameters.buildingUuid was null or undefined when calling updateBuildingPlanPositioning.');
        }

        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateBuildingPlanPositioning.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateBuildingPlanPositioning.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateBuildingPlanPositioning.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateBuildingPlanPositioning.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/building/{building_uuid}/plan/{id}/positioning`.replace(`{${"building_uuid"}}`, encodeURIComponent(String(requestParameters.buildingUuid))).replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPositioningPlanRequestToJSON(requestParameters.patchedPositioningPlanRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PositioningPlanFromJSON(jsonValue));
    }

    /**
     * Update the postioning of the plan in the building  Required scopes: ifc:write, model:write
     * Update the postioning of the plan in the building
     */
    async updateBuildingPlanPositioning(buildingUuid: string, cloudPk: number, id: number, modelPk: number, projectPk: number, patchedPositioningPlanRequest?: PatchedPositioningPlanRequest): Promise<PositioningPlan> {
        const response = await this.updateBuildingPlanPositioningRaw({ buildingUuid: buildingUuid, cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, patchedPositioningPlanRequest: patchedPositioningPlanRequest });
        return await response.value();
    }

    /**
     * Update some fields of an element. The IFC file will not be updated. The created element will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update some fields of an element
     */
    async updateElementRaw(requestParameters: UpdateElementRequest): Promise<runtime.ApiResponse<Element>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateElement.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateElement.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateElement.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateElement.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedElementRequestToJSON(requestParameters.patchedElementRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ElementFromJSON(jsonValue));
    }

    /**
     * Update some fields of an element. The IFC file will not be updated. The created element will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update some fields of an element
     */
    async updateElement(cloudPk: number, modelPk: number, projectPk: number, uuid: string, patchedElementRequest?: PatchedElementRequest): Promise<Element> {
        const response = await this.updateElementRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid, patchedElementRequest: patchedElementRequest });
        return await response.value();
    }

    /**
     * Update a property value from an element. If the element is the only one to have this property, the property will be update in place. If many elements share this property, a new property will be created to replace the property for this element. Keeping the property for all other elements. If you want to update the property of all elements, see updateIfcProperty  Required scopes: ifc:write, model:write
     * Update a property from an element
     */
    async updateElementPropertySetPropertyRaw(requestParameters: UpdateElementPropertySetPropertyRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateElementPropertySetProperty.');
        }

        if (requestParameters.elementUuid === null || requestParameters.elementUuid === undefined) {
            throw new runtime.RequiredError('elementUuid','Required parameter requestParameters.elementUuid was null or undefined when calling updateElementPropertySetProperty.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateElementPropertySetProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateElementPropertySetProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateElementPropertySetProperty.');
        }

        if (requestParameters.propertysetPk === null || requestParameters.propertysetPk === undefined) {
            throw new runtime.RequiredError('propertysetPk','Required parameter requestParameters.propertysetPk was null or undefined when calling updateElementPropertySetProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/element/{element_uuid}/propertyset/{propertyset_pk}/property/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"element_uuid"}}`, encodeURIComponent(String(requestParameters.elementUuid))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"propertyset_pk"}}`, encodeURIComponent(String(requestParameters.propertysetPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPropertyRequestToJSON(requestParameters.patchedPropertyRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * Update a property value from an element. If the element is the only one to have this property, the property will be update in place. If many elements share this property, a new property will be created to replace the property for this element. Keeping the property for all other elements. If you want to update the property of all elements, see updateIfcProperty  Required scopes: ifc:write, model:write
     * Update a property from an element
     */
    async updateElementPropertySetProperty(cloudPk: number, elementUuid: string, id: number, modelPk: number, projectPk: number, propertysetPk: number, patchedPropertyRequest?: PatchedPropertyRequest): Promise<Property> {
        const response = await this.updateElementPropertySetPropertyRaw({ cloudPk: cloudPk, elementUuid: elementUuid, id: id, modelPk: modelPk, projectPk: projectPk, propertysetPk: propertysetPk, patchedPropertyRequest: patchedPropertyRequest });
        return await response.value();
    }

    /**
     * Update some fields of a layer. The IFC file will not be updated. The created layer will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update some fields of a layer
     */
    async updateLayerRaw(requestParameters: UpdateLayerRequest): Promise<runtime.ApiResponse<Layer>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateLayer.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateLayer.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateLayer.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateLayer.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/layer/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedLayerRequestToJSON(requestParameters.patchedLayerRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LayerFromJSON(jsonValue));
    }

    /**
     * Update some fields of a layer. The IFC file will not be updated. The created layer will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update some fields of a layer
     */
    async updateLayer(cloudPk: number, id: number, modelPk: number, projectPk: number, patchedLayerRequest?: PatchedLayerRequest): Promise<Layer> {
        const response = await this.updateLayerRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, patchedLayerRequest: patchedLayerRequest });
        return await response.value();
    }

    /**
     * Update some fields of a model  Required scopes: ifc:write, model:write
     * Update some fields of a model
     */
    async updateModelRaw(requestParameters: UpdateModelRequest): Promise<runtime.ApiResponse<Model>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateModel.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateModel.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateModel.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedModelRequestToJSON(requestParameters.patchedModelRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
    }

    /**
     * Update some fields of a model  Required scopes: ifc:write, model:write
     * Update some fields of a model
     */
    async updateModel(cloudPk: number, id: number, projectPk: number, patchedModelRequest?: PatchedModelRequest): Promise<Model> {
        const response = await this.updateModelRaw({ cloudPk: cloudPk, id: id, projectPk: projectPk, patchedModelRequest: patchedModelRequest });
        return await response.value();
    }

    /**
     * This route does not accept JSON, only files as x-www-form-urlencoded  Required scopes: ifc:write, model:write
     * Update models file (gltf, svg, structure, etc)
     */
    async updateModelFilesRaw(requestParameters: UpdateModelFilesRequest): Promise<runtime.ApiResponse<ModelFiles>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateModelFiles.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateModelFiles.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateModelFiles.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.structureFile !== undefined) {
            formParams.append('structure_file', requestParameters.structureFile as any);
        }

        if (requestParameters.systemsFile !== undefined) {
            formParams.append('systems_file', requestParameters.systemsFile as any);
        }

        if (requestParameters.mapFile !== undefined) {
            formParams.append('map_file', requestParameters.mapFile as any);
        }

        if (requestParameters.gltfFile !== undefined) {
            formParams.append('gltf_file', requestParameters.gltfFile as any);
        }

        if (requestParameters.gltfWithOpeningsFile !== undefined) {
            formParams.append('gltf_with_openings_file', requestParameters.gltfWithOpeningsFile as any);
        }

        if (requestParameters.bvhTreeFile !== undefined) {
            formParams.append('bvh_tree_file', requestParameters.bvhTreeFile as any);
        }

        if (requestParameters.viewer360File !== undefined) {
            formParams.append('viewer_360_file', requestParameters.viewer360File as any);
        }

        if (requestParameters.xktFile !== undefined) {
            formParams.append('xkt_file', requestParameters.xktFile as any);
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{id}/files`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelFilesFromJSON(jsonValue));
    }

    /**
     * This route does not accept JSON, only files as x-www-form-urlencoded  Required scopes: ifc:write, model:write
     * Update models file (gltf, svg, structure, etc)
     */
    async updateModelFiles(cloudPk: number, id: number, projectPk: number, structureFile?: Blob | null, systemsFile?: Blob | null, mapFile?: Blob | null, gltfFile?: Blob | null, gltfWithOpeningsFile?: Blob | null, bvhTreeFile?: Blob | null, viewer360File?: Blob | null, xktFile?: Blob | null): Promise<ModelFiles> {
        const response = await this.updateModelFilesRaw({ cloudPk: cloudPk, id: id, projectPk: projectPk, structureFile: structureFile, systemsFile: systemsFile, mapFile: mapFile, gltfFile: gltfFile, gltfWithOpeningsFile: gltfWithOpeningsFile, bvhTreeFile: bvhTreeFile, viewer360File: viewer360File, xktFile: xktFile });
        return await response.value();
    }

    /**
     * Update some fields of a Property  Required scopes: ifc:write, model:write
     * Update some fields of a Property
     */
    async updateModelPropertyRaw(requestParameters: UpdateModelPropertyRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateModelProperty.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateModelProperty.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateModelProperty.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateModelProperty.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/property/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPropertyRequestToJSON(requestParameters.patchedPropertyRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * Update some fields of a Property  Required scopes: ifc:write, model:write
     * Update some fields of a Property
     */
    async updateModelProperty(cloudPk: number, id: number, modelPk: number, projectPk: number, patchedPropertyRequest?: PatchedPropertyRequest): Promise<Property> {
        const response = await this.updateModelPropertyRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, patchedPropertyRequest: patchedPropertyRequest });
        return await response.value();
    }

    /**
     * Update some fields of many PropertyDefinitions of a model  Required scopes: ifc:write, model:write
     * Update some fields of many PropertyDefinitions of a model
     */
    async updateModelPropertyDefinitionRaw(requestParameters: UpdateModelPropertyDefinitionRequest): Promise<runtime.ApiResponse<PropertyDefinition>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateModelPropertyDefinition.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateModelPropertyDefinition.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateModelPropertyDefinition.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateModelPropertyDefinition.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertydefinition/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPropertyDefinitionRequestToJSON(requestParameters.patchedPropertyDefinitionRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyDefinitionFromJSON(jsonValue));
    }

    /**
     * Update some fields of many PropertyDefinitions of a model  Required scopes: ifc:write, model:write
     * Update some fields of many PropertyDefinitions of a model
     */
    async updateModelPropertyDefinition(cloudPk: number, id: number, modelPk: number, projectPk: number, patchedPropertyDefinitionRequest?: PatchedPropertyDefinitionRequest): Promise<PropertyDefinition> {
        const response = await this.updateModelPropertyDefinitionRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, patchedPropertyDefinitionRequest: patchedPropertyDefinitionRequest });
        return await response.value();
    }

    /**
     * Update some fields of a Unit of a model  Required scopes: ifc:write, model:write
     * Update some fields of a Unit of a model
     */
    async updateModelUnitRaw(requestParameters: UpdateModelUnitRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateModelUnit.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateModelUnit.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateModelUnit.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateModelUnit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/unit/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUnitRequestToJSON(requestParameters.patchedUnitRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     * Update some fields of a Unit of a model  Required scopes: ifc:write, model:write
     * Update some fields of a Unit of a model
     */
    async updateModelUnit(cloudPk: number, id: number, modelPk: number, projectPk: number, patchedUnitRequest?: PatchedUnitRequest): Promise<Unit> {
        const response = await this.updateModelUnitRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, patchedUnitRequest: patchedUnitRequest });
        return await response.value();
    }

    /**
     * Update order of all plan of a building  Required scopes: ifc:write, model:write
     * Update order of all plan of a building
     */
    async updateOrderBuildingPlanRaw(requestParameters: UpdateOrderBuildingPlanRequest): Promise<runtime.ApiResponse<Storey>> {
        if (requestParameters.buildingUuid === null || requestParameters.buildingUuid === undefined) {
            throw new runtime.RequiredError('buildingUuid','Required parameter requestParameters.buildingUuid was null or undefined when calling updateOrderBuildingPlan.');
        }

        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateOrderBuildingPlan.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateOrderBuildingPlan.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateOrderBuildingPlan.');
        }

        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling updateOrderBuildingPlan.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/building/{building_uuid}/plan/order`.replace(`{${"building_uuid"}}`, encodeURIComponent(String(requestParameters.buildingUuid))).replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreyFromJSON(jsonValue));
    }

    /**
     * Update order of all plan of a building  Required scopes: ifc:write, model:write
     * Update order of all plan of a building
     */
    async updateOrderBuildingPlan(buildingUuid: string, cloudPk: number, modelPk: number, projectPk: number, requestBody: Array<number>): Promise<Storey> {
        const response = await this.updateOrderBuildingPlanRaw({ buildingUuid: buildingUuid, cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, requestBody: requestBody });
        return await response.value();
    }

    /**
     * Update order of all plan of a storey  Required scopes: ifc:write, model:write
     * Update order of all plan of a storey
     */
    async updateOrderStoreyPlanRaw(requestParameters: UpdateOrderStoreyPlanRequest): Promise<runtime.ApiResponse<Storey>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateOrderStoreyPlan.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateOrderStoreyPlan.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateOrderStoreyPlan.');
        }

        if (requestParameters.storeyUuid === null || requestParameters.storeyUuid === undefined) {
            throw new runtime.RequiredError('storeyUuid','Required parameter requestParameters.storeyUuid was null or undefined when calling updateOrderStoreyPlan.');
        }

        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling updateOrderStoreyPlan.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{storey_uuid}/plan/order`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"storey_uuid"}}`, encodeURIComponent(String(requestParameters.storeyUuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreyFromJSON(jsonValue));
    }

    /**
     * Update order of all plan of a storey  Required scopes: ifc:write, model:write
     * Update order of all plan of a storey
     */
    async updateOrderStoreyPlan(cloudPk: number, modelPk: number, projectPk: number, storeyUuid: string, requestBody: Array<number>): Promise<Storey> {
        const response = await this.updateOrderStoreyPlanRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, storeyUuid: storeyUuid, requestBody: requestBody });
        return await response.value();
    }

    /**
     * Update order of all storey of a model  Required scopes: ifc:write, model:write
     * Update order of all storey of a model
     */
    async updateOrderStoreysRaw(requestParameters: UpdateOrderStoreysRequest): Promise<runtime.ApiResponse<Array<Storey>>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateOrderStoreys.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateOrderStoreys.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateOrderStoreys.');
        }

        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling updateOrderStoreys.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/order`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StoreyFromJSON));
    }

    /**
     * Update order of all storey of a model  Required scopes: ifc:write, model:write
     * Update order of all storey of a model
     */
    async updateOrderStoreys(cloudPk: number, modelPk: number, projectPk: number, requestBody: Array<string>): Promise<Array<Storey>> {
        const response = await this.updateOrderStoreysRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, requestBody: requestBody });
        return await response.value();
    }

    /**
     * Update the status of a processor handler  Required scopes: ifc:write, model:write
     * Update the status of a processor handler
     */
    async updateProcessorHandlerRaw(requestParameters: UpdateProcessorHandlerRequest): Promise<runtime.ApiResponse<ProcessorHandler>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateProcessorHandler.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateProcessorHandler.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateProcessorHandler.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateProcessorHandler.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/processorhandler/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedProcessorHandlerRequestToJSON(requestParameters.patchedProcessorHandlerRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessorHandlerFromJSON(jsonValue));
    }

    /**
     * Update the status of a processor handler  Required scopes: ifc:write, model:write
     * Update the status of a processor handler
     */
    async updateProcessorHandler(cloudPk: number, id: number, modelPk: number, projectPk: number, patchedProcessorHandlerRequest?: PatchedProcessorHandlerRequest): Promise<ProcessorHandler> {
        const response = await this.updateProcessorHandlerRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, patchedProcessorHandlerRequest: patchedProcessorHandlerRequest });
        return await response.value();
    }

    /**
     * Update some fields of a PropertySet  Required scopes: ifc:write, model:write
     * Update some fields of a PropertySet
     */
    async updatePropertySetRaw(requestParameters: UpdatePropertySetRequest): Promise<runtime.ApiResponse<PropertySet>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updatePropertySet.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updatePropertySet.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updatePropertySet.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updatePropertySet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/propertyset/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPropertySetRequestToJSON(requestParameters.patchedPropertySetRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertySetFromJSON(jsonValue));
    }

    /**
     * Update some fields of a PropertySet  Required scopes: ifc:write, model:write
     * Update some fields of a PropertySet
     */
    async updatePropertySet(cloudPk: number, id: number, modelPk: number, projectPk: number, patchedPropertySetRequest?: PatchedPropertySetRequest): Promise<PropertySet> {
        const response = await this.updatePropertySetRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, patchedPropertySetRequest: patchedPropertySetRequest });
        return await response.value();
    }

    /**
     * Update some fields of a space. The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update some fields of a space
     */
    async updateSpaceRaw(requestParameters: UpdateSpaceRequest): Promise<runtime.ApiResponse<Space>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateSpace.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/space/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSpaceRequestToJSON(requestParameters.patchedSpaceRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SpaceFromJSON(jsonValue));
    }

    /**
     * Update some fields of a space. The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update some fields of a space
     */
    async updateSpace(cloudPk: number, id: number, modelPk: number, projectPk: number, patchedSpaceRequest?: PatchedSpaceRequest): Promise<Space> {
        const response = await this.updateSpaceRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, patchedSpaceRequest: patchedSpaceRequest });
        return await response.value();
    }

    /**
     * Update some fields of a storey  Required scopes: ifc:write, model:write
     * Update some fields of a storey
     */
    async updateStoreyRaw(requestParameters: UpdateStoreyRequest): Promise<runtime.ApiResponse<Storey>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateStorey.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateStorey.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateStorey.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateStorey.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreyFromJSON(jsonValue));
    }

    /**
     * Update some fields of a storey  Required scopes: ifc:write, model:write
     * Update some fields of a storey
     */
    async updateStorey(cloudPk: number, modelPk: number, projectPk: number, uuid: string): Promise<Storey> {
        const response = await this.updateStoreyRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid });
        return await response.value();
    }

    /**
     * Update the postioning of the plan in the storey  Required scopes: ifc:write, model:write
     * Update the postioning of the plan in the storey
     */
    async updateStoreyPlanPositioningRaw(requestParameters: UpdateStoreyPlanPositioningRequest): Promise<runtime.ApiResponse<PositioningPlan>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateStoreyPlanPositioning.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateStoreyPlanPositioning.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateStoreyPlanPositioning.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateStoreyPlanPositioning.');
        }

        if (requestParameters.storeyUuid === null || requestParameters.storeyUuid === undefined) {
            throw new runtime.RequiredError('storeyUuid','Required parameter requestParameters.storeyUuid was null or undefined when calling updateStoreyPlanPositioning.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/storey/{storey_uuid}/plan/{id}/positioning`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"storey_uuid"}}`, encodeURIComponent(String(requestParameters.storeyUuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPositioningPlanRequestToJSON(requestParameters.patchedPositioningPlanRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PositioningPlanFromJSON(jsonValue));
    }

    /**
     * Update the postioning of the plan in the storey  Required scopes: ifc:write, model:write
     * Update the postioning of the plan in the storey
     */
    async updateStoreyPlanPositioning(cloudPk: number, id: number, modelPk: number, projectPk: number, storeyUuid: string, patchedPositioningPlanRequest?: PatchedPositioningPlanRequest): Promise<PositioningPlan> {
        const response = await this.updateStoreyPlanPositioningRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, storeyUuid: storeyUuid, patchedPositioningPlanRequest: patchedPositioningPlanRequest });
        return await response.value();
    }

    /**
     * Update some fields of a system. The IFC file will not be updated. The created system will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update some fields of a system
     */
    async updateSystemRaw(requestParameters: UpdateSystemRequest): Promise<runtime.ApiResponse<System>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateSystem.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateSystem.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateSystem.');
        }

        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling updateSystem.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/system/{uuid}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSystemRequestToJSON(requestParameters.patchedSystemRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SystemFromJSON(jsonValue));
    }

    /**
     * Update some fields of a system. The IFC file will not be updated. The created system will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update some fields of a system
     */
    async updateSystem(cloudPk: number, modelPk: number, projectPk: number, uuid: string, patchedSystemRequest?: PatchedSystemRequest): Promise<System> {
        const response = await this.updateSystemRaw({ cloudPk: cloudPk, modelPk: modelPk, projectPk: projectPk, uuid: uuid, patchedSystemRequest: patchedSystemRequest });
        return await response.value();
    }

    /**
     * Update some fields of a zone. The IFC file will not be updated. The created zone will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update some fields of a zone
     */
    async updateZoneRaw(requestParameters: UpdateZoneRequest): Promise<runtime.ApiResponse<Zone>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateZone.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateZone.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateZone.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateZone.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedZoneRequestToJSON(requestParameters.patchedZoneRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ZoneFromJSON(jsonValue));
    }

    /**
     * Update some fields of a zone. The IFC file will not be updated. The created zone will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update some fields of a zone
     */
    async updateZone(cloudPk: number, id: number, modelPk: number, projectPk: number, patchedZoneRequest?: PatchedZoneRequest): Promise<Zone> {
        const response = await this.updateZoneRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, patchedZoneRequest: patchedZoneRequest });
        return await response.value();
    }

    /**
     * Update some fields of a space. The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update some fields of a space
     */
    async updateZoneSpaceRaw(requestParameters: UpdateZoneSpaceRequest): Promise<runtime.ApiResponse<ZoneSpace>> {
        if (requestParameters.cloudPk === null || requestParameters.cloudPk === undefined) {
            throw new runtime.RequiredError('cloudPk','Required parameter requestParameters.cloudPk was null or undefined when calling updateZoneSpace.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateZoneSpace.');
        }

        if (requestParameters.modelPk === null || requestParameters.modelPk === undefined) {
            throw new runtime.RequiredError('modelPk','Required parameter requestParameters.modelPk was null or undefined when calling updateZoneSpace.');
        }

        if (requestParameters.projectPk === null || requestParameters.projectPk === undefined) {
            throw new runtime.RequiredError('projectPk','Required parameter requestParameters.projectPk was null or undefined when calling updateZoneSpace.');
        }

        if (requestParameters.zonePk === null || requestParameters.zonePk === undefined) {
            throw new runtime.RequiredError('zonePk','Required parameter requestParameters.zonePk was null or undefined when calling updateZoneSpace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("BIMData_Connect", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Bearer authentication
        }

        const response = await this.request({
            path: `/cloud/{cloud_pk}/project/{project_pk}/model/{model_pk}/zone/{zone_pk}/space/{id}`.replace(`{${"cloud_pk"}}`, encodeURIComponent(String(requestParameters.cloudPk))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"model_pk"}}`, encodeURIComponent(String(requestParameters.modelPk))).replace(`{${"project_pk"}}`, encodeURIComponent(String(requestParameters.projectPk))).replace(`{${"zone_pk"}}`, encodeURIComponent(String(requestParameters.zonePk))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedZoneSpaceRequestToJSON(requestParameters.patchedZoneSpaceRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ZoneSpaceFromJSON(jsonValue));
    }

    /**
     * Update some fields of a space. The IFC file will not be updated. The created space will be accessible over the API and when exporting an IFC file  Required scopes: ifc:write, model:write
     * Update some fields of a space
     */
    async updateZoneSpace(cloudPk: number, id: number, modelPk: number, projectPk: number, zonePk: number, patchedZoneSpaceRequest?: PatchedZoneSpaceRequest): Promise<ZoneSpace> {
        const response = await this.updateZoneSpaceRaw({ cloudPk: cloudPk, id: id, modelPk: modelPk, projectPk: projectPk, zonePk: zonePk, patchedZoneSpaceRequest: patchedZoneSpaceRequest });
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetModelsSourceEnum {
    EXPORT = 'EXPORT',
    MERGE = 'MERGE',
    OPTIMIZED = 'OPTIMIZED',
    SPLIT = 'SPLIT',
    UPLOAD = 'UPLOAD'
}
/**
    * @export
    * @enum {string}
    */
export enum GetModelsStatusEnum {
    C = 'C',
    D = 'D',
    E = 'E',
    I = 'I',
    P = 'P',
    W = 'W',
    X = 'X'
}
/**
    * @export
    * @enum {string}
    */
export enum GetModelsTypeEnum {
    BFX = 'BFX',
    DAE = 'DAE',
    DWG = 'DWG',
    DXF = 'DXF',
    GLTF = 'GLTF',
    IFC = 'IFC',
    JPEG = 'JPEG',
    METABUILDING = 'METABUILDING',
    OBJ = 'OBJ',
    PDF = 'PDF',
    PNG = 'PNG'
}
